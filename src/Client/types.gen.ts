// This file is auto-generated by @hey-api/openapi-ts

/**
 * An entity representing a user's access schedule.
 */
export type AccessSchedule = {
    /**
     * Gets the id of this instance.
     */
    readonly Id?: number;
    /**
     * Gets the id of the associated user.
     */
    UserId?: string;
    /**
     * Gets or sets the day of week.
     */
    DayOfWeek?: 'Sunday' | 'Monday' | 'Tuesday' | 'Wednesday' | 'Thursday' | 'Friday' | 'Saturday' | 'Everyday' | 'Weekday' | 'Weekend';
    /**
     * Gets or sets the start hour.
     */
    StartHour?: number;
    /**
     * Gets or sets the end hour.
     */
    EndHour?: number;
};

/**
 * An activity log entry.
 */
export type ActivityLogEntry = {
    /**
     * Gets or sets the identifier.
     */
    Id?: number;
    /**
     * Gets or sets the name.
     */
    Name?: string;
    /**
     * Gets or sets the overview.
     */
    Overview?: string | null;
    /**
     * Gets or sets the short overview.
     */
    ShortOverview?: string | null;
    /**
     * Gets or sets the type.
     */
    Type?: string;
    /**
     * Gets or sets the item identifier.
     */
    ItemId?: string | null;
    /**
     * Gets or sets the date.
     */
    Date?: string;
    /**
     * Gets or sets the user identifier.
     */
    UserId?: string;
    /**
     * Gets or sets the user primary image tag.
     * @deprecated
     */
    UserPrimaryImageTag?: string | null;
    /**
     * Gets or sets the log severity.
     */
    Severity?: 'Trace' | 'Debug' | 'Information' | 'Warning' | 'Error' | 'Critical' | 'None';
};

/**
 * Activity log created message.
 */
export type ActivityLogEntryMessage = {
    /**
     * Gets or sets the data.
     */
    Data?: Array<ActivityLogEntry> | null;
    /**
     * Gets or sets the message id.
     */
    MessageId?: string;
    /**
     * The different kinds of messages that are used in the WebSocket api.
     */
    MessageType?: 'ForceKeepAlive' | 'GeneralCommand' | 'UserDataChanged' | 'Sessions' | 'Play' | 'SyncPlayCommand' | 'SyncPlayGroupUpdate' | 'Playstate' | 'RestartRequired' | 'ServerShuttingDown' | 'ServerRestarting' | 'LibraryChanged' | 'UserDeleted' | 'UserUpdated' | 'SeriesTimerCreated' | 'TimerCreated' | 'SeriesTimerCancelled' | 'TimerCancelled' | 'RefreshProgress' | 'ScheduledTaskEnded' | 'PackageInstallationCancelled' | 'PackageInstallationFailed' | 'PackageInstallationCompleted' | 'PackageInstalling' | 'PackageUninstalled' | 'ActivityLogEntry' | 'ScheduledTasksInfo' | 'ActivityLogEntryStart' | 'ActivityLogEntryStop' | 'SessionsStart' | 'SessionsStop' | 'ScheduledTasksInfoStart' | 'ScheduledTasksInfoStop' | 'KeepAlive';
};

/**
 * Query result container.
 */
export type ActivityLogEntryQueryResult = {
    /**
     * Gets or sets the items.
     */
    Items?: Array<ActivityLogEntry>;
    /**
     * Gets or sets the total number of records available.
     */
    TotalRecordCount?: number;
    /**
     * Gets or sets the index of the first record in Items.
     */
    StartIndex?: number;
};

/**
 * Activity log entry start message.
 * Data is the timing data encoded as "$initialDelay,$interval" in ms.
 */
export type ActivityLogEntryStartMessage = {
    /**
     * Gets or sets the data.
     */
    Data?: string | null;
    /**
     * The different kinds of messages that are used in the WebSocket api.
     */
    MessageType?: 'ForceKeepAlive' | 'GeneralCommand' | 'UserDataChanged' | 'Sessions' | 'Play' | 'SyncPlayCommand' | 'SyncPlayGroupUpdate' | 'Playstate' | 'RestartRequired' | 'ServerShuttingDown' | 'ServerRestarting' | 'LibraryChanged' | 'UserDeleted' | 'UserUpdated' | 'SeriesTimerCreated' | 'TimerCreated' | 'SeriesTimerCancelled' | 'TimerCancelled' | 'RefreshProgress' | 'ScheduledTaskEnded' | 'PackageInstallationCancelled' | 'PackageInstallationFailed' | 'PackageInstallationCompleted' | 'PackageInstalling' | 'PackageUninstalled' | 'ActivityLogEntry' | 'ScheduledTasksInfo' | 'ActivityLogEntryStart' | 'ActivityLogEntryStop' | 'SessionsStart' | 'SessionsStop' | 'ScheduledTasksInfoStart' | 'ScheduledTasksInfoStop' | 'KeepAlive';
};

/**
 * Activity log entry stop message.
 */
export type ActivityLogEntryStopMessage = {
    /**
     * The different kinds of messages that are used in the WebSocket api.
     */
    MessageType?: 'ForceKeepAlive' | 'GeneralCommand' | 'UserDataChanged' | 'Sessions' | 'Play' | 'SyncPlayCommand' | 'SyncPlayGroupUpdate' | 'Playstate' | 'RestartRequired' | 'ServerShuttingDown' | 'ServerRestarting' | 'LibraryChanged' | 'UserDeleted' | 'UserUpdated' | 'SeriesTimerCreated' | 'TimerCreated' | 'SeriesTimerCancelled' | 'TimerCancelled' | 'RefreshProgress' | 'ScheduledTaskEnded' | 'PackageInstallationCancelled' | 'PackageInstallationFailed' | 'PackageInstallationCompleted' | 'PackageInstalling' | 'PackageUninstalled' | 'ActivityLogEntry' | 'ScheduledTasksInfo' | 'ActivityLogEntryStart' | 'ActivityLogEntryStop' | 'SessionsStart' | 'SessionsStop' | 'ScheduledTasksInfoStart' | 'ScheduledTasksInfoStop' | 'KeepAlive';
};

/**
 * Add virtual folder dto.
 */
export type AddVirtualFolderDto = {
    /**
     * Gets or sets library options.
     */
    LibraryOptions?: LibraryOptions | null;
};

export type AlbumInfo = {
    /**
     * Gets or sets the name.
     */
    Name?: string | null;
    /**
     * Gets or sets the original title.
     */
    OriginalTitle?: string | null;
    /**
     * Gets or sets the path.
     */
    Path?: string | null;
    /**
     * Gets or sets the metadata language.
     */
    MetadataLanguage?: string | null;
    /**
     * Gets or sets the metadata country code.
     */
    MetadataCountryCode?: string | null;
    /**
     * Gets or sets the provider ids.
     */
    ProviderIds?: {
        [key: string]: string | null;
    } | null;
    /**
     * Gets or sets the year.
     */
    Year?: number | null;
    IndexNumber?: number | null;
    ParentIndexNumber?: number | null;
    PremiereDate?: string | null;
    IsAutomated?: boolean;
    /**
     * Gets or sets the album artist.
     */
    AlbumArtists?: Array<string>;
    /**
     * Gets or sets the artist provider ids.
     */
    ArtistProviderIds?: {
        [key: string]: string | null;
    };
    SongInfos?: Array<SongInfo>;
};

export type AlbumInfoRemoteSearchQuery = {
    SearchInfo?: AlbumInfo | null;
    ItemId?: string;
    /**
     * Gets or sets the provider name to search within if set.
     */
    SearchProviderName?: string | null;
    /**
     * Gets or sets a value indicating whether disabled providers should be included.
     */
    IncludeDisabledProviders?: boolean;
};

export type AllThemeMediaResult = {
    /**
     * Class ThemeMediaResult.
     */
    ThemeVideosResult?: ThemeMediaResult | null;
    /**
     * Class ThemeMediaResult.
     */
    ThemeSongsResult?: ThemeMediaResult | null;
    /**
     * Class ThemeMediaResult.
     */
    SoundtrackSongsResult?: ThemeMediaResult | null;
};

export type ArtistInfo = {
    /**
     * Gets or sets the name.
     */
    Name?: string | null;
    /**
     * Gets or sets the original title.
     */
    OriginalTitle?: string | null;
    /**
     * Gets or sets the path.
     */
    Path?: string | null;
    /**
     * Gets or sets the metadata language.
     */
    MetadataLanguage?: string | null;
    /**
     * Gets or sets the metadata country code.
     */
    MetadataCountryCode?: string | null;
    /**
     * Gets or sets the provider ids.
     */
    ProviderIds?: {
        [key: string]: string | null;
    } | null;
    /**
     * Gets or sets the year.
     */
    Year?: number | null;
    IndexNumber?: number | null;
    ParentIndexNumber?: number | null;
    PremiereDate?: string | null;
    IsAutomated?: boolean;
    SongInfos?: Array<SongInfo>;
};

export type ArtistInfoRemoteSearchQuery = {
    SearchInfo?: ArtistInfo | null;
    ItemId?: string;
    /**
     * Gets or sets the provider name to search within if set.
     */
    SearchProviderName?: string | null;
    /**
     * Gets or sets a value indicating whether disabled providers should be included.
     */
    IncludeDisabledProviders?: boolean;
};

/**
 * An enum representing formats of spatial audio.
 */
export type AudioSpatialFormat = 'None' | 'DolbyAtmos' | 'DTSX';

/**
 * The authenticate user by name request body.
 */
export type AuthenticateUserByName = {
    /**
     * Gets or sets the username.
     */
    Username?: string | null;
    /**
     * Gets or sets the plain text password.
     */
    Pw?: string | null;
};

export type AuthenticationInfo = {
    /**
     * Gets or sets the identifier.
     */
    Id?: number;
    /**
     * Gets or sets the access token.
     */
    AccessToken?: string | null;
    /**
     * Gets or sets the device identifier.
     */
    DeviceId?: string | null;
    /**
     * Gets or sets the name of the application.
     */
    AppName?: string | null;
    /**
     * Gets or sets the application version.
     */
    AppVersion?: string | null;
    /**
     * Gets or sets the name of the device.
     */
    DeviceName?: string | null;
    /**
     * Gets or sets the user identifier.
     */
    UserId?: string;
    /**
     * Gets or sets a value indicating whether this instance is active.
     */
    IsActive?: boolean;
    /**
     * Gets or sets the date created.
     */
    DateCreated?: string;
    /**
     * Gets or sets the date revoked.
     */
    DateRevoked?: string | null;
    DateLastActivity?: string;
    UserName?: string | null;
};

/**
 * Query result container.
 */
export type AuthenticationInfoQueryResult = {
    /**
     * Gets or sets the items.
     */
    Items?: Array<AuthenticationInfo>;
    /**
     * Gets or sets the total number of records available.
     */
    TotalRecordCount?: number;
    /**
     * Gets or sets the index of the first record in Items.
     */
    StartIndex?: number;
};

/**
 * A class representing an authentication result.
 */
export type AuthenticationResult = {
    /**
     * Gets or sets the user.
     */
    User?: UserDto | null;
    /**
     * Gets or sets the session info.
     */
    SessionInfo?: SessionInfoDto | null;
    /**
     * Gets or sets the access token.
     */
    AccessToken?: string | null;
    /**
     * Gets or sets the server id.
     */
    ServerId?: string | null;
};

/**
 * This is strictly used as a data transfer object from the api layer.
 * This holds information about a BaseItem in a format that is convenient for the client.
 */
export type BaseItemDto = {
    /**
     * Gets or sets the name.
     */
    Name?: string | null;
    OriginalTitle?: string | null;
    /**
     * Gets or sets the server identifier.
     */
    ServerId?: string | null;
    /**
     * Gets or sets the id.
     */
    Id?: string;
    /**
     * Gets or sets the etag.
     */
    Etag?: string | null;
    /**
     * Gets or sets the type of the source.
     */
    SourceType?: string | null;
    /**
     * Gets or sets the playlist item identifier.
     */
    PlaylistItemId?: string | null;
    /**
     * Gets or sets the date created.
     */
    DateCreated?: string | null;
    DateLastMediaAdded?: string | null;
    ExtraType?: 'Unknown' | 'Clip' | 'Trailer' | 'BehindTheScenes' | 'DeletedScene' | 'Interview' | 'Scene' | 'Sample' | 'ThemeSong' | 'ThemeVideo' | 'Featurette' | 'Short';
    AirsBeforeSeasonNumber?: number | null;
    AirsAfterSeasonNumber?: number | null;
    AirsBeforeEpisodeNumber?: number | null;
    CanDelete?: boolean | null;
    CanDownload?: boolean | null;
    HasLyrics?: boolean | null;
    HasSubtitles?: boolean | null;
    PreferredMetadataLanguage?: string | null;
    PreferredMetadataCountryCode?: string | null;
    Container?: string | null;
    /**
     * Gets or sets the name of the sort.
     */
    SortName?: string | null;
    ForcedSortName?: string | null;
    /**
     * Gets or sets the video3 D format.
     */
    Video3DFormat?: 'HalfSideBySide' | 'FullSideBySide' | 'FullTopAndBottom' | 'HalfTopAndBottom' | 'MVC';
    /**
     * Gets or sets the premiere date.
     */
    PremiereDate?: string | null;
    /**
     * Gets or sets the external urls.
     */
    ExternalUrls?: Array<ExternalUrl> | null;
    /**
     * Gets or sets the media versions.
     */
    MediaSources?: Array<MediaSourceInfo> | null;
    /**
     * Gets or sets the critic rating.
     */
    CriticRating?: number | null;
    ProductionLocations?: Array<string> | null;
    /**
     * Gets or sets the path.
     */
    Path?: string | null;
    EnableMediaSourceDisplay?: boolean | null;
    /**
     * Gets or sets the official rating.
     */
    OfficialRating?: string | null;
    /**
     * Gets or sets the custom rating.
     */
    CustomRating?: string | null;
    /**
     * Gets or sets the channel identifier.
     */
    ChannelId?: string | null;
    ChannelName?: string | null;
    /**
     * Gets or sets the overview.
     */
    Overview?: string | null;
    /**
     * Gets or sets the taglines.
     */
    Taglines?: Array<string> | null;
    /**
     * Gets or sets the genres.
     */
    Genres?: Array<string> | null;
    /**
     * Gets or sets the community rating.
     */
    CommunityRating?: number | null;
    /**
     * Gets or sets the cumulative run time ticks.
     */
    CumulativeRunTimeTicks?: number | null;
    /**
     * Gets or sets the run time ticks.
     */
    RunTimeTicks?: number | null;
    /**
     * Gets or sets the play access.
     */
    PlayAccess?: 'Full' | 'None';
    /**
     * Gets or sets the aspect ratio.
     */
    AspectRatio?: string | null;
    /**
     * Gets or sets the production year.
     */
    ProductionYear?: number | null;
    /**
     * Gets or sets a value indicating whether this instance is place holder.
     */
    IsPlaceHolder?: boolean | null;
    /**
     * Gets or sets the number.
     */
    Number?: string | null;
    ChannelNumber?: string | null;
    /**
     * Gets or sets the index number.
     */
    IndexNumber?: number | null;
    /**
     * Gets or sets the index number end.
     */
    IndexNumberEnd?: number | null;
    /**
     * Gets or sets the parent index number.
     */
    ParentIndexNumber?: number | null;
    /**
     * Gets or sets the trailer urls.
     */
    RemoteTrailers?: Array<MediaUrl> | null;
    /**
     * Gets or sets the provider ids.
     */
    ProviderIds?: {
        [key: string]: string | null;
    } | null;
    /**
     * Gets or sets a value indicating whether this instance is HD.
     */
    IsHD?: boolean | null;
    /**
     * Gets or sets a value indicating whether this instance is folder.
     */
    IsFolder?: boolean | null;
    /**
     * Gets or sets the parent id.
     */
    ParentId?: string | null;
    /**
     * The base item kind.
     */
    Type?: 'AggregateFolder' | 'Audio' | 'AudioBook' | 'BasePluginFolder' | 'Book' | 'BoxSet' | 'Channel' | 'ChannelFolderItem' | 'CollectionFolder' | 'Episode' | 'Folder' | 'Genre' | 'ManualPlaylistsFolder' | 'Movie' | 'LiveTvChannel' | 'LiveTvProgram' | 'MusicAlbum' | 'MusicArtist' | 'MusicGenre' | 'MusicVideo' | 'Person' | 'Photo' | 'PhotoAlbum' | 'Playlist' | 'PlaylistsFolder' | 'Program' | 'Recording' | 'Season' | 'Series' | 'Studio' | 'Trailer' | 'TvChannel' | 'TvProgram' | 'UserRootFolder' | 'UserView' | 'Video' | 'Year';
    /**
     * Gets or sets the people.
     */
    People?: Array<BaseItemPerson> | null;
    /**
     * Gets or sets the studios.
     */
    Studios?: Array<NameGuidPair> | null;
    GenreItems?: Array<NameGuidPair> | null;
    /**
     * Gets or sets whether the item has a logo, this will hold the Id of the Parent that has one.
     */
    ParentLogoItemId?: string | null;
    /**
     * Gets or sets whether the item has any backdrops, this will hold the Id of the Parent that has one.
     */
    ParentBackdropItemId?: string | null;
    /**
     * Gets or sets the parent backdrop image tags.
     */
    ParentBackdropImageTags?: Array<string> | null;
    /**
     * Gets or sets the local trailer count.
     */
    LocalTrailerCount?: number | null;
    /**
     * Gets or sets the user data for this item based on the user it's being requested for.
     */
    UserData?: UserItemDataDto | null;
    /**
     * Gets or sets the recursive item count.
     */
    RecursiveItemCount?: number | null;
    /**
     * Gets or sets the child count.
     */
    ChildCount?: number | null;
    /**
     * Gets or sets the name of the series.
     */
    SeriesName?: string | null;
    /**
     * Gets or sets the series id.
     */
    SeriesId?: string | null;
    /**
     * Gets or sets the season identifier.
     */
    SeasonId?: string | null;
    /**
     * Gets or sets the special feature count.
     */
    SpecialFeatureCount?: number | null;
    /**
     * Gets or sets the display preferences id.
     */
    DisplayPreferencesId?: string | null;
    /**
     * Gets or sets the status.
     */
    Status?: string | null;
    /**
     * Gets or sets the air time.
     */
    AirTime?: string | null;
    /**
     * Gets or sets the air days.
     */
    AirDays?: Array<DayOfWeek> | null;
    /**
     * Gets or sets the tags.
     */
    Tags?: Array<string> | null;
    /**
     * Gets or sets the primary image aspect ratio, after image enhancements.
     */
    PrimaryImageAspectRatio?: number | null;
    /**
     * Gets or sets the artists.
     */
    Artists?: Array<string> | null;
    /**
     * Gets or sets the artist items.
     */
    ArtistItems?: Array<NameGuidPair> | null;
    /**
     * Gets or sets the album.
     */
    Album?: string | null;
    /**
     * Gets or sets the type of the collection.
     */
    CollectionType?: 'unknown' | 'movies' | 'tvshows' | 'music' | 'musicvideos' | 'trailers' | 'homevideos' | 'boxsets' | 'books' | 'photos' | 'livetv' | 'playlists' | 'folders';
    /**
     * Gets or sets the display order.
     */
    DisplayOrder?: string | null;
    /**
     * Gets or sets the album id.
     */
    AlbumId?: string | null;
    /**
     * Gets or sets the album image tag.
     */
    AlbumPrimaryImageTag?: string | null;
    /**
     * Gets or sets the series primary image tag.
     */
    SeriesPrimaryImageTag?: string | null;
    /**
     * Gets or sets the album artist.
     */
    AlbumArtist?: string | null;
    /**
     * Gets or sets the album artists.
     */
    AlbumArtists?: Array<NameGuidPair> | null;
    /**
     * Gets or sets the name of the season.
     */
    SeasonName?: string | null;
    /**
     * Gets or sets the media streams.
     */
    MediaStreams?: Array<MediaStream> | null;
    /**
     * Gets or sets the type of the video.
     */
    VideoType?: 'VideoFile' | 'Iso' | 'Dvd' | 'BluRay';
    /**
     * Gets or sets the part count.
     */
    PartCount?: number | null;
    MediaSourceCount?: number | null;
    /**
     * Gets or sets the image tags.
     */
    ImageTags?: {
        [key: string]: string;
    } | null;
    /**
     * Gets or sets the backdrop image tags.
     */
    BackdropImageTags?: Array<string> | null;
    /**
     * Gets or sets the screenshot image tags.
     */
    ScreenshotImageTags?: Array<string> | null;
    /**
     * Gets or sets the parent logo image tag.
     */
    ParentLogoImageTag?: string | null;
    /**
     * Gets or sets whether the item has fan art, this will hold the Id of the Parent that has one.
     */
    ParentArtItemId?: string | null;
    /**
     * Gets or sets the parent art image tag.
     */
    ParentArtImageTag?: string | null;
    /**
     * Gets or sets the series thumb image tag.
     */
    SeriesThumbImageTag?: string | null;
    /**
     * Gets or sets the blurhashes for the image tags.
     * Maps image type to dictionary mapping image tag to blurhash value.
     */
    ImageBlurHashes?: {
        Primary?: {
            [key: string]: string;
        };
        Art?: {
            [key: string]: string;
        };
        Backdrop?: {
            [key: string]: string;
        };
        Banner?: {
            [key: string]: string;
        };
        Logo?: {
            [key: string]: string;
        };
        Thumb?: {
            [key: string]: string;
        };
        Disc?: {
            [key: string]: string;
        };
        Box?: {
            [key: string]: string;
        };
        Screenshot?: {
            [key: string]: string;
        };
        Menu?: {
            [key: string]: string;
        };
        Chapter?: {
            [key: string]: string;
        };
        BoxRear?: {
            [key: string]: string;
        };
        Profile?: {
            [key: string]: string;
        };
    } | null;
    /**
     * Gets or sets the series studio.
     */
    SeriesStudio?: string | null;
    /**
     * Gets or sets the parent thumb item id.
     */
    ParentThumbItemId?: string | null;
    /**
     * Gets or sets the parent thumb image tag.
     */
    ParentThumbImageTag?: string | null;
    /**
     * Gets or sets the parent primary image item identifier.
     */
    ParentPrimaryImageItemId?: string | null;
    /**
     * Gets or sets the parent primary image tag.
     */
    ParentPrimaryImageTag?: string | null;
    /**
     * Gets or sets the chapters.
     */
    Chapters?: Array<ChapterInfo> | null;
    /**
     * Gets or sets the trickplay manifest.
     */
    Trickplay?: {
        [key: string]: {
            [key: string]: TrickplayInfo;
        };
    } | null;
    /**
     * Gets or sets the type of the location.
     */
    LocationType?: 'FileSystem' | 'Remote' | 'Virtual' | 'Offline';
    /**
     * Gets or sets the type of the iso.
     */
    IsoType?: 'Dvd' | 'BluRay';
    /**
     * Media types.
     */
    MediaType?: 'Unknown' | 'Video' | 'Audio' | 'Photo' | 'Book';
    /**
     * Gets or sets the end date.
     */
    EndDate?: string | null;
    /**
     * Gets or sets the locked fields.
     */
    LockedFields?: Array<MetadataField> | null;
    /**
     * Gets or sets the trailer count.
     */
    TrailerCount?: number | null;
    /**
     * Gets or sets the movie count.
     */
    MovieCount?: number | null;
    /**
     * Gets or sets the series count.
     */
    SeriesCount?: number | null;
    ProgramCount?: number | null;
    /**
     * Gets or sets the episode count.
     */
    EpisodeCount?: number | null;
    /**
     * Gets or sets the song count.
     */
    SongCount?: number | null;
    /**
     * Gets or sets the album count.
     */
    AlbumCount?: number | null;
    ArtistCount?: number | null;
    /**
     * Gets or sets the music video count.
     */
    MusicVideoCount?: number | null;
    /**
     * Gets or sets a value indicating whether [enable internet providers].
     */
    LockData?: boolean | null;
    Width?: number | null;
    Height?: number | null;
    CameraMake?: string | null;
    CameraModel?: string | null;
    Software?: string | null;
    ExposureTime?: number | null;
    FocalLength?: number | null;
    ImageOrientation?: 'TopLeft' | 'TopRight' | 'BottomRight' | 'BottomLeft' | 'LeftTop' | 'RightTop' | 'RightBottom' | 'LeftBottom';
    Aperture?: number | null;
    ShutterSpeed?: number | null;
    Latitude?: number | null;
    Longitude?: number | null;
    Altitude?: number | null;
    IsoSpeedRating?: number | null;
    /**
     * Gets or sets the series timer identifier.
     */
    SeriesTimerId?: string | null;
    /**
     * Gets or sets the program identifier.
     */
    ProgramId?: string | null;
    /**
     * Gets or sets the channel primary image tag.
     */
    ChannelPrimaryImageTag?: string | null;
    /**
     * Gets or sets the start date of the recording, in UTC.
     */
    StartDate?: string | null;
    /**
     * Gets or sets the completion percentage.
     */
    CompletionPercentage?: number | null;
    /**
     * Gets or sets a value indicating whether this instance is repeat.
     */
    IsRepeat?: boolean | null;
    /**
     * Gets or sets the episode title.
     */
    EpisodeTitle?: string | null;
    /**
     * Gets or sets the type of the channel.
     */
    ChannelType?: 'TV' | 'Radio';
    /**
     * Gets or sets the audio.
     */
    Audio?: 'Mono' | 'Stereo' | 'Dolby' | 'DolbyDigital' | 'Thx' | 'Atmos';
    /**
     * Gets or sets a value indicating whether this instance is movie.
     */
    IsMovie?: boolean | null;
    /**
     * Gets or sets a value indicating whether this instance is sports.
     */
    IsSports?: boolean | null;
    /**
     * Gets or sets a value indicating whether this instance is series.
     */
    IsSeries?: boolean | null;
    /**
     * Gets or sets a value indicating whether this instance is live.
     */
    IsLive?: boolean | null;
    /**
     * Gets or sets a value indicating whether this instance is news.
     */
    IsNews?: boolean | null;
    /**
     * Gets or sets a value indicating whether this instance is kids.
     */
    IsKids?: boolean | null;
    /**
     * Gets or sets a value indicating whether this instance is premiere.
     */
    IsPremiere?: boolean | null;
    /**
     * Gets or sets the timer identifier.
     */
    TimerId?: string | null;
    /**
     * Gets or sets the gain required for audio normalization.
     */
    NormalizationGain?: number | null;
    /**
     * Gets or sets the current program.
     */
    CurrentProgram?: BaseItemDto | null;
};

/**
 * Query result container.
 */
export type BaseItemDtoQueryResult = {
    /**
     * Gets or sets the items.
     */
    Items?: Array<BaseItemDto>;
    /**
     * Gets or sets the total number of records available.
     */
    TotalRecordCount?: number;
    /**
     * Gets or sets the index of the first record in Items.
     */
    StartIndex?: number;
};

/**
 * The base item kind.
 */
export type BaseItemKind = 'AggregateFolder' | 'Audio' | 'AudioBook' | 'BasePluginFolder' | 'Book' | 'BoxSet' | 'Channel' | 'ChannelFolderItem' | 'CollectionFolder' | 'Episode' | 'Folder' | 'Genre' | 'ManualPlaylistsFolder' | 'Movie' | 'LiveTvChannel' | 'LiveTvProgram' | 'MusicAlbum' | 'MusicArtist' | 'MusicGenre' | 'MusicVideo' | 'Person' | 'Photo' | 'PhotoAlbum' | 'Playlist' | 'PlaylistsFolder' | 'Program' | 'Recording' | 'Season' | 'Series' | 'Studio' | 'Trailer' | 'TvChannel' | 'TvProgram' | 'UserRootFolder' | 'UserView' | 'Video' | 'Year';

/**
 * This is used by the api to get information about a Person within a BaseItem.
 */
export type BaseItemPerson = {
    /**
     * Gets or sets the name.
     */
    Name?: string | null;
    /**
     * Gets or sets the identifier.
     */
    Id?: string;
    /**
     * Gets or sets the role.
     */
    Role?: string | null;
    /**
     * The person kind.
     */
    Type?: 'Unknown' | 'Actor' | 'Director' | 'Composer' | 'Writer' | 'GuestStar' | 'Producer' | 'Conductor' | 'Lyricist' | 'Arranger' | 'Engineer' | 'Mixer' | 'Remixer' | 'Creator' | 'Artist' | 'AlbumArtist' | 'Author' | 'Illustrator' | 'Penciller' | 'Inker' | 'Colorist' | 'Letterer' | 'CoverArtist' | 'Editor' | 'Translator';
    /**
     * Gets or sets the primary image tag.
     */
    PrimaryImageTag?: string | null;
    /**
     * Gets or sets the primary image blurhash.
     */
    ImageBlurHashes?: {
        Primary?: {
            [key: string]: string;
        };
        Art?: {
            [key: string]: string;
        };
        Backdrop?: {
            [key: string]: string;
        };
        Banner?: {
            [key: string]: string;
        };
        Logo?: {
            [key: string]: string;
        };
        Thumb?: {
            [key: string]: string;
        };
        Disc?: {
            [key: string]: string;
        };
        Box?: {
            [key: string]: string;
        };
        Screenshot?: {
            [key: string]: string;
        };
        Menu?: {
            [key: string]: string;
        };
        Chapter?: {
            [key: string]: string;
        };
        BoxRear?: {
            [key: string]: string;
        };
        Profile?: {
            [key: string]: string;
        };
    } | null;
};

/**
 * Class BasePluginConfiguration.
 */
export type BasePluginConfiguration = {
    [key: string]: never;
};

export type BookInfo = {
    /**
     * Gets or sets the name.
     */
    Name?: string | null;
    /**
     * Gets or sets the original title.
     */
    OriginalTitle?: string | null;
    /**
     * Gets or sets the path.
     */
    Path?: string | null;
    /**
     * Gets or sets the metadata language.
     */
    MetadataLanguage?: string | null;
    /**
     * Gets or sets the metadata country code.
     */
    MetadataCountryCode?: string | null;
    /**
     * Gets or sets the provider ids.
     */
    ProviderIds?: {
        [key: string]: string | null;
    } | null;
    /**
     * Gets or sets the year.
     */
    Year?: number | null;
    IndexNumber?: number | null;
    ParentIndexNumber?: number | null;
    PremiereDate?: string | null;
    IsAutomated?: boolean;
    SeriesName?: string | null;
};

export type BookInfoRemoteSearchQuery = {
    SearchInfo?: BookInfo | null;
    ItemId?: string;
    /**
     * Gets or sets the provider name to search within if set.
     */
    SearchProviderName?: string | null;
    /**
     * Gets or sets a value indicating whether disabled providers should be included.
     */
    IncludeDisabledProviders?: boolean;
};

export type BoxSetInfo = {
    /**
     * Gets or sets the name.
     */
    Name?: string | null;
    /**
     * Gets or sets the original title.
     */
    OriginalTitle?: string | null;
    /**
     * Gets or sets the path.
     */
    Path?: string | null;
    /**
     * Gets or sets the metadata language.
     */
    MetadataLanguage?: string | null;
    /**
     * Gets or sets the metadata country code.
     */
    MetadataCountryCode?: string | null;
    /**
     * Gets or sets the provider ids.
     */
    ProviderIds?: {
        [key: string]: string | null;
    } | null;
    /**
     * Gets or sets the year.
     */
    Year?: number | null;
    IndexNumber?: number | null;
    ParentIndexNumber?: number | null;
    PremiereDate?: string | null;
    IsAutomated?: boolean;
};

export type BoxSetInfoRemoteSearchQuery = {
    SearchInfo?: BoxSetInfo | null;
    ItemId?: string;
    /**
     * Gets or sets the provider name to search within if set.
     */
    SearchProviderName?: string | null;
    /**
     * Gets or sets a value indicating whether disabled providers should be included.
     */
    IncludeDisabledProviders?: boolean;
};

/**
 * The branding options.
 */
export type BrandingOptions = {
    /**
     * Gets or sets the login disclaimer.
     */
    LoginDisclaimer?: string | null;
    /**
     * Gets or sets the custom CSS.
     */
    CustomCss?: string | null;
    /**
     * Gets or sets a value indicating whether to enable the splashscreen.
     */
    SplashscreenEnabled?: boolean;
};

/**
 * Class BufferRequestDto.
 */
export type BufferRequestDto = {
    /**
     * Gets or sets when the request has been made by the client.
     */
    When?: string;
    /**
     * Gets or sets the position ticks.
     */
    PositionTicks?: number;
    /**
     * Gets or sets a value indicating whether the client playback is unpaused.
     */
    IsPlaying?: boolean;
    /**
     * Gets or sets the playlist item identifier of the playing item.
     */
    PlaylistItemId?: string;
};

/**
 * The cast receiver application model.
 */
export type CastReceiverApplication = {
    /**
     * Gets or sets the cast receiver application id.
     */
    Id?: string;
    /**
     * Gets or sets the cast receiver application name.
     */
    Name?: string;
};

export type ChannelFeatures = {
    /**
     * Gets or sets the name.
     */
    Name?: string;
    /**
     * Gets or sets the identifier.
     */
    Id?: string;
    /**
     * Gets or sets a value indicating whether this instance can search.
     */
    CanSearch?: boolean;
    /**
     * Gets or sets the media types.
     */
    MediaTypes?: Array<ChannelMediaType>;
    /**
     * Gets or sets the content types.
     */
    ContentTypes?: Array<ChannelMediaContentType>;
    /**
     * Gets or sets the maximum number of records the channel allows retrieving at a time.
     */
    MaxPageSize?: number | null;
    /**
     * Gets or sets the automatic refresh levels.
     */
    AutoRefreshLevels?: number | null;
    /**
     * Gets or sets the default sort orders.
     */
    DefaultSortFields?: Array<ChannelItemSortField>;
    /**
     * Gets or sets a value indicating whether a sort ascending/descending toggle is supported.
     */
    SupportsSortOrderToggle?: boolean;
    /**
     * Gets or sets a value indicating whether [supports latest media].
     */
    SupportsLatestMedia?: boolean;
    /**
     * Gets or sets a value indicating whether this instance can filter.
     */
    CanFilter?: boolean;
    /**
     * Gets or sets a value indicating whether [supports content downloading].
     */
    SupportsContentDownloading?: boolean;
};

export type ChannelItemSortField = 'Name' | 'CommunityRating' | 'PremiereDate' | 'DateCreated' | 'Runtime' | 'PlayCount' | 'CommunityPlayCount';

/**
 * Channel mapping options dto.
 */
export type ChannelMappingOptionsDto = {
    /**
     * Gets or sets list of tuner channels.
     */
    TunerChannels?: Array<TunerChannelMapping>;
    /**
     * Gets or sets list of provider channels.
     */
    ProviderChannels?: Array<NameIdPair>;
    /**
     * Gets or sets list of mappings.
     */
    Mappings?: Array<NameValuePair>;
    /**
     * Gets or sets provider name.
     */
    ProviderName?: string | null;
};

export type ChannelMediaContentType = 'Clip' | 'Podcast' | 'Trailer' | 'Movie' | 'Episode' | 'Song' | 'MovieExtra' | 'TvExtra';

export type ChannelMediaType = 'Audio' | 'Video' | 'Photo';

/**
 * Enum ChannelType.
 */
export type ChannelType = 'TV' | 'Radio';

/**
 * Class ChapterInfo.
 */
export type ChapterInfo = {
    /**
     * Gets or sets the start position ticks.
     */
    StartPositionTicks?: number;
    /**
     * Gets or sets the name.
     */
    Name?: string | null;
    /**
     * Gets or sets the image path.
     */
    ImagePath?: string | null;
    ImageDateModified?: string;
    ImageTag?: string | null;
};

/**
 * Client capabilities dto.
 */
export type ClientCapabilitiesDto = {
    /**
     * Gets or sets the list of playable media types.
     */
    PlayableMediaTypes?: Array<MediaType>;
    /**
     * Gets or sets the list of supported commands.
     */
    SupportedCommands?: Array<GeneralCommandType>;
    /**
     * Gets or sets a value indicating whether session supports media control.
     */
    SupportsMediaControl?: boolean;
    /**
     * Gets or sets a value indicating whether session supports a persistent identifier.
     */
    SupportsPersistentIdentifier?: boolean;
    /**
     * Gets or sets the device profile.
     */
    DeviceProfile?: DeviceProfile | null;
    /**
     * Gets or sets the app store url.
     */
    AppStoreUrl?: string | null;
    /**
     * Gets or sets the icon url.
     */
    IconUrl?: string | null;
};

/**
 * Client log document response dto.
 */
export type ClientLogDocumentResponseDto = {
    /**
     * Gets the resulting filename.
     */
    FileName?: string;
};

/**
 * Defines the MediaBrowser.Model.Dlna.CodecProfile.
 */
export type CodecProfile = {
    /**
     * Gets or sets the MediaBrowser.Model.Dlna.CodecType which this container must meet.
     */
    Type?: 'Video' | 'VideoAudio' | 'Audio';
    /**
     * Gets or sets the list of MediaBrowser.Model.Dlna.ProfileCondition which this profile must meet.
     */
    Conditions?: Array<ProfileCondition>;
    /**
     * Gets or sets the list of MediaBrowser.Model.Dlna.ProfileCondition to apply if this profile is met.
     */
    ApplyConditions?: Array<ProfileCondition>;
    /**
     * Gets or sets the codec(s) that this profile applies to.
     */
    Codec?: string | null;
    /**
     * Gets or sets the container(s) which this profile will be applied to.
     */
    Container?: string | null;
    /**
     * Gets or sets the sub-container(s) which this profile will be applied to.
     */
    SubContainer?: string | null;
};

export type CodecType = 'Video' | 'VideoAudio' | 'Audio';

export type CollectionCreationResult = {
    Id?: string;
};

/**
 * Collection type.
 */
export type CollectionType = 'unknown' | 'movies' | 'tvshows' | 'music' | 'musicvideos' | 'trailers' | 'homevideos' | 'boxsets' | 'books' | 'photos' | 'livetv' | 'playlists' | 'folders';

/**
 * The collection type options.
 */
export type CollectionTypeOptions = 'movies' | 'tvshows' | 'music' | 'musicvideos' | 'homevideos' | 'boxsets' | 'books' | 'mixed';

export type ConfigImageTypes = {
    BackdropSizes?: Array<string> | null;
    BaseUrl?: string | null;
    LogoSizes?: Array<string> | null;
    PosterSizes?: Array<string> | null;
    ProfileSizes?: Array<string> | null;
    SecureBaseUrl?: string | null;
    StillSizes?: Array<string> | null;
};

/**
 * The configuration page info.
 */
export type ConfigurationPageInfo = {
    /**
     * Gets or sets the name.
     */
    Name?: string;
    /**
     * Gets or sets a value indicating whether the configurations page is enabled in the main menu.
     */
    EnableInMainMenu?: boolean;
    /**
     * Gets or sets the menu section.
     */
    MenuSection?: string | null;
    /**
     * Gets or sets the menu icon.
     */
    MenuIcon?: string | null;
    /**
     * Gets or sets the display name.
     */
    DisplayName?: string | null;
    /**
     * Gets or sets the plugin id.
     */
    PluginId?: string | null;
};

/**
 * Defines the MediaBrowser.Model.Dlna.ContainerProfile.
 */
export type ContainerProfile = {
    /**
     * Gets or sets the MediaBrowser.Model.Dlna.DlnaProfileType which this container must meet.
     */
    Type?: 'Audio' | 'Video' | 'Photo' | 'Subtitle' | 'Lyric';
    /**
     * Gets or sets the list of MediaBrowser.Model.Dlna.ProfileCondition which this container will be applied to.
     */
    Conditions?: Array<ProfileCondition>;
    /**
     * Gets or sets the container(s) which this container must meet.
     */
    Container?: string | null;
    /**
     * Gets or sets the sub container(s) which this container must meet.
     */
    SubContainer?: string | null;
};

/**
 * Class CountryInfo.
 */
export type CountryInfo = {
    /**
     * Gets or sets the name.
     */
    Name?: string | null;
    /**
     * Gets or sets the display name.
     */
    DisplayName?: string | null;
    /**
     * Gets or sets the name of the two letter ISO region.
     */
    TwoLetterISORegionName?: string | null;
    /**
     * Gets or sets the name of the three letter ISO region.
     */
    ThreeLetterISORegionName?: string | null;
};

/**
 * Create new playlist dto.
 */
export type CreatePlaylistDto = {
    /**
     * Gets or sets the name of the new playlist.
     */
    Name?: string;
    /**
     * Gets or sets item ids to add to the playlist.
     */
    Ids?: Array<string>;
    /**
     * Gets or sets the user id.
     */
    UserId?: string | null;
    /**
     * Gets or sets the media type.
     */
    MediaType?: 'Unknown' | 'Video' | 'Audio' | 'Photo' | 'Book';
    /**
     * Gets or sets the playlist users.
     */
    Users?: Array<PlaylistUserPermissions>;
    /**
     * Gets or sets a value indicating whether the playlist is public.
     */
    IsPublic?: boolean;
};

/**
 * The create user by name request body.
 */
export type CreateUserByName = {
    /**
     * Gets or sets the username.
     */
    Name: string;
    /**
     * Gets or sets the password.
     */
    Password?: string | null;
};

/**
 * Class CultureDto.
 */
export type CultureDto = {
    /**
     * Gets the name.
     */
    Name?: string;
    /**
     * Gets the display name.
     */
    DisplayName?: string;
    /**
     * Gets the name of the two letter ISO language.
     */
    TwoLetterISOLanguageName?: string;
    /**
     * Gets the name of the three letter ISO language.
     */
    readonly ThreeLetterISOLanguageName?: string | null;
    ThreeLetterISOLanguageNames?: Array<string>;
};

export type CustomQueryData = {
    CustomQueryString?: string;
    ReplaceUserId?: boolean;
};

export type DayOfWeek = 'Sunday' | 'Monday' | 'Tuesday' | 'Wednesday' | 'Thursday' | 'Friday' | 'Saturday';

export type DayPattern = 'Daily' | 'Weekdays' | 'Weekends';

/**
 * Default directory browser info.
 */
export type DefaultDirectoryBrowserInfoDto = {
    /**
     * Gets or sets the path.
     */
    Path?: string | null;
};

/**
 * Enum containing deinterlace methods.
 */
export type DeinterlaceMethod = 'yadif' | 'bwdif';

/**
 * A DTO representing device information.
 */
export type DeviceInfoDto = {
    /**
     * Gets or sets the name.
     */
    Name?: string | null;
    /**
     * Gets or sets the custom name.
     */
    CustomName?: string | null;
    /**
     * Gets or sets the access token.
     */
    AccessToken?: string | null;
    /**
     * Gets or sets the identifier.
     */
    Id?: string | null;
    /**
     * Gets or sets the last name of the user.
     */
    LastUserName?: string | null;
    /**
     * Gets or sets the name of the application.
     */
    AppName?: string | null;
    /**
     * Gets or sets the application version.
     */
    AppVersion?: string | null;
    /**
     * Gets or sets the last user identifier.
     */
    LastUserId?: string | null;
    /**
     * Gets or sets the date last modified.
     */
    DateLastActivity?: string | null;
    /**
     * Gets or sets the capabilities.
     */
    Capabilities?: ClientCapabilitiesDto;
    /**
     * Gets or sets the icon URL.
     */
    IconUrl?: string | null;
};

/**
 * Query result container.
 */
export type DeviceInfoDtoQueryResult = {
    /**
     * Gets or sets the items.
     */
    Items?: Array<DeviceInfoDto>;
    /**
     * Gets or sets the total number of records available.
     */
    TotalRecordCount?: number;
    /**
     * Gets or sets the index of the first record in Items.
     */
    StartIndex?: number;
};

/**
 * A dto representing custom options for a device.
 */
export type DeviceOptionsDto = {
    /**
     * Gets or sets the id.
     */
    Id?: number;
    /**
     * Gets or sets the device id.
     */
    DeviceId?: string | null;
    /**
     * Gets or sets the custom name.
     */
    CustomName?: string | null;
};

/**
 * A MediaBrowser.Model.Dlna.DeviceProfile represents a set of metadata which determines which content a certain device is able to play.
 * <br />
 * Specifically, it defines the supported <see cref="P:MediaBrowser.Model.Dlna.DeviceProfile.ContainerProfiles">containers</see> and
 * <see cref="P:MediaBrowser.Model.Dlna.DeviceProfile.CodecProfiles">codecs</see> (video and/or audio, including codec profiles and levels)
 * the device is able to direct play (without transcoding or remuxing),
 * as well as which <see cref="P:MediaBrowser.Model.Dlna.DeviceProfile.TranscodingProfiles">containers/codecs to transcode to</see> in case it isn't.
 */
export type DeviceProfile = {
    /**
     * Gets or sets the name of this device profile. User profiles must have a unique name.
     */
    Name?: string | null;
    /**
     * Gets or sets the unique internal identifier.
     */
    Id?: string | null;
    /**
     * Gets or sets the maximum allowed bitrate for all streamed content.
     */
    MaxStreamingBitrate?: number | null;
    /**
     * Gets or sets the maximum allowed bitrate for statically streamed content (= direct played files).
     */
    MaxStaticBitrate?: number | null;
    /**
     * Gets or sets the maximum allowed bitrate for transcoded music streams.
     */
    MusicStreamingTranscodingBitrate?: number | null;
    /**
     * Gets or sets the maximum allowed bitrate for statically streamed (= direct played) music files.
     */
    MaxStaticMusicBitrate?: number | null;
    /**
     * Gets or sets the direct play profiles.
     */
    DirectPlayProfiles?: Array<DirectPlayProfile>;
    /**
     * Gets or sets the transcoding profiles.
     */
    TranscodingProfiles?: Array<TranscodingProfile>;
    /**
     * Gets or sets the container profiles. Failing to meet these optional conditions causes transcoding to occur.
     */
    ContainerProfiles?: Array<ContainerProfile>;
    /**
     * Gets or sets the codec profiles.
     */
    CodecProfiles?: Array<CodecProfile>;
    /**
     * Gets or sets the subtitle profiles.
     */
    SubtitleProfiles?: Array<SubtitleProfile>;
};

/**
 * Defines the MediaBrowser.Model.Dlna.DirectPlayProfile.
 */
export type DirectPlayProfile = {
    /**
     * Gets or sets the container.
     */
    Container?: string;
    /**
     * Gets or sets the audio codec.
     */
    AudioCodec?: string | null;
    /**
     * Gets or sets the video codec.
     */
    VideoCodec?: string | null;
    /**
     * Gets or sets the Dlna profile type.
     */
    Type?: 'Audio' | 'Video' | 'Photo' | 'Subtitle' | 'Lyric';
};

/**
 * Defines the display preferences for any item that supports them (usually Folders).
 */
export type DisplayPreferencesDto = {
    /**
     * Gets or sets the user id.
     */
    Id?: string | null;
    /**
     * Gets or sets the type of the view.
     */
    ViewType?: string | null;
    /**
     * Gets or sets the sort by.
     */
    SortBy?: string | null;
    /**
     * Gets or sets the index by.
     */
    IndexBy?: string | null;
    /**
     * Gets or sets a value indicating whether [remember indexing].
     */
    RememberIndexing?: boolean;
    /**
     * Gets or sets the height of the primary image.
     */
    PrimaryImageHeight?: number;
    /**
     * Gets or sets the width of the primary image.
     */
    PrimaryImageWidth?: number;
    /**
     * Gets or sets the custom prefs.
     */
    CustomPrefs?: {
        [key: string]: string | null;
    };
    /**
     * An enum representing the axis that should be scrolled.
     */
    ScrollDirection?: 'Horizontal' | 'Vertical';
    /**
     * Gets or sets a value indicating whether to show backdrops on this item.
     */
    ShowBackdrop?: boolean;
    /**
     * Gets or sets a value indicating whether [remember sorting].
     */
    RememberSorting?: boolean;
    /**
     * An enum representing the sorting order.
     */
    SortOrder?: 'Ascending' | 'Descending';
    /**
     * Gets or sets a value indicating whether [show sidebar].
     */
    ShowSidebar?: boolean;
    /**
     * Gets or sets the client.
     */
    Client?: string | null;
};

export type DlnaProfileType = 'Audio' | 'Video' | 'Photo' | 'Subtitle' | 'Lyric';

/**
 * An enum representing an algorithm to downmix surround sound to stereo.
 */
export type DownMixStereoAlgorithms = 'None' | 'Dave750' | 'NightmodeDialogue' | 'Rfc7845' | 'Ac4';

/**
 * An enum that represents a day of the week, weekdays, weekends, or all days.
 */
export type DynamicDayOfWeek = 'Sunday' | 'Monday' | 'Tuesday' | 'Wednesday' | 'Thursday' | 'Friday' | 'Saturday' | 'Everyday' | 'Weekday' | 'Weekend';

/**
 * An enum representing the options to disable embedded subs.
 */
export type EmbeddedSubtitleOptions = 'AllowAll' | 'AllowText' | 'AllowImage' | 'AllowNone';

/**
 * Enum containing encoder presets.
 */
export type EncoderPreset = 'auto' | 'placebo' | 'veryslow' | 'slower' | 'slow' | 'medium' | 'fast' | 'faster' | 'veryfast' | 'superfast' | 'ultrafast';

export type EncodingContext = 'Streaming' | 'Static';

/**
 * Class EncodingOptions.
 */
export type EncodingOptions = {
    /**
     * Gets or sets the thread count used for encoding.
     */
    EncodingThreadCount?: number;
    /**
     * Gets or sets the temporary transcoding path.
     */
    TranscodingTempPath?: string | null;
    /**
     * Gets or sets the path to the fallback font.
     */
    FallbackFontPath?: string | null;
    /**
     * Gets or sets a value indicating whether to use the fallback font.
     */
    EnableFallbackFont?: boolean;
    /**
     * Gets or sets a value indicating whether audio VBR is enabled.
     */
    EnableAudioVbr?: boolean;
    /**
     * Gets or sets the audio boost applied when downmixing audio.
     */
    DownMixAudioBoost?: number;
    /**
     * Gets or sets the algorithm used for downmixing audio to stereo.
     */
    DownMixStereoAlgorithm?: 'None' | 'Dave750' | 'NightmodeDialogue' | 'Rfc7845' | 'Ac4';
    /**
     * Gets or sets the maximum size of the muxing queue.
     */
    MaxMuxingQueueSize?: number;
    /**
     * Gets or sets a value indicating whether throttling is enabled.
     */
    EnableThrottling?: boolean;
    /**
     * Gets or sets the delay after which throttling happens.
     */
    ThrottleDelaySeconds?: number;
    /**
     * Gets or sets a value indicating whether segment deletion is enabled.
     */
    EnableSegmentDeletion?: boolean;
    /**
     * Gets or sets seconds for which segments should be kept before being deleted.
     */
    SegmentKeepSeconds?: number;
    /**
     * Gets or sets the hardware acceleration type.
     */
    HardwareAccelerationType?: 'none' | 'amf' | 'qsv' | 'nvenc' | 'v4l2m2m' | 'vaapi' | 'videotoolbox' | 'rkmpp';
    /**
     * Gets or sets the FFmpeg path as set by the user via the UI.
     */
    EncoderAppPath?: string | null;
    /**
     * Gets or sets the current FFmpeg path being used by the system and displayed on the transcode page.
     */
    EncoderAppPathDisplay?: string | null;
    /**
     * Gets or sets the VA-API device.
     */
    VaapiDevice?: string | null;
    /**
     * Gets or sets the QSV device.
     */
    QsvDevice?: string | null;
    /**
     * Gets or sets a value indicating whether tonemapping is enabled.
     */
    EnableTonemapping?: boolean;
    /**
     * Gets or sets a value indicating whether VPP tonemapping is enabled.
     */
    EnableVppTonemapping?: boolean;
    /**
     * Gets or sets a value indicating whether videotoolbox tonemapping is enabled.
     */
    EnableVideoToolboxTonemapping?: boolean;
    /**
     * Gets or sets the tone-mapping algorithm.
     */
    TonemappingAlgorithm?: 'none' | 'clip' | 'linear' | 'gamma' | 'reinhard' | 'hable' | 'mobius' | 'bt2390';
    /**
     * Gets or sets the tone-mapping mode.
     */
    TonemappingMode?: 'auto' | 'max' | 'rgb' | 'lum' | 'itp';
    /**
     * Gets or sets the tone-mapping range.
     */
    TonemappingRange?: 'auto' | 'tv' | 'pc';
    /**
     * Gets or sets the tone-mapping desaturation.
     */
    TonemappingDesat?: number;
    /**
     * Gets or sets the tone-mapping peak.
     */
    TonemappingPeak?: number;
    /**
     * Gets or sets the tone-mapping parameters.
     */
    TonemappingParam?: number;
    /**
     * Gets or sets the VPP tone-mapping brightness.
     */
    VppTonemappingBrightness?: number;
    /**
     * Gets or sets the VPP tone-mapping contrast.
     */
    VppTonemappingContrast?: number;
    /**
     * Gets or sets the H264 CRF.
     */
    H264Crf?: number;
    /**
     * Gets or sets the H265 CRF.
     */
    H265Crf?: number;
    /**
     * Gets or sets the encoder preset.
     */
    EncoderPreset?: 'auto' | 'placebo' | 'veryslow' | 'slower' | 'slow' | 'medium' | 'fast' | 'faster' | 'veryfast' | 'superfast' | 'ultrafast';
    /**
     * Gets or sets a value indicating whether the framerate is doubled when deinterlacing.
     */
    DeinterlaceDoubleRate?: boolean;
    /**
     * Gets or sets the deinterlace method.
     */
    DeinterlaceMethod?: 'yadif' | 'bwdif';
    /**
     * Gets or sets a value indicating whether 10bit HEVC decoding is enabled.
     */
    EnableDecodingColorDepth10Hevc?: boolean;
    /**
     * Gets or sets a value indicating whether 10bit VP9 decoding is enabled.
     */
    EnableDecodingColorDepth10Vp9?: boolean;
    /**
     * Gets or sets a value indicating whether 8/10bit HEVC RExt decoding is enabled.
     */
    EnableDecodingColorDepth10HevcRext?: boolean;
    /**
     * Gets or sets a value indicating whether 12bit HEVC RExt decoding is enabled.
     */
    EnableDecodingColorDepth12HevcRext?: boolean;
    /**
     * Gets or sets a value indicating whether the enhanced NVDEC is enabled.
     */
    EnableEnhancedNvdecDecoder?: boolean;
    /**
     * Gets or sets a value indicating whether the system native hardware decoder should be used.
     */
    PreferSystemNativeHwDecoder?: boolean;
    /**
     * Gets or sets a value indicating whether the Intel H264 low-power hardware encoder should be used.
     */
    EnableIntelLowPowerH264HwEncoder?: boolean;
    /**
     * Gets or sets a value indicating whether the Intel HEVC low-power hardware encoder should be used.
     */
    EnableIntelLowPowerHevcHwEncoder?: boolean;
    /**
     * Gets or sets a value indicating whether hardware encoding is enabled.
     */
    EnableHardwareEncoding?: boolean;
    /**
     * Gets or sets a value indicating whether HEVC encoding is enabled.
     */
    AllowHevcEncoding?: boolean;
    /**
     * Gets or sets a value indicating whether AV1 encoding is enabled.
     */
    AllowAv1Encoding?: boolean;
    /**
     * Gets or sets a value indicating whether subtitle extraction is enabled.
     */
    EnableSubtitleExtraction?: boolean;
    /**
     * Gets or sets the codecs hardware encoding is used for.
     */
    HardwareDecodingCodecs?: Array<string> | null;
    /**
     * Gets or sets the file extensions on-demand metadata based keyframe extraction is enabled for.
     */
    AllowOnDemandMetadataBasedKeyframeExtractionForExtensions?: Array<string> | null;
};

export type EndPointInfo = {
    IsLocal?: boolean;
    IsInNetwork?: boolean;
};

/**
 * Represents the external id information for serialization to the client.
 */
export type ExternalIdInfo = {
    /**
     * Gets or sets the display name of the external id provider (IE: IMDB, MusicBrainz, etc).
     */
    Name?: string;
    /**
     * Gets or sets the unique key for this id. This key should be unique across all providers.
     */
    Key?: string;
    /**
     * Gets or sets the specific media type for this id. This is used to distinguish between the different
     * external id types for providers with multiple ids.
     * A null value indicates there is no specific media type associated with the external id, or this is the
     * default id for the external provider so there is no need to specify a type.
     */
    Type?: 'Album' | 'AlbumArtist' | 'Artist' | 'BoxSet' | 'Episode' | 'Movie' | 'OtherArtist' | 'Person' | 'ReleaseGroup' | 'Season' | 'Series' | 'Track' | 'Book';
    /**
     * Gets or sets the URL format string.
     * @deprecated
     */
    UrlFormatString?: string | null;
};

/**
 * The specific media type of an MediaBrowser.Model.Providers.ExternalIdInfo.
 */
export type ExternalIdMediaType = 'Album' | 'AlbumArtist' | 'Artist' | 'BoxSet' | 'Episode' | 'Movie' | 'OtherArtist' | 'Person' | 'ReleaseGroup' | 'Season' | 'Series' | 'Track' | 'Book';

export type ExternalUrl = {
    /**
     * Gets or sets the name.
     */
    Name?: string | null;
    /**
     * Gets or sets the type of the item.
     */
    Url?: string | null;
};

export type ExtraType = 'Unknown' | 'Clip' | 'Trailer' | 'BehindTheScenes' | 'DeletedScene' | 'Interview' | 'Scene' | 'Sample' | 'ThemeSong' | 'ThemeVideo' | 'Featurette' | 'Short';

/**
 * Class FileSystemEntryInfo.
 */
export type FileSystemEntryInfo = {
    /**
     * Gets the name.
     */
    Name?: string;
    /**
     * Gets the path.
     */
    Path?: string;
    /**
     * Gets the type.
     */
    Type?: 'File' | 'Directory' | 'NetworkComputer' | 'NetworkShare';
};

/**
 * Enum FileSystemEntryType.
 */
export type FileSystemEntryType = 'File' | 'Directory' | 'NetworkComputer' | 'NetworkShare';

/**
 * Class FontFile.
 */
export type FontFile = {
    /**
     * Gets or sets the name.
     */
    Name?: string | null;
    /**
     * Gets or sets the size.
     */
    Size?: number;
    /**
     * Gets or sets the date created.
     */
    DateCreated?: string;
    /**
     * Gets or sets the date modified.
     */
    DateModified?: string;
};

/**
 * Force keep alive websocket messages.
 */
export type ForceKeepAliveMessage = {
    /**
     * Gets or sets the data.
     */
    Data?: number;
    /**
     * Gets or sets the message id.
     */
    MessageId?: string;
    /**
     * The different kinds of messages that are used in the WebSocket api.
     */
    MessageType?: 'ForceKeepAlive' | 'GeneralCommand' | 'UserDataChanged' | 'Sessions' | 'Play' | 'SyncPlayCommand' | 'SyncPlayGroupUpdate' | 'Playstate' | 'RestartRequired' | 'ServerShuttingDown' | 'ServerRestarting' | 'LibraryChanged' | 'UserDeleted' | 'UserUpdated' | 'SeriesTimerCreated' | 'TimerCreated' | 'SeriesTimerCancelled' | 'TimerCancelled' | 'RefreshProgress' | 'ScheduledTaskEnded' | 'PackageInstallationCancelled' | 'PackageInstallationFailed' | 'PackageInstallationCompleted' | 'PackageInstalling' | 'PackageUninstalled' | 'ActivityLogEntry' | 'ScheduledTasksInfo' | 'ActivityLogEntryStart' | 'ActivityLogEntryStop' | 'SessionsStart' | 'SessionsStop' | 'ScheduledTasksInfoStart' | 'ScheduledTasksInfoStop' | 'KeepAlive';
};

export type ForgotPasswordAction = 'ContactAdmin' | 'PinCode' | 'InNetworkRequired';

/**
 * Forgot Password request body DTO.
 */
export type ForgotPasswordDto = {
    /**
     * Gets or sets the entered username to have its password reset.
     */
    EnteredUsername: string;
};

/**
 * Forgot Password Pin enter request body DTO.
 */
export type ForgotPasswordPinDto = {
    /**
     * Gets or sets the entered pin to have the password reset.
     */
    Pin: string;
};

export type ForgotPasswordResult = {
    /**
     * Gets or sets the action.
     */
    Action?: 'ContactAdmin' | 'PinCode' | 'InNetworkRequired';
    /**
     * Gets or sets the pin file.
     */
    PinFile?: string | null;
    /**
     * Gets or sets the pin expiration date.
     */
    PinExpirationDate?: string | null;
};

export type GeneralCommand = {
    /**
     * This exists simply to identify a set of known commands.
     */
    Name?: 'MoveUp' | 'MoveDown' | 'MoveLeft' | 'MoveRight' | 'PageUp' | 'PageDown' | 'PreviousLetter' | 'NextLetter' | 'ToggleOsd' | 'ToggleContextMenu' | 'Select' | 'Back' | 'TakeScreenshot' | 'SendKey' | 'SendString' | 'GoHome' | 'GoToSettings' | 'VolumeUp' | 'VolumeDown' | 'Mute' | 'Unmute' | 'ToggleMute' | 'SetVolume' | 'SetAudioStreamIndex' | 'SetSubtitleStreamIndex' | 'ToggleFullscreen' | 'DisplayContent' | 'GoToSearch' | 'DisplayMessage' | 'SetRepeatMode' | 'ChannelUp' | 'ChannelDown' | 'Guide' | 'ToggleStats' | 'PlayMediaSource' | 'PlayTrailers' | 'SetShuffleQueue' | 'PlayState' | 'PlayNext' | 'ToggleOsdMenu' | 'Play' | 'SetMaxStreamingBitrate' | 'SetPlaybackOrder';
    ControllingUserId?: string;
    Arguments?: {
        [key: string]: string | null;
    };
};

/**
 * General command websocket message.
 */
export type GeneralCommandMessage = {
    /**
     * Gets or sets the data.
     */
    Data?: GeneralCommand | null;
    /**
     * Gets or sets the message id.
     */
    MessageId?: string;
    /**
     * The different kinds of messages that are used in the WebSocket api.
     */
    MessageType?: 'ForceKeepAlive' | 'GeneralCommand' | 'UserDataChanged' | 'Sessions' | 'Play' | 'SyncPlayCommand' | 'SyncPlayGroupUpdate' | 'Playstate' | 'RestartRequired' | 'ServerShuttingDown' | 'ServerRestarting' | 'LibraryChanged' | 'UserDeleted' | 'UserUpdated' | 'SeriesTimerCreated' | 'TimerCreated' | 'SeriesTimerCancelled' | 'TimerCancelled' | 'RefreshProgress' | 'ScheduledTaskEnded' | 'PackageInstallationCancelled' | 'PackageInstallationFailed' | 'PackageInstallationCompleted' | 'PackageInstalling' | 'PackageUninstalled' | 'ActivityLogEntry' | 'ScheduledTasksInfo' | 'ActivityLogEntryStart' | 'ActivityLogEntryStop' | 'SessionsStart' | 'SessionsStop' | 'ScheduledTasksInfoStart' | 'ScheduledTasksInfoStop' | 'KeepAlive';
};

/**
 * This exists simply to identify a set of known commands.
 */
export type GeneralCommandType = 'MoveUp' | 'MoveDown' | 'MoveLeft' | 'MoveRight' | 'PageUp' | 'PageDown' | 'PreviousLetter' | 'NextLetter' | 'ToggleOsd' | 'ToggleContextMenu' | 'Select' | 'Back' | 'TakeScreenshot' | 'SendKey' | 'SendString' | 'GoHome' | 'GoToSettings' | 'VolumeUp' | 'VolumeDown' | 'Mute' | 'Unmute' | 'ToggleMute' | 'SetVolume' | 'SetAudioStreamIndex' | 'SetSubtitleStreamIndex' | 'ToggleFullscreen' | 'DisplayContent' | 'GoToSearch' | 'DisplayMessage' | 'SetRepeatMode' | 'ChannelUp' | 'ChannelDown' | 'Guide' | 'ToggleStats' | 'PlayMediaSource' | 'PlayTrailers' | 'SetShuffleQueue' | 'PlayState' | 'PlayNext' | 'ToggleOsdMenu' | 'Play' | 'SetMaxStreamingBitrate' | 'SetPlaybackOrder';

/**
 * Get programs dto.
 */
export type GetProgramsDto = {
    /**
     * Gets or sets the channels to return guide information for.
     */
    ChannelIds?: Array<string> | null;
    /**
     * Gets or sets optional. Filter by user id.
     */
    UserId?: string | null;
    /**
     * Gets or sets the minimum premiere start date.
     */
    MinStartDate?: string | null;
    /**
     * Gets or sets filter by programs that have completed airing, or not.
     */
    HasAired?: boolean | null;
    /**
     * Gets or sets filter by programs that are currently airing, or not.
     */
    IsAiring?: boolean | null;
    /**
     * Gets or sets the maximum premiere start date.
     */
    MaxStartDate?: string | null;
    /**
     * Gets or sets the minimum premiere end date.
     */
    MinEndDate?: string | null;
    /**
     * Gets or sets the maximum premiere end date.
     */
    MaxEndDate?: string | null;
    /**
     * Gets or sets filter for movies.
     */
    IsMovie?: boolean | null;
    /**
     * Gets or sets filter for series.
     */
    IsSeries?: boolean | null;
    /**
     * Gets or sets filter for news.
     */
    IsNews?: boolean | null;
    /**
     * Gets or sets filter for kids.
     */
    IsKids?: boolean | null;
    /**
     * Gets or sets filter for sports.
     */
    IsSports?: boolean | null;
    /**
     * Gets or sets the record index to start at. All items with a lower index will be dropped from the results.
     */
    StartIndex?: number | null;
    /**
     * Gets or sets the maximum number of records to return.
     */
    Limit?: number | null;
    /**
     * Gets or sets specify one or more sort orders, comma delimited. Options: Name, StartDate.
     */
    SortBy?: Array<ItemSortBy> | null;
    /**
     * Gets or sets sort order.
     */
    SortOrder?: Array<SortOrder> | null;
    /**
     * Gets or sets the genres to return guide information for.
     */
    Genres?: Array<string> | null;
    /**
     * Gets or sets the genre ids to return guide information for.
     */
    GenreIds?: Array<string> | null;
    /**
     * Gets or sets include image information in output.
     */
    EnableImages?: boolean | null;
    /**
     * Gets or sets a value indicating whether retrieve total record count.
     */
    EnableTotalRecordCount?: boolean;
    /**
     * Gets or sets the max number of images to return, per image type.
     */
    ImageTypeLimit?: number | null;
    /**
     * Gets or sets the image types to include in the output.
     */
    EnableImageTypes?: Array<ImageType> | null;
    /**
     * Gets or sets include user data.
     */
    EnableUserData?: boolean | null;
    /**
     * Gets or sets filter by series timer id.
     */
    SeriesTimerId?: string | null;
    /**
     * Gets or sets filter by library series id.
     */
    LibrarySeriesId?: string | null;
    /**
     * Gets or sets specify additional fields of information to return in the output.
     */
    Fields?: Array<ItemFields> | null;
};

/**
 * Class GroupInfoDto.
 */
export type GroupInfoDto = {
    /**
     * Gets the group identifier.
     */
    GroupId?: string;
    /**
     * Gets the group name.
     */
    GroupName?: string;
    /**
     * Gets the group state.
     */
    State?: 'Idle' | 'Waiting' | 'Paused' | 'Playing';
    /**
     * Gets the participants.
     */
    Participants?: Array<string>;
    /**
     * Gets the date when this DTO has been created.
     */
    LastUpdatedAt?: string;
};

/**
 * Class GroupUpdate.
 */
export type GroupInfoDtoGroupUpdate = {
    /**
     * Gets the group identifier.
     */
    readonly GroupId?: string;
    /**
     * Gets the update type.
     */
    Type?: 'UserJoined' | 'UserLeft' | 'GroupJoined' | 'GroupLeft' | 'StateUpdate' | 'PlayQueue' | 'NotInGroup' | 'GroupDoesNotExist' | 'CreateGroupDenied' | 'JoinGroupDenied' | 'LibraryAccessDenied';
    /**
     * Gets the update data.
     */
    Data?: GroupInfoDto;
};

/**
 * Enum GroupQueueMode.
 */
export type GroupQueueMode = 'Queue' | 'QueueNext';

/**
 * Enum GroupRepeatMode.
 */
export type GroupRepeatMode = 'RepeatOne' | 'RepeatAll' | 'RepeatNone';

/**
 * Enum GroupShuffleMode.
 */
export type GroupShuffleMode = 'Sorted' | 'Shuffle';

/**
 * Enum GroupState.
 */
export type GroupStateType = 'Idle' | 'Waiting' | 'Paused' | 'Playing';

/**
 * Class GroupStateUpdate.
 */
export type GroupStateUpdate = {
    /**
     * Gets the state of the group.
     */
    State?: 'Idle' | 'Waiting' | 'Paused' | 'Playing';
    /**
     * Gets the reason of the state change.
     */
    Reason?: 'Play' | 'SetPlaylistItem' | 'RemoveFromPlaylist' | 'MovePlaylistItem' | 'Queue' | 'Unpause' | 'Pause' | 'Stop' | 'Seek' | 'Buffer' | 'Ready' | 'NextItem' | 'PreviousItem' | 'SetRepeatMode' | 'SetShuffleMode' | 'Ping' | 'IgnoreWait';
};

/**
 * Class GroupUpdate.
 */
export type GroupStateUpdateGroupUpdate = {
    /**
     * Gets the group identifier.
     */
    readonly GroupId?: string;
    /**
     * Gets the update type.
     */
    Type?: 'UserJoined' | 'UserLeft' | 'GroupJoined' | 'GroupLeft' | 'StateUpdate' | 'PlayQueue' | 'NotInGroup' | 'GroupDoesNotExist' | 'CreateGroupDenied' | 'JoinGroupDenied' | 'LibraryAccessDenied';
    /**
     * Gets the update data.
     */
    Data?: GroupStateUpdate;
};

export type GroupUpdate = (({
    Type: 'GroupJoined';
} & GroupInfoDtoGroupUpdate) | ({
    Type: 'StateUpdate';
} & GroupStateUpdateGroupUpdate) | ({
    Type: 'UserJoined' | 'UserLeft' | 'GroupLeft' | 'NotInGroup' | 'GroupDoesNotExist' | 'LibraryAccessDenied';
} & StringGroupUpdate) | ({
    Type: 'PlayQueue';
} & PlayQueueUpdateGroupUpdate)) & {
    /**
     * Gets the group identifier.
     */
    readonly GroupId?: string;
    /**
     * Gets the update type.
     */
    Type?: 'UserJoined' | 'UserLeft' | 'GroupJoined' | 'GroupLeft' | 'StateUpdate' | 'PlayQueue' | 'NotInGroup' | 'GroupDoesNotExist' | 'CreateGroupDenied' | 'JoinGroupDenied' | 'LibraryAccessDenied';
};

/**
 * Enum GroupUpdateType.
 */
export type GroupUpdateType = 'UserJoined' | 'UserLeft' | 'GroupJoined' | 'GroupLeft' | 'StateUpdate' | 'PlayQueue' | 'NotInGroup' | 'GroupDoesNotExist' | 'CreateGroupDenied' | 'JoinGroupDenied' | 'LibraryAccessDenied';

export type GuideInfo = {
    /**
     * Gets or sets the start date.
     */
    StartDate?: string;
    /**
     * Gets or sets the end date.
     */
    EndDate?: string;
};

/**
 * Enum containing hardware acceleration types.
 */
export type HardwareAccelerationType = 'none' | 'amf' | 'qsv' | 'nvenc' | 'v4l2m2m' | 'vaapi' | 'videotoolbox' | 'rkmpp';

/**
 * Class IgnoreWaitRequestDto.
 */
export type IgnoreWaitRequestDto = {
    /**
     * Gets or sets a value indicating whether the client should be ignored.
     */
    IgnoreWait?: boolean;
};

/**
 * Enum ImageOutputFormat.
 */
export type ImageFormat = 'Bmp' | 'Gif' | 'Jpg' | 'Png' | 'Webp' | 'Svg';

/**
 * Class ImageInfo.
 */
export type ImageInfo = {
    /**
     * Gets or sets the type of the image.
     */
    ImageType?: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Profile';
    /**
     * Gets or sets the index of the image.
     */
    ImageIndex?: number | null;
    /**
     * Gets or sets the image tag.
     */
    ImageTag?: string | null;
    /**
     * Gets or sets the path.
     */
    Path?: string | null;
    /**
     * Gets or sets the blurhash.
     */
    BlurHash?: string | null;
    /**
     * Gets or sets the height.
     */
    Height?: number | null;
    /**
     * Gets or sets the width.
     */
    Width?: number | null;
    /**
     * Gets or sets the size.
     */
    Size?: number;
};

export type ImageOption = {
    /**
     * Gets or sets the type.
     */
    Type?: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Profile';
    /**
     * Gets or sets the limit.
     */
    Limit?: number;
    /**
     * Gets or sets the minimum width.
     */
    MinWidth?: number;
};

export type ImageOrientation = 'TopLeft' | 'TopRight' | 'BottomRight' | 'BottomLeft' | 'LeftTop' | 'RightTop' | 'RightBottom' | 'LeftBottom';

/**
 * Class ImageProviderInfo.
 */
export type ImageProviderInfo = {
    /**
     * Gets the name.
     */
    Name?: string;
    /**
     * Gets the supported image types.
     */
    SupportedImages?: Array<ImageType>;
};

/**
 * Enum ImageResolution.
 */
export type ImageResolution = 'MatchSource' | 'P144' | 'P240' | 'P360' | 'P480' | 'P720' | 'P1080' | 'P1440' | 'P2160';

export type ImageSavingConvention = 'Legacy' | 'Compatible';

/**
 * Enum ImageType.
 */
export type ImageType = 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Profile';

/**
 * Keep alive websocket messages.
 */
export type InboundKeepAliveMessage = {
    /**
     * The different kinds of messages that are used in the WebSocket api.
     */
    MessageType?: 'ForceKeepAlive' | 'GeneralCommand' | 'UserDataChanged' | 'Sessions' | 'Play' | 'SyncPlayCommand' | 'SyncPlayGroupUpdate' | 'Playstate' | 'RestartRequired' | 'ServerShuttingDown' | 'ServerRestarting' | 'LibraryChanged' | 'UserDeleted' | 'UserUpdated' | 'SeriesTimerCreated' | 'TimerCreated' | 'SeriesTimerCancelled' | 'TimerCancelled' | 'RefreshProgress' | 'ScheduledTaskEnded' | 'PackageInstallationCancelled' | 'PackageInstallationFailed' | 'PackageInstallationCompleted' | 'PackageInstalling' | 'PackageUninstalled' | 'ActivityLogEntry' | 'ScheduledTasksInfo' | 'ActivityLogEntryStart' | 'ActivityLogEntryStop' | 'SessionsStart' | 'SessionsStop' | 'ScheduledTasksInfoStart' | 'ScheduledTasksInfoStop' | 'KeepAlive';
};

/**
 * Represents the list of possible inbound websocket types
 */
export type InboundWebSocketMessage = ({
    MessageType: 'ActivityLogEntryStart';
} & ActivityLogEntryStartMessage) | ({
    MessageType: 'ActivityLogEntryStop';
} & ActivityLogEntryStopMessage) | ({
    MessageType: 'KeepAlive';
} & InboundKeepAliveMessage) | ({
    MessageType: 'ScheduledTasksInfoStart';
} & ScheduledTasksInfoStartMessage) | ({
    MessageType: 'ScheduledTasksInfoStop';
} & ScheduledTasksInfoStopMessage) | ({
    MessageType: 'SessionsStart';
} & SessionsStartMessage) | ({
    MessageType: 'SessionsStop';
} & SessionsStopMessage);

/**
 * Class InstallationInfo.
 */
export type InstallationInfo = {
    /**
     * Gets or sets the Id.
     */
    Guid?: string;
    /**
     * Gets or sets the name.
     */
    Name?: string | null;
    /**
     * Gets or sets the version.
     */
    Version?: string | null;
    /**
     * Gets or sets the changelog for this version.
     */
    Changelog?: string | null;
    /**
     * Gets or sets the source URL.
     */
    SourceUrl?: string | null;
    /**
     * Gets or sets a checksum for the binary.
     */
    Checksum?: string | null;
    /**
     * Gets or sets package information for the installation.
     */
    PackageInfo?: PackageInfo | null;
};

/**
 * Defines the MediaBrowser.Common.Plugins.IPlugin.
 */
export type IPlugin = {
    /**
     * Gets the name of the plugin.
     */
    readonly Name?: string | null;
    /**
     * Gets the Description.
     */
    readonly Description?: string | null;
    /**
     * Gets the unique id.
     */
    readonly Id?: string;
    /**
     * Gets the plugin version.
     */
    readonly Version?: string | null;
    /**
     * Gets the path to the assembly file.
     */
    readonly AssemblyFilePath?: string | null;
    /**
     * Gets a value indicating whether the plugin can be uninstalled.
     */
    readonly CanUninstall?: boolean;
    /**
     * Gets the full path to the data folder, where the plugin can store any miscellaneous files needed.
     */
    readonly DataFolderPath?: string | null;
};

/**
 * Enum IsoType.
 */
export type IsoType = 'Dvd' | 'BluRay';

/**
 * Class LibrarySummary.
 */
export type ItemCounts = {
    /**
     * Gets or sets the movie count.
     */
    MovieCount?: number;
    /**
     * Gets or sets the series count.
     */
    SeriesCount?: number;
    /**
     * Gets or sets the episode count.
     */
    EpisodeCount?: number;
    /**
     * Gets or sets the artist count.
     */
    ArtistCount?: number;
    /**
     * Gets or sets the program count.
     */
    ProgramCount?: number;
    /**
     * Gets or sets the trailer count.
     */
    TrailerCount?: number;
    /**
     * Gets or sets the song count.
     */
    SongCount?: number;
    /**
     * Gets or sets the album count.
     */
    AlbumCount?: number;
    /**
     * Gets or sets the music video count.
     */
    MusicVideoCount?: number;
    /**
     * Gets or sets the box set count.
     */
    BoxSetCount?: number;
    /**
     * Gets or sets the book count.
     */
    BookCount?: number;
    /**
     * Gets or sets the item count.
     */
    ItemCount?: number;
};

/**
 * Used to control the data that gets attached to DtoBaseItems.
 */
export type ItemFields = 'AirTime' | 'CanDelete' | 'CanDownload' | 'ChannelInfo' | 'Chapters' | 'Trickplay' | 'ChildCount' | 'CumulativeRunTimeTicks' | 'CustomRating' | 'DateCreated' | 'DateLastMediaAdded' | 'DisplayPreferencesId' | 'Etag' | 'ExternalUrls' | 'Genres' | 'HomePageUrl' | 'ItemCounts' | 'MediaSourceCount' | 'MediaSources' | 'OriginalTitle' | 'Overview' | 'ParentId' | 'Path' | 'People' | 'PlayAccess' | 'ProductionLocations' | 'ProviderIds' | 'PrimaryImageAspectRatio' | 'RecursiveItemCount' | 'Settings' | 'ScreenshotImageTags' | 'SeriesPrimaryImage' | 'SeriesStudio' | 'SortName' | 'SpecialEpisodeNumbers' | 'Studios' | 'Taglines' | 'Tags' | 'RemoteTrailers' | 'MediaStreams' | 'SeasonUserData' | 'ServiceName' | 'ThemeSongIds' | 'ThemeVideoIds' | 'ExternalEtag' | 'PresentationUniqueKey' | 'InheritedParentalRatingValue' | 'ExternalSeriesId' | 'SeriesPresentationUniqueKey' | 'DateLastRefreshed' | 'DateLastSaved' | 'RefreshState' | 'ChannelImage' | 'EnableMediaSourceDisplay' | 'Width' | 'Height' | 'ExtraIds' | 'LocalTrailerCount' | 'IsHD' | 'SpecialFeatureCount';

/**
 * Enum ItemFilter.
 */
export type ItemFilter = 'IsFolder' | 'IsNotFolder' | 'IsUnplayed' | 'IsPlayed' | 'IsFavorite' | 'IsResumable' | 'Likes' | 'Dislikes' | 'IsFavoriteOrLikes';

/**
 * These represent sort orders.
 */
export type ItemSortBy = 'Default' | 'AiredEpisodeOrder' | 'Album' | 'AlbumArtist' | 'Artist' | 'DateCreated' | 'OfficialRating' | 'DatePlayed' | 'PremiereDate' | 'StartDate' | 'SortName' | 'Name' | 'Random' | 'Runtime' | 'CommunityRating' | 'ProductionYear' | 'PlayCount' | 'CriticRating' | 'IsFolder' | 'IsUnplayed' | 'IsPlayed' | 'SeriesSortName' | 'VideoBitRate' | 'AirTime' | 'Studio' | 'IsFavoriteOrLiked' | 'DateLastContentAdded' | 'SeriesDatePlayed' | 'ParentIndexNumber' | 'IndexNumber' | 'SimilarityScore' | 'SearchScore';

/**
 * Class JoinGroupRequestDto.
 */
export type JoinGroupRequestDto = {
    /**
     * Gets or sets the group identifier.
     */
    GroupId?: string;
};

export type KeepUntil = 'UntilDeleted' | 'UntilSpaceNeeded' | 'UntilWatched' | 'UntilDate';

/**
 * Library changed message.
 */
export type LibraryChangedMessage = {
    /**
     * Gets or sets the data.
     */
    Data?: LibraryUpdateInfo | null;
    /**
     * Gets or sets the message id.
     */
    MessageId?: string;
    /**
     * The different kinds of messages that are used in the WebSocket api.
     */
    MessageType?: 'ForceKeepAlive' | 'GeneralCommand' | 'UserDataChanged' | 'Sessions' | 'Play' | 'SyncPlayCommand' | 'SyncPlayGroupUpdate' | 'Playstate' | 'RestartRequired' | 'ServerShuttingDown' | 'ServerRestarting' | 'LibraryChanged' | 'UserDeleted' | 'UserUpdated' | 'SeriesTimerCreated' | 'TimerCreated' | 'SeriesTimerCancelled' | 'TimerCancelled' | 'RefreshProgress' | 'ScheduledTaskEnded' | 'PackageInstallationCancelled' | 'PackageInstallationFailed' | 'PackageInstallationCompleted' | 'PackageInstalling' | 'PackageUninstalled' | 'ActivityLogEntry' | 'ScheduledTasksInfo' | 'ActivityLogEntryStart' | 'ActivityLogEntryStop' | 'SessionsStart' | 'SessionsStop' | 'ScheduledTasksInfoStart' | 'ScheduledTasksInfoStop' | 'KeepAlive';
};

/**
 * Library option info dto.
 */
export type LibraryOptionInfoDto = {
    /**
     * Gets or sets name.
     */
    Name?: string | null;
    /**
     * Gets or sets a value indicating whether default enabled.
     */
    DefaultEnabled?: boolean;
};

export type LibraryOptions = {
    Enabled?: boolean;
    EnablePhotos?: boolean;
    EnableRealtimeMonitor?: boolean;
    EnableLUFSScan?: boolean;
    EnableChapterImageExtraction?: boolean;
    ExtractChapterImagesDuringLibraryScan?: boolean;
    EnableTrickplayImageExtraction?: boolean;
    ExtractTrickplayImagesDuringLibraryScan?: boolean;
    PathInfos?: Array<MediaPathInfo>;
    SaveLocalMetadata?: boolean;
    /**
     * @deprecated
     */
    EnableInternetProviders?: boolean;
    EnableAutomaticSeriesGrouping?: boolean;
    EnableEmbeddedTitles?: boolean;
    EnableEmbeddedExtrasTitles?: boolean;
    EnableEmbeddedEpisodeInfos?: boolean;
    AutomaticRefreshIntervalDays?: number;
    /**
     * Gets or sets the preferred metadata language.
     */
    PreferredMetadataLanguage?: string | null;
    /**
     * Gets or sets the metadata country code.
     */
    MetadataCountryCode?: string | null;
    SeasonZeroDisplayName?: string;
    MetadataSavers?: Array<string> | null;
    DisabledLocalMetadataReaders?: Array<string>;
    LocalMetadataReaderOrder?: Array<string> | null;
    DisabledSubtitleFetchers?: Array<string>;
    SubtitleFetcherOrder?: Array<string>;
    DisabledMediaSegmentProviders?: Array<string>;
    MediaSegmentProvideOrder?: Array<string>;
    SkipSubtitlesIfEmbeddedSubtitlesPresent?: boolean;
    SkipSubtitlesIfAudioTrackMatches?: boolean;
    SubtitleDownloadLanguages?: Array<string> | null;
    RequirePerfectSubtitleMatch?: boolean;
    SaveSubtitlesWithMedia?: boolean;
    SaveLyricsWithMedia?: boolean;
    SaveTrickplayWithMedia?: boolean;
    DisabledLyricFetchers?: Array<string>;
    LyricFetcherOrder?: Array<string>;
    PreferNonstandardArtistsTag?: boolean;
    UseCustomTagDelimiters?: boolean;
    CustomTagDelimiters?: Array<string>;
    DelimiterWhitelist?: Array<string>;
    AutomaticallyAddToCollection?: boolean;
    /**
     * An enum representing the options to disable embedded subs.
     */
    AllowEmbeddedSubtitles?: 'AllowAll' | 'AllowText' | 'AllowImage' | 'AllowNone';
    TypeOptions?: Array<TypeOptions>;
};

/**
 * Library options result dto.
 */
export type LibraryOptionsResultDto = {
    /**
     * Gets or sets the metadata savers.
     */
    MetadataSavers?: Array<LibraryOptionInfoDto>;
    /**
     * Gets or sets the metadata readers.
     */
    MetadataReaders?: Array<LibraryOptionInfoDto>;
    /**
     * Gets or sets the subtitle fetchers.
     */
    SubtitleFetchers?: Array<LibraryOptionInfoDto>;
    /**
     * Gets or sets the list of lyric fetchers.
     */
    LyricFetchers?: Array<LibraryOptionInfoDto>;
    /**
     * Gets or sets the type options.
     */
    TypeOptions?: Array<LibraryTypeOptionsDto>;
};

/**
 * Library type options dto.
 */
export type LibraryTypeOptionsDto = {
    /**
     * Gets or sets the type.
     */
    Type?: string | null;
    /**
     * Gets or sets the metadata fetchers.
     */
    MetadataFetchers?: Array<LibraryOptionInfoDto>;
    /**
     * Gets or sets the image fetchers.
     */
    ImageFetchers?: Array<LibraryOptionInfoDto>;
    /**
     * Gets or sets the supported image types.
     */
    SupportedImageTypes?: Array<ImageType>;
    /**
     * Gets or sets the default image options.
     */
    DefaultImageOptions?: Array<ImageOption>;
};

/**
 * Class LibraryUpdateInfo.
 */
export type LibraryUpdateInfo = {
    /**
     * Gets or sets the folders added to.
     */
    FoldersAddedTo?: Array<string>;
    /**
     * Gets or sets the folders removed from.
     */
    FoldersRemovedFrom?: Array<string>;
    /**
     * Gets or sets the items added.
     */
    ItemsAdded?: Array<string>;
    /**
     * Gets or sets the items removed.
     */
    ItemsRemoved?: Array<string>;
    /**
     * Gets or sets the items updated.
     */
    ItemsUpdated?: Array<string>;
    CollectionFolders?: Array<string>;
    readonly IsEmpty?: boolean;
};

export type ListingsProviderInfo = {
    Id?: string | null;
    Type?: string | null;
    Username?: string | null;
    Password?: string | null;
    ListingsId?: string | null;
    ZipCode?: string | null;
    Country?: string | null;
    Path?: string | null;
    EnabledTuners?: Array<string> | null;
    EnableAllTuners?: boolean;
    NewsCategories?: Array<string> | null;
    SportsCategories?: Array<string> | null;
    KidsCategories?: Array<string> | null;
    MovieCategories?: Array<string> | null;
    ChannelMappings?: Array<NameValuePair> | null;
    MoviePrefix?: string | null;
    PreferredLanguage?: string | null;
    UserAgent?: string | null;
};

export type LiveStreamResponse = {
    MediaSource?: MediaSourceInfo;
};

export type LiveTvInfo = {
    /**
     * Gets or sets the services.
     */
    Services?: Array<LiveTvServiceInfo>;
    /**
     * Gets or sets a value indicating whether this instance is enabled.
     */
    IsEnabled?: boolean;
    /**
     * Gets or sets the enabled users.
     */
    EnabledUsers?: Array<string>;
};

export type LiveTvOptions = {
    GuideDays?: number | null;
    RecordingPath?: string | null;
    MovieRecordingPath?: string | null;
    SeriesRecordingPath?: string | null;
    EnableRecordingSubfolders?: boolean;
    EnableOriginalAudioWithEncodedRecordings?: boolean;
    TunerHosts?: Array<TunerHostInfo> | null;
    ListingProviders?: Array<ListingsProviderInfo> | null;
    PrePaddingSeconds?: number;
    PostPaddingSeconds?: number;
    MediaLocationsCreated?: Array<string> | null;
    RecordingPostProcessor?: string | null;
    RecordingPostProcessorArguments?: string | null;
    SaveRecordingNFO?: boolean;
    SaveRecordingImages?: boolean;
};

/**
 * Class ServiceInfo.
 */
export type LiveTvServiceInfo = {
    /**
     * Gets or sets the name.
     */
    Name?: string | null;
    /**
     * Gets or sets the home page URL.
     */
    HomePageUrl?: string | null;
    /**
     * Gets or sets the status.
     */
    Status?: 'Ok' | 'Unavailable';
    /**
     * Gets or sets the status message.
     */
    StatusMessage?: string | null;
    /**
     * Gets or sets the version.
     */
    Version?: string | null;
    /**
     * Gets or sets a value indicating whether this instance has update available.
     */
    HasUpdateAvailable?: boolean;
    /**
     * Gets or sets a value indicating whether this instance is visible.
     */
    IsVisible?: boolean;
    Tuners?: Array<string> | null;
};

export type LiveTvServiceStatus = 'Ok' | 'Unavailable';

export type LocalizationOption = {
    Name?: string | null;
    Value?: string | null;
};

/**
 * Enum LocationType.
 */
export type LocationType = 'FileSystem' | 'Remote' | 'Virtual' | 'Offline';

export type LogFile = {
    /**
     * Gets or sets the date created.
     */
    DateCreated?: string;
    /**
     * Gets or sets the date modified.
     */
    DateModified?: string;
    /**
     * Gets or sets the size.
     */
    Size?: number;
    /**
     * Gets or sets the name.
     */
    Name?: string;
};

export type LogLevel = 'Trace' | 'Debug' | 'Information' | 'Warning' | 'Error' | 'Critical' | 'None';

/**
 * LyricResponse model.
 */
export type LyricDto = {
    /**
     * Gets or sets Metadata for the lyrics.
     */
    Metadata?: LyricMetadata;
    /**
     * Gets or sets a collection of individual lyric lines.
     */
    Lyrics?: Array<LyricLine>;
};

/**
 * Lyric model.
 */
export type LyricLine = {
    /**
     * Gets the text of this lyric line.
     */
    Text?: string;
    /**
     * Gets the start time in ticks.
     */
    Start?: number | null;
};

/**
 * LyricMetadata model.
 */
export type LyricMetadata = {
    /**
     * Gets or sets the song artist.
     */
    Artist?: string | null;
    /**
     * Gets or sets the album this song is on.
     */
    Album?: string | null;
    /**
     * Gets or sets the title of the song.
     */
    Title?: string | null;
    /**
     * Gets or sets the author of the lyric data.
     */
    Author?: string | null;
    /**
     * Gets or sets the length of the song in ticks.
     */
    Length?: number | null;
    /**
     * Gets or sets who the LRC file was created by.
     */
    By?: string | null;
    /**
     * Gets or sets the lyric offset compared to audio in ticks.
     */
    Offset?: number | null;
    /**
     * Gets or sets the software used to create the LRC file.
     */
    Creator?: string | null;
    /**
     * Gets or sets the version of the creator used.
     */
    Version?: string | null;
    /**
     * Gets or sets a value indicating whether this lyric is synced.
     */
    IsSynced?: boolean | null;
};

/**
 * Class MediaAttachment.
 */
export type MediaAttachment = {
    /**
     * Gets or sets the codec.
     */
    Codec?: string | null;
    /**
     * Gets or sets the codec tag.
     */
    CodecTag?: string | null;
    /**
     * Gets or sets the comment.
     */
    Comment?: string | null;
    /**
     * Gets or sets the index.
     */
    Index?: number;
    /**
     * Gets or sets the filename.
     */
    FileName?: string | null;
    /**
     * Gets or sets the MIME type.
     */
    MimeType?: string | null;
    /**
     * Gets or sets the delivery URL.
     */
    DeliveryUrl?: string | null;
};

/**
 * Media Path dto.
 */
export type MediaPathDto = {
    /**
     * Gets or sets the name of the library.
     */
    Name: string;
    /**
     * Gets or sets the path to add.
     */
    Path?: string | null;
    /**
     * Gets or sets the path info.
     */
    PathInfo?: MediaPathInfo | null;
};

export type MediaPathInfo = {
    Path?: string;
};

export type MediaProtocol = 'File' | 'Http' | 'Rtmp' | 'Rtsp' | 'Udp' | 'Rtp' | 'Ftp';

/**
 * Api model for MediaSegment's.
 */
export type MediaSegmentDto = {
    /**
     * Gets or sets the id of the media segment.
     */
    Id?: string;
    /**
     * Gets or sets the id of the associated item.
     */
    ItemId?: string;
    /**
     * Defines the types of content an individual Jellyfin.Data.Entities.MediaSegment represents.
     */
    Type?: 'Unknown' | 'Commercial' | 'Preview' | 'Recap' | 'Outro' | 'Intro';
    /**
     * Gets or sets the start of the segment.
     */
    StartTicks?: number;
    /**
     * Gets or sets the end of the segment.
     */
    EndTicks?: number;
};

/**
 * Query result container.
 */
export type MediaSegmentDtoQueryResult = {
    /**
     * Gets or sets the items.
     */
    Items?: Array<MediaSegmentDto>;
    /**
     * Gets or sets the total number of records available.
     */
    TotalRecordCount?: number;
    /**
     * Gets or sets the index of the first record in Items.
     */
    StartIndex?: number;
};

/**
 * Defines the types of content an individual Jellyfin.Data.Entities.MediaSegment represents.
 */
export type MediaSegmentType = 'Unknown' | 'Commercial' | 'Preview' | 'Recap' | 'Outro' | 'Intro';

export type MediaSourceInfo = {
    Protocol?: 'File' | 'Http' | 'Rtmp' | 'Rtsp' | 'Udp' | 'Rtp' | 'Ftp';
    Id?: string | null;
    Path?: string | null;
    EncoderPath?: string | null;
    EncoderProtocol?: 'File' | 'Http' | 'Rtmp' | 'Rtsp' | 'Udp' | 'Rtp' | 'Ftp';
    Type?: 'Default' | 'Grouping' | 'Placeholder';
    Container?: string | null;
    Size?: number | null;
    Name?: string | null;
    /**
     * Gets or sets a value indicating whether the media is remote.
     * Differentiate internet url vs local network.
     */
    IsRemote?: boolean;
    ETag?: string | null;
    RunTimeTicks?: number | null;
    ReadAtNativeFramerate?: boolean;
    IgnoreDts?: boolean;
    IgnoreIndex?: boolean;
    GenPtsInput?: boolean;
    SupportsTranscoding?: boolean;
    SupportsDirectStream?: boolean;
    SupportsDirectPlay?: boolean;
    IsInfiniteStream?: boolean;
    UseMostCompatibleTranscodingProfile?: boolean;
    RequiresOpening?: boolean;
    OpenToken?: string | null;
    RequiresClosing?: boolean;
    LiveStreamId?: string | null;
    BufferMs?: number | null;
    RequiresLooping?: boolean;
    SupportsProbing?: boolean;
    VideoType?: 'VideoFile' | 'Iso' | 'Dvd' | 'BluRay';
    IsoType?: 'Dvd' | 'BluRay';
    Video3DFormat?: 'HalfSideBySide' | 'FullSideBySide' | 'FullTopAndBottom' | 'HalfTopAndBottom' | 'MVC';
    MediaStreams?: Array<MediaStream> | null;
    MediaAttachments?: Array<MediaAttachment> | null;
    Formats?: Array<string> | null;
    Bitrate?: number | null;
    FallbackMaxStreamingBitrate?: number | null;
    Timestamp?: 'None' | 'Zero' | 'Valid';
    RequiredHttpHeaders?: {
        [key: string]: string | null;
    } | null;
    TranscodingUrl?: string | null;
    /**
     * Media streaming protocol.
     * Lowercase for backwards compatibility.
     */
    TranscodingSubProtocol?: 'http' | 'hls';
    TranscodingContainer?: string | null;
    AnalyzeDurationMs?: number | null;
    DefaultAudioStreamIndex?: number | null;
    DefaultSubtitleStreamIndex?: number | null;
    HasSegments?: boolean;
};

export type MediaSourceType = 'Default' | 'Grouping' | 'Placeholder';

/**
 * Class MediaStream.
 */
export type MediaStream = {
    /**
     * Gets or sets the codec.
     */
    Codec?: string | null;
    /**
     * Gets or sets the codec tag.
     */
    CodecTag?: string | null;
    /**
     * Gets or sets the language.
     */
    Language?: string | null;
    /**
     * Gets or sets the color range.
     */
    ColorRange?: string | null;
    /**
     * Gets or sets the color space.
     */
    ColorSpace?: string | null;
    /**
     * Gets or sets the color transfer.
     */
    ColorTransfer?: string | null;
    /**
     * Gets or sets the color primaries.
     */
    ColorPrimaries?: string | null;
    /**
     * Gets or sets the Dolby Vision version major.
     */
    DvVersionMajor?: number | null;
    /**
     * Gets or sets the Dolby Vision version minor.
     */
    DvVersionMinor?: number | null;
    /**
     * Gets or sets the Dolby Vision profile.
     */
    DvProfile?: number | null;
    /**
     * Gets or sets the Dolby Vision level.
     */
    DvLevel?: number | null;
    /**
     * Gets or sets the Dolby Vision rpu present flag.
     */
    RpuPresentFlag?: number | null;
    /**
     * Gets or sets the Dolby Vision el present flag.
     */
    ElPresentFlag?: number | null;
    /**
     * Gets or sets the Dolby Vision bl present flag.
     */
    BlPresentFlag?: number | null;
    /**
     * Gets or sets the Dolby Vision bl signal compatibility id.
     */
    DvBlSignalCompatibilityId?: number | null;
    /**
     * Gets or sets the Rotation in degrees.
     */
    Rotation?: number | null;
    /**
     * Gets or sets the comment.
     */
    Comment?: string | null;
    /**
     * Gets or sets the time base.
     */
    TimeBase?: string | null;
    /**
     * Gets or sets the codec time base.
     */
    CodecTimeBase?: string | null;
    /**
     * Gets or sets the title.
     */
    Title?: string | null;
    /**
     * An enum representing video ranges.
     */
    VideoRange?: 'Unknown' | 'SDR' | 'HDR';
    /**
     * An enum representing types of video ranges.
     */
    VideoRangeType?: 'Unknown' | 'SDR' | 'HDR10' | 'HLG' | 'DOVI' | 'DOVIWithHDR10' | 'DOVIWithHLG' | 'DOVIWithSDR' | 'HDR10Plus';
    /**
     * Gets the video dovi title.
     */
    readonly VideoDoViTitle?: string | null;
    /**
     * An enum representing formats of spatial audio.
     */
    AudioSpatialFormat?: 'None' | 'DolbyAtmos' | 'DTSX';
    LocalizedUndefined?: string | null;
    LocalizedDefault?: string | null;
    LocalizedForced?: string | null;
    LocalizedExternal?: string | null;
    LocalizedHearingImpaired?: string | null;
    readonly DisplayTitle?: string | null;
    NalLengthSize?: string | null;
    /**
     * Gets or sets a value indicating whether this instance is interlaced.
     */
    IsInterlaced?: boolean;
    IsAVC?: boolean | null;
    /**
     * Gets or sets the channel layout.
     */
    ChannelLayout?: string | null;
    /**
     * Gets or sets the bit rate.
     */
    BitRate?: number | null;
    /**
     * Gets or sets the bit depth.
     */
    BitDepth?: number | null;
    /**
     * Gets or sets the reference frames.
     */
    RefFrames?: number | null;
    /**
     * Gets or sets the length of the packet.
     */
    PacketLength?: number | null;
    /**
     * Gets or sets the channels.
     */
    Channels?: number | null;
    /**
     * Gets or sets the sample rate.
     */
    SampleRate?: number | null;
    /**
     * Gets or sets a value indicating whether this instance is default.
     */
    IsDefault?: boolean;
    /**
     * Gets or sets a value indicating whether this instance is forced.
     */
    IsForced?: boolean;
    /**
     * Gets or sets a value indicating whether this instance is for the hearing impaired.
     */
    IsHearingImpaired?: boolean;
    /**
     * Gets or sets the height.
     */
    Height?: number | null;
    /**
     * Gets or sets the width.
     */
    Width?: number | null;
    /**
     * Gets or sets the average frame rate.
     */
    AverageFrameRate?: number | null;
    /**
     * Gets or sets the real frame rate.
     */
    RealFrameRate?: number | null;
    /**
     * Gets the framerate used as reference.
     * Prefer AverageFrameRate, if that is null or an unrealistic value
     * then fallback to RealFrameRate.
     */
    readonly ReferenceFrameRate?: number | null;
    /**
     * Gets or sets the profile.
     */
    Profile?: string | null;
    /**
     * Gets or sets the type.
     */
    Type?: 'Audio' | 'Video' | 'Subtitle' | 'EmbeddedImage' | 'Data' | 'Lyric';
    /**
     * Gets or sets the aspect ratio.
     */
    AspectRatio?: string | null;
    /**
     * Gets or sets the index.
     */
    Index?: number;
    /**
     * Gets or sets the score.
     */
    Score?: number | null;
    /**
     * Gets or sets a value indicating whether this instance is external.
     */
    IsExternal?: boolean;
    /**
     * Gets or sets the method.
     */
    DeliveryMethod?: 'Encode' | 'Embed' | 'External' | 'Hls' | 'Drop';
    /**
     * Gets or sets the delivery URL.
     */
    DeliveryUrl?: string | null;
    /**
     * Gets or sets a value indicating whether this instance is external URL.
     */
    IsExternalUrl?: boolean | null;
    readonly IsTextSubtitleStream?: boolean;
    /**
     * Gets or sets a value indicating whether [supports external stream].
     */
    SupportsExternalStream?: boolean;
    /**
     * Gets or sets the filename.
     */
    Path?: string | null;
    /**
     * Gets or sets the pixel format.
     */
    PixelFormat?: string | null;
    /**
     * Gets or sets the level.
     */
    Level?: number | null;
    /**
     * Gets or sets whether this instance is anamorphic.
     */
    IsAnamorphic?: boolean | null;
};

/**
 * Media streaming protocol.
 * Lowercase for backwards compatibility.
 */
export type MediaStreamProtocol = 'http' | 'hls';

/**
 * Enum MediaStreamType.
 */
export type MediaStreamType = 'Audio' | 'Video' | 'Subtitle' | 'EmbeddedImage' | 'Data' | 'Lyric';

/**
 * Media types.
 */
export type MediaType = 'Unknown' | 'Video' | 'Audio' | 'Photo' | 'Book';

/**
 * Media Update Info Dto.
 */
export type MediaUpdateInfoDto = {
    /**
     * Gets or sets the list of updates.
     */
    Updates?: Array<MediaUpdateInfoPathDto>;
};

/**
 * The media update info path.
 */
export type MediaUpdateInfoPathDto = {
    /**
     * Gets or sets media path.
     */
    Path?: string | null;
    /**
     * Gets or sets media update type.
     * Created, Modified, Deleted.
     */
    UpdateType?: string | null;
};

export type MediaUrl = {
    Url?: string | null;
    Name?: string | null;
};

export type MessageCommand = {
    Header?: string | null;
    Text: string;
    TimeoutMs?: number | null;
};

export type MetadataConfiguration = {
    UseFileCreationTimeForDateAdded?: boolean;
};

export type MetadataEditorInfo = {
    ParentalRatingOptions?: Array<ParentalRating>;
    Countries?: Array<CountryInfo>;
    Cultures?: Array<CultureDto>;
    ExternalIdInfos?: Array<ExternalIdInfo>;
    ContentType?: 'unknown' | 'movies' | 'tvshows' | 'music' | 'musicvideos' | 'trailers' | 'homevideos' | 'boxsets' | 'books' | 'photos' | 'livetv' | 'playlists' | 'folders';
    ContentTypeOptions?: Array<NameValuePair>;
};

/**
 * Enum MetadataFields.
 */
export type MetadataField = 'Cast' | 'Genres' | 'ProductionLocations' | 'Studios' | 'Tags' | 'Name' | 'Overview' | 'Runtime' | 'OfficialRating';

/**
 * Class MetadataOptions.
 */
export type MetadataOptions = {
    ItemType?: string | null;
    DisabledMetadataSavers?: Array<string> | null;
    LocalMetadataReaderOrder?: Array<string> | null;
    DisabledMetadataFetchers?: Array<string> | null;
    MetadataFetcherOrder?: Array<string> | null;
    DisabledImageFetchers?: Array<string> | null;
    ImageFetcherOrder?: Array<string> | null;
};

export type MetadataRefreshMode = 'None' | 'ValidationOnly' | 'Default' | 'FullRefresh';

/**
 * Class MovePlaylistItemRequestDto.
 */
export type MovePlaylistItemRequestDto = {
    /**
     * Gets or sets the playlist identifier of the item.
     */
    PlaylistItemId?: string;
    /**
     * Gets or sets the new position.
     */
    NewIndex?: number;
};

export type MovieInfo = {
    /**
     * Gets or sets the name.
     */
    Name?: string | null;
    /**
     * Gets or sets the original title.
     */
    OriginalTitle?: string | null;
    /**
     * Gets or sets the path.
     */
    Path?: string | null;
    /**
     * Gets or sets the metadata language.
     */
    MetadataLanguage?: string | null;
    /**
     * Gets or sets the metadata country code.
     */
    MetadataCountryCode?: string | null;
    /**
     * Gets or sets the provider ids.
     */
    ProviderIds?: {
        [key: string]: string | null;
    } | null;
    /**
     * Gets or sets the year.
     */
    Year?: number | null;
    IndexNumber?: number | null;
    ParentIndexNumber?: number | null;
    PremiereDate?: string | null;
    IsAutomated?: boolean;
};

export type MovieInfoRemoteSearchQuery = {
    SearchInfo?: MovieInfo | null;
    ItemId?: string;
    /**
     * Gets or sets the provider name to search within if set.
     */
    SearchProviderName?: string | null;
    /**
     * Gets or sets a value indicating whether disabled providers should be included.
     */
    IncludeDisabledProviders?: boolean;
};

export type MusicVideoInfo = {
    /**
     * Gets or sets the name.
     */
    Name?: string | null;
    /**
     * Gets or sets the original title.
     */
    OriginalTitle?: string | null;
    /**
     * Gets or sets the path.
     */
    Path?: string | null;
    /**
     * Gets or sets the metadata language.
     */
    MetadataLanguage?: string | null;
    /**
     * Gets or sets the metadata country code.
     */
    MetadataCountryCode?: string | null;
    /**
     * Gets or sets the provider ids.
     */
    ProviderIds?: {
        [key: string]: string | null;
    } | null;
    /**
     * Gets or sets the year.
     */
    Year?: number | null;
    IndexNumber?: number | null;
    ParentIndexNumber?: number | null;
    PremiereDate?: string | null;
    IsAutomated?: boolean;
    Artists?: Array<string> | null;
};

export type MusicVideoInfoRemoteSearchQuery = {
    SearchInfo?: MusicVideoInfo | null;
    ItemId?: string;
    /**
     * Gets or sets the provider name to search within if set.
     */
    SearchProviderName?: string | null;
    /**
     * Gets or sets a value indicating whether disabled providers should be included.
     */
    IncludeDisabledProviders?: boolean;
};

export type NameGuidPair = {
    Name?: string | null;
    Id?: string;
};

export type NameIdPair = {
    /**
     * Gets or sets the name.
     */
    Name?: string | null;
    /**
     * Gets or sets the identifier.
     */
    Id?: string | null;
};

export type NameValuePair = {
    /**
     * Gets or sets the name.
     */
    Name?: string | null;
    /**
     * Gets or sets the value.
     */
    Value?: string | null;
};

/**
 * Defines the MediaBrowser.Common.Net.NetworkConfiguration.
 */
export type NetworkConfiguration = {
    /**
     * Gets or sets a value used to specify the URL prefix that your Jellyfin instance can be accessed at.
     */
    BaseUrl?: string;
    /**
     * Gets or sets a value indicating whether to use HTTPS.
     */
    EnableHttps?: boolean;
    /**
     * Gets or sets a value indicating whether the server should force connections over HTTPS.
     */
    RequireHttps?: boolean;
    /**
     * Gets or sets the filesystem path of an X.509 certificate to use for SSL.
     */
    CertificatePath?: string;
    /**
     * Gets or sets the password required to access the X.509 certificate data in the file specified by MediaBrowser.Common.Net.NetworkConfiguration.CertificatePath.
     */
    CertificatePassword?: string;
    /**
     * Gets or sets the internal HTTP server port.
     */
    InternalHttpPort?: number;
    /**
     * Gets or sets the internal HTTPS server port.
     */
    InternalHttpsPort?: number;
    /**
     * Gets or sets the public HTTP port.
     */
    PublicHttpPort?: number;
    /**
     * Gets or sets the public HTTPS port.
     */
    PublicHttpsPort?: number;
    /**
     * Gets or sets a value indicating whether Autodiscovery is enabled.
     */
    AutoDiscovery?: boolean;
    /**
     * Gets or sets a value indicating whether to enable automatic port forwarding.
     */
    EnableUPnP?: boolean;
    /**
     * Gets or sets a value indicating whether IPv6 is enabled.
     */
    EnableIPv4?: boolean;
    /**
     * Gets or sets a value indicating whether IPv6 is enabled.
     */
    EnableIPv6?: boolean;
    /**
     * Gets or sets a value indicating whether access from outside of the LAN is permitted.
     */
    EnableRemoteAccess?: boolean;
    /**
     * Gets or sets the subnets that are deemed to make up the LAN.
     */
    LocalNetworkSubnets?: Array<string>;
    /**
     * Gets or sets the interface addresses which Jellyfin will bind to. If empty, all interfaces will be used.
     */
    LocalNetworkAddresses?: Array<string>;
    /**
     * Gets or sets the known proxies.
     */
    KnownProxies?: Array<string>;
    /**
     * Gets or sets a value indicating whether address names that match MediaBrowser.Common.Net.NetworkConfiguration.VirtualInterfaceNames should be ignored for the purposes of binding.
     */
    IgnoreVirtualInterfaces?: boolean;
    /**
     * Gets or sets a value indicating the interface name prefixes that should be ignored. The list can be comma separated and values are case-insensitive. <seealso cref="P:MediaBrowser.Common.Net.NetworkConfiguration.IgnoreVirtualInterfaces" />.
     */
    VirtualInterfaceNames?: Array<string>;
    /**
     * Gets or sets a value indicating whether the published server uri is based on information in HTTP requests.
     */
    EnablePublishedServerUriByRequest?: boolean;
    /**
     * Gets or sets the PublishedServerUriBySubnet
     * Gets or sets PublishedServerUri to advertise for specific subnets.
     */
    PublishedServerUriBySubnet?: Array<string>;
    /**
     * Gets or sets the filter for remote IP connectivity. Used in conjunction with <seealso cref="P:MediaBrowser.Common.Net.NetworkConfiguration.IsRemoteIPFilterBlacklist" />.
     */
    RemoteIPFilter?: Array<string>;
    /**
     * Gets or sets a value indicating whether <seealso cref="P:MediaBrowser.Common.Net.NetworkConfiguration.RemoteIPFilter" /> contains a blacklist or a whitelist. Default is a whitelist.
     */
    IsRemoteIPFilterBlacklist?: boolean;
};

/**
 * Class NewGroupRequestDto.
 */
export type NewGroupRequestDto = {
    /**
     * Gets or sets the group name.
     */
    GroupName?: string;
};

/**
 * Class NextItemRequestDto.
 */
export type NextItemRequestDto = {
    /**
     * Gets or sets the playing item identifier.
     */
    PlaylistItemId?: string;
};

/**
 * Open live stream dto.
 */
export type OpenLiveStreamDto = {
    /**
     * Gets or sets the open token.
     */
    OpenToken?: string | null;
    /**
     * Gets or sets the user id.
     */
    UserId?: string | null;
    /**
     * Gets or sets the play session id.
     */
    PlaySessionId?: string | null;
    /**
     * Gets or sets the max streaming bitrate.
     */
    MaxStreamingBitrate?: number | null;
    /**
     * Gets or sets the start time in ticks.
     */
    StartTimeTicks?: number | null;
    /**
     * Gets or sets the audio stream index.
     */
    AudioStreamIndex?: number | null;
    /**
     * Gets or sets the subtitle stream index.
     */
    SubtitleStreamIndex?: number | null;
    /**
     * Gets or sets the max audio channels.
     */
    MaxAudioChannels?: number | null;
    /**
     * Gets or sets the item id.
     */
    ItemId?: string | null;
    /**
     * Gets or sets a value indicating whether to enable direct play.
     */
    EnableDirectPlay?: boolean | null;
    /**
     * Gets or sets a value indicating whether to enale direct stream.
     */
    EnableDirectStream?: boolean | null;
    /**
     * Gets or sets a value indicating whether always burn in subtitles when transcoding.
     */
    AlwaysBurnInSubtitleWhenTranscoding?: boolean | null;
    /**
     * Gets or sets the device profile.
     */
    DeviceProfile?: DeviceProfile | null;
    /**
     * Gets or sets the device play protocols.
     */
    DirectPlayProtocols?: Array<MediaProtocol>;
};

/**
 * Keep alive websocket messages.
 */
export type OutboundKeepAliveMessage = {
    /**
     * Gets or sets the message id.
     */
    MessageId?: string;
    /**
     * The different kinds of messages that are used in the WebSocket api.
     */
    MessageType?: 'ForceKeepAlive' | 'GeneralCommand' | 'UserDataChanged' | 'Sessions' | 'Play' | 'SyncPlayCommand' | 'SyncPlayGroupUpdate' | 'Playstate' | 'RestartRequired' | 'ServerShuttingDown' | 'ServerRestarting' | 'LibraryChanged' | 'UserDeleted' | 'UserUpdated' | 'SeriesTimerCreated' | 'TimerCreated' | 'SeriesTimerCancelled' | 'TimerCancelled' | 'RefreshProgress' | 'ScheduledTaskEnded' | 'PackageInstallationCancelled' | 'PackageInstallationFailed' | 'PackageInstallationCompleted' | 'PackageInstalling' | 'PackageUninstalled' | 'ActivityLogEntry' | 'ScheduledTasksInfo' | 'ActivityLogEntryStart' | 'ActivityLogEntryStop' | 'SessionsStart' | 'SessionsStop' | 'ScheduledTasksInfoStart' | 'ScheduledTasksInfoStop' | 'KeepAlive';
};

/**
 * Represents the list of possible outbound websocket types
 */
export type OutboundWebSocketMessage = ({
    MessageType: 'ActivityLogEntry';
} & ActivityLogEntryMessage) | ({
    MessageType: 'ForceKeepAlive';
} & ForceKeepAliveMessage) | ({
    MessageType: 'GeneralCommand';
} & GeneralCommandMessage) | ({
    MessageType: 'LibraryChanged';
} & LibraryChangedMessage) | ({
    MessageType: 'KeepAlive';
} & OutboundKeepAliveMessage) | ({
    MessageType: 'Play';
} & PlayMessage) | ({
    MessageType: 'Playstate';
} & PlaystateMessage) | ({
    MessageType: 'PackageInstallationCancelled';
} & PluginInstallationCancelledMessage) | ({
    MessageType: 'PackageInstallationCompleted';
} & PluginInstallationCompletedMessage) | ({
    MessageType: 'PackageInstallationFailed';
} & PluginInstallationFailedMessage) | ({
    MessageType: 'PackageInstalling';
} & PluginInstallingMessage) | ({
    MessageType: 'PackageUninstalled';
} & PluginUninstalledMessage) | ({
    MessageType: 'RefreshProgress';
} & RefreshProgressMessage) | ({
    MessageType: 'RestartRequired';
} & RestartRequiredMessage) | ({
    MessageType: 'ScheduledTaskEnded';
} & ScheduledTaskEndedMessage) | ({
    MessageType: 'ScheduledTasksInfo';
} & ScheduledTasksInfoMessage) | ({
    MessageType: 'SeriesTimerCancelled';
} & SeriesTimerCancelledMessage) | ({
    MessageType: 'SeriesTimerCreated';
} & SeriesTimerCreatedMessage) | ({
    MessageType: 'ServerRestarting';
} & ServerRestartingMessage) | ({
    MessageType: 'ServerShuttingDown';
} & ServerShuttingDownMessage) | ({
    MessageType: 'Sessions';
} & SessionsMessage) | ({
    MessageType: 'SyncPlayCommand';
} & SyncPlayCommandMessage) | ({
    MessageType: 'SyncPlayGroupUpdate';
} & SyncPlayGroupUpdateCommandMessage) | ({
    MessageType: 'TimerCancelled';
} & TimerCancelledMessage) | ({
    MessageType: 'TimerCreated';
} & TimerCreatedMessage) | ({
    MessageType: 'UserDataChanged';
} & UserDataChangedMessage) | ({
    MessageType: 'UserDeleted';
} & UserDeletedMessage) | ({
    MessageType: 'UserUpdated';
} & UserUpdatedMessage);

/**
 * Class PackageInfo.
 */
export type PackageInfo = {
    /**
     * Gets or sets the name.
     */
    name?: string;
    /**
     * Gets or sets a long description of the plugin containing features or helpful explanations.
     */
    description?: string;
    /**
     * Gets or sets a short overview of what the plugin does.
     */
    overview?: string;
    /**
     * Gets or sets the owner.
     */
    owner?: string;
    /**
     * Gets or sets the category.
     */
    category?: string;
    /**
     * Gets or sets the guid of the assembly associated with this plugin.
     * This is used to identify the proper item for automatic updates.
     */
    guid?: string;
    /**
     * Gets or sets the versions.
     */
    versions?: Array<VersionInfo>;
    /**
     * Gets or sets the image url for the package.
     */
    imageUrl?: string | null;
};

/**
 * Class ParentalRating.
 */
export type ParentalRating = {
    /**
     * Gets or sets the name.
     */
    Name?: string | null;
    /**
     * Gets or sets the value.
     */
    Value?: number | null;
};

/**
 * Defines the MediaBrowser.Model.Configuration.PathSubstitution.
 */
export type PathSubstitution = {
    /**
     * Gets or sets the value to substitute.
     */
    From?: string;
    /**
     * Gets or sets the value to substitution with.
     */
    To?: string;
};

/**
 * The person kind.
 */
export type PersonKind = 'Unknown' | 'Actor' | 'Director' | 'Composer' | 'Writer' | 'GuestStar' | 'Producer' | 'Conductor' | 'Lyricist' | 'Arranger' | 'Engineer' | 'Mixer' | 'Remixer' | 'Creator' | 'Artist' | 'AlbumArtist' | 'Author' | 'Illustrator' | 'Penciller' | 'Inker' | 'Colorist' | 'Letterer' | 'CoverArtist' | 'Editor' | 'Translator';

export type PersonLookupInfo = {
    /**
     * Gets or sets the name.
     */
    Name?: string | null;
    /**
     * Gets or sets the original title.
     */
    OriginalTitle?: string | null;
    /**
     * Gets or sets the path.
     */
    Path?: string | null;
    /**
     * Gets or sets the metadata language.
     */
    MetadataLanguage?: string | null;
    /**
     * Gets or sets the metadata country code.
     */
    MetadataCountryCode?: string | null;
    /**
     * Gets or sets the provider ids.
     */
    ProviderIds?: {
        [key: string]: string | null;
    } | null;
    /**
     * Gets or sets the year.
     */
    Year?: number | null;
    IndexNumber?: number | null;
    ParentIndexNumber?: number | null;
    PremiereDate?: string | null;
    IsAutomated?: boolean;
};

export type PersonLookupInfoRemoteSearchQuery = {
    SearchInfo?: PersonLookupInfo | null;
    ItemId?: string;
    /**
     * Gets or sets the provider name to search within if set.
     */
    SearchProviderName?: string | null;
    /**
     * Gets or sets a value indicating whether disabled providers should be included.
     */
    IncludeDisabledProviders?: boolean;
};

/**
 * Class PingRequestDto.
 */
export type PingRequestDto = {
    /**
     * Gets or sets the ping time.
     */
    Ping?: number;
};

export type PinRedeemResult = {
    /**
     * Gets or sets a value indicating whether this MediaBrowser.Model.Users.PinRedeemResult is success.
     */
    Success?: boolean;
    /**
     * Gets or sets the users reset.
     */
    UsersReset?: Array<string>;
};

export type PlayAccess = 'Full' | 'None';

export type PlaybackErrorCode = 'NotAllowed' | 'NoCompatibleStream' | 'RateLimitExceeded';

/**
 * Plabyback info dto.
 */
export type PlaybackInfoDto = {
    /**
     * Gets or sets the playback userId.
     */
    UserId?: string | null;
    /**
     * Gets or sets the max streaming bitrate.
     */
    MaxStreamingBitrate?: number | null;
    /**
     * Gets or sets the start time in ticks.
     */
    StartTimeTicks?: number | null;
    /**
     * Gets or sets the audio stream index.
     */
    AudioStreamIndex?: number | null;
    /**
     * Gets or sets the subtitle stream index.
     */
    SubtitleStreamIndex?: number | null;
    /**
     * Gets or sets the max audio channels.
     */
    MaxAudioChannels?: number | null;
    /**
     * Gets or sets the media source id.
     */
    MediaSourceId?: string | null;
    /**
     * Gets or sets the live stream id.
     */
    LiveStreamId?: string | null;
    /**
     * Gets or sets the device profile.
     */
    DeviceProfile?: DeviceProfile | null;
    /**
     * Gets or sets a value indicating whether to enable direct play.
     */
    EnableDirectPlay?: boolean | null;
    /**
     * Gets or sets a value indicating whether to enable direct stream.
     */
    EnableDirectStream?: boolean | null;
    /**
     * Gets or sets a value indicating whether to enable transcoding.
     */
    EnableTranscoding?: boolean | null;
    /**
     * Gets or sets a value indicating whether to enable video stream copy.
     */
    AllowVideoStreamCopy?: boolean | null;
    /**
     * Gets or sets a value indicating whether to allow audio stream copy.
     */
    AllowAudioStreamCopy?: boolean | null;
    /**
     * Gets or sets a value indicating whether to auto open the live stream.
     */
    AutoOpenLiveStream?: boolean | null;
    /**
     * Gets or sets a value indicating whether always burn in subtitles when transcoding.
     */
    AlwaysBurnInSubtitleWhenTranscoding?: boolean | null;
};

/**
 * Class PlaybackInfoResponse.
 */
export type PlaybackInfoResponse = {
    /**
     * Gets or sets the media sources.
     */
    MediaSources?: Array<MediaSourceInfo>;
    /**
     * Gets or sets the play session identifier.
     */
    PlaySessionId?: string | null;
    /**
     * Gets or sets the error code.
     */
    ErrorCode?: 'NotAllowed' | 'NoCompatibleStream' | 'RateLimitExceeded';
};

/**
 * Enum PlaybackOrder.
 */
export type PlaybackOrder = 'Default' | 'Shuffle';

/**
 * Class PlaybackProgressInfo.
 */
export type PlaybackProgressInfo = {
    /**
     * Gets or sets a value indicating whether this instance can seek.
     */
    CanSeek?: boolean;
    /**
     * Gets or sets the item.
     */
    Item?: BaseItemDto | null;
    /**
     * Gets or sets the item identifier.
     */
    ItemId?: string;
    /**
     * Gets or sets the session id.
     */
    SessionId?: string | null;
    /**
     * Gets or sets the media version identifier.
     */
    MediaSourceId?: string | null;
    /**
     * Gets or sets the index of the audio stream.
     */
    AudioStreamIndex?: number | null;
    /**
     * Gets or sets the index of the subtitle stream.
     */
    SubtitleStreamIndex?: number | null;
    /**
     * Gets or sets a value indicating whether this instance is paused.
     */
    IsPaused?: boolean;
    /**
     * Gets or sets a value indicating whether this instance is muted.
     */
    IsMuted?: boolean;
    /**
     * Gets or sets the position ticks.
     */
    PositionTicks?: number | null;
    PlaybackStartTimeTicks?: number | null;
    /**
     * Gets or sets the volume level.
     */
    VolumeLevel?: number | null;
    Brightness?: number | null;
    AspectRatio?: string | null;
    /**
     * Gets or sets the play method.
     */
    PlayMethod?: 'Transcode' | 'DirectStream' | 'DirectPlay';
    /**
     * Gets or sets the live stream identifier.
     */
    LiveStreamId?: string | null;
    /**
     * Gets or sets the play session identifier.
     */
    PlaySessionId?: string | null;
    /**
     * Gets or sets the repeat mode.
     */
    RepeatMode?: 'RepeatNone' | 'RepeatAll' | 'RepeatOne';
    /**
     * Gets or sets the playback order.
     */
    PlaybackOrder?: 'Default' | 'Shuffle';
    NowPlayingQueue?: Array<QueueItem> | null;
    PlaylistItemId?: string | null;
};

/**
 * Enum PlaybackRequestType.
 */
export type PlaybackRequestType = 'Play' | 'SetPlaylistItem' | 'RemoveFromPlaylist' | 'MovePlaylistItem' | 'Queue' | 'Unpause' | 'Pause' | 'Stop' | 'Seek' | 'Buffer' | 'Ready' | 'NextItem' | 'PreviousItem' | 'SetRepeatMode' | 'SetShuffleMode' | 'Ping' | 'IgnoreWait';

/**
 * Class PlaybackStartInfo.
 */
export type PlaybackStartInfo = {
    /**
     * Gets or sets a value indicating whether this instance can seek.
     */
    CanSeek?: boolean;
    /**
     * Gets or sets the item.
     */
    Item?: BaseItemDto | null;
    /**
     * Gets or sets the item identifier.
     */
    ItemId?: string;
    /**
     * Gets or sets the session id.
     */
    SessionId?: string | null;
    /**
     * Gets or sets the media version identifier.
     */
    MediaSourceId?: string | null;
    /**
     * Gets or sets the index of the audio stream.
     */
    AudioStreamIndex?: number | null;
    /**
     * Gets or sets the index of the subtitle stream.
     */
    SubtitleStreamIndex?: number | null;
    /**
     * Gets or sets a value indicating whether this instance is paused.
     */
    IsPaused?: boolean;
    /**
     * Gets or sets a value indicating whether this instance is muted.
     */
    IsMuted?: boolean;
    /**
     * Gets or sets the position ticks.
     */
    PositionTicks?: number | null;
    PlaybackStartTimeTicks?: number | null;
    /**
     * Gets or sets the volume level.
     */
    VolumeLevel?: number | null;
    Brightness?: number | null;
    AspectRatio?: string | null;
    /**
     * Gets or sets the play method.
     */
    PlayMethod?: 'Transcode' | 'DirectStream' | 'DirectPlay';
    /**
     * Gets or sets the live stream identifier.
     */
    LiveStreamId?: string | null;
    /**
     * Gets or sets the play session identifier.
     */
    PlaySessionId?: string | null;
    /**
     * Gets or sets the repeat mode.
     */
    RepeatMode?: 'RepeatNone' | 'RepeatAll' | 'RepeatOne';
    /**
     * Gets or sets the playback order.
     */
    PlaybackOrder?: 'Default' | 'Shuffle';
    NowPlayingQueue?: Array<QueueItem> | null;
    PlaylistItemId?: string | null;
};

/**
 * Class PlaybackStopInfo.
 */
export type PlaybackStopInfo = {
    /**
     * Gets or sets the item.
     */
    Item?: BaseItemDto | null;
    /**
     * Gets or sets the item identifier.
     */
    ItemId?: string;
    /**
     * Gets or sets the session id.
     */
    SessionId?: string | null;
    /**
     * Gets or sets the media version identifier.
     */
    MediaSourceId?: string | null;
    /**
     * Gets or sets the position ticks.
     */
    PositionTicks?: number | null;
    /**
     * Gets or sets the live stream identifier.
     */
    LiveStreamId?: string | null;
    /**
     * Gets or sets the play session identifier.
     */
    PlaySessionId?: string | null;
    /**
     * Gets or sets a value indicating whether this MediaBrowser.Model.Session.PlaybackStopInfo is failed.
     */
    Failed?: boolean;
    NextMediaType?: string | null;
    PlaylistItemId?: string | null;
    NowPlayingQueue?: Array<QueueItem> | null;
};

/**
 * Enum PlayCommand.
 */
export type PlayCommand = 'PlayNow' | 'PlayNext' | 'PlayLast' | 'PlayInstantMix' | 'PlayShuffle';

export type PlayerStateInfo = {
    /**
     * Gets or sets the now playing position ticks.
     */
    PositionTicks?: number | null;
    /**
     * Gets or sets a value indicating whether this instance can seek.
     */
    CanSeek?: boolean;
    /**
     * Gets or sets a value indicating whether this instance is paused.
     */
    IsPaused?: boolean;
    /**
     * Gets or sets a value indicating whether this instance is muted.
     */
    IsMuted?: boolean;
    /**
     * Gets or sets the volume level.
     */
    VolumeLevel?: number | null;
    /**
     * Gets or sets the index of the now playing audio stream.
     */
    AudioStreamIndex?: number | null;
    /**
     * Gets or sets the index of the now playing subtitle stream.
     */
    SubtitleStreamIndex?: number | null;
    /**
     * Gets or sets the now playing media version identifier.
     */
    MediaSourceId?: string | null;
    /**
     * Gets or sets the play method.
     */
    PlayMethod?: 'Transcode' | 'DirectStream' | 'DirectPlay';
    /**
     * Gets or sets the repeat mode.
     */
    RepeatMode?: 'RepeatNone' | 'RepeatAll' | 'RepeatOne';
    /**
     * Gets or sets the playback order.
     */
    PlaybackOrder?: 'Default' | 'Shuffle';
    /**
     * Gets or sets the now playing live stream identifier.
     */
    LiveStreamId?: string | null;
};

export type PlaylistCreationResult = {
    Id?: string;
};

/**
 * DTO for playlists.
 */
export type PlaylistDto = {
    /**
     * Gets or sets a value indicating whether the playlist is publicly readable.
     */
    OpenAccess?: boolean;
    /**
     * Gets or sets the share permissions.
     */
    Shares?: Array<PlaylistUserPermissions>;
    /**
     * Gets or sets the item ids.
     */
    ItemIds?: Array<string>;
};

/**
 * Class to hold data on user permissions for playlists.
 */
export type PlaylistUserPermissions = {
    /**
     * Gets or sets the user id.
     */
    UserId?: string;
    /**
     * Gets or sets a value indicating whether the user has edit permissions.
     */
    CanEdit?: boolean;
};

/**
 * Play command websocket message.
 */
export type PlayMessage = {
    /**
     * Gets or sets the data.
     */
    Data?: PlayRequest | null;
    /**
     * Gets or sets the message id.
     */
    MessageId?: string;
    /**
     * The different kinds of messages that are used in the WebSocket api.
     */
    MessageType?: 'ForceKeepAlive' | 'GeneralCommand' | 'UserDataChanged' | 'Sessions' | 'Play' | 'SyncPlayCommand' | 'SyncPlayGroupUpdate' | 'Playstate' | 'RestartRequired' | 'ServerShuttingDown' | 'ServerRestarting' | 'LibraryChanged' | 'UserDeleted' | 'UserUpdated' | 'SeriesTimerCreated' | 'TimerCreated' | 'SeriesTimerCancelled' | 'TimerCancelled' | 'RefreshProgress' | 'ScheduledTaskEnded' | 'PackageInstallationCancelled' | 'PackageInstallationFailed' | 'PackageInstallationCompleted' | 'PackageInstalling' | 'PackageUninstalled' | 'ActivityLogEntry' | 'ScheduledTasksInfo' | 'ActivityLogEntryStart' | 'ActivityLogEntryStop' | 'SessionsStart' | 'SessionsStop' | 'ScheduledTasksInfoStart' | 'ScheduledTasksInfoStop' | 'KeepAlive';
};

export type PlayMethod = 'Transcode' | 'DirectStream' | 'DirectPlay';

/**
 * Class PlayQueueUpdate.
 */
export type PlayQueueUpdate = {
    /**
     * Gets the request type that originated this update.
     */
    Reason?: 'NewPlaylist' | 'SetCurrentItem' | 'RemoveItems' | 'MoveItem' | 'Queue' | 'QueueNext' | 'NextItem' | 'PreviousItem' | 'RepeatMode' | 'ShuffleMode';
    /**
     * Gets the UTC time of the last change to the playing queue.
     */
    LastUpdate?: string;
    /**
     * Gets the playlist.
     */
    Playlist?: Array<SyncPlayQueueItem>;
    /**
     * Gets the playing item index in the playlist.
     */
    PlayingItemIndex?: number;
    /**
     * Gets the start position ticks.
     */
    StartPositionTicks?: number;
    /**
     * Gets a value indicating whether the current item is playing.
     */
    IsPlaying?: boolean;
    /**
     * Gets the shuffle mode.
     */
    ShuffleMode?: 'Sorted' | 'Shuffle';
    /**
     * Gets the repeat mode.
     */
    RepeatMode?: 'RepeatOne' | 'RepeatAll' | 'RepeatNone';
};

/**
 * Class GroupUpdate.
 */
export type PlayQueueUpdateGroupUpdate = {
    /**
     * Gets the group identifier.
     */
    readonly GroupId?: string;
    /**
     * Gets the update type.
     */
    Type?: 'UserJoined' | 'UserLeft' | 'GroupJoined' | 'GroupLeft' | 'StateUpdate' | 'PlayQueue' | 'NotInGroup' | 'GroupDoesNotExist' | 'CreateGroupDenied' | 'JoinGroupDenied' | 'LibraryAccessDenied';
    /**
     * Gets the update data.
     */
    Data?: PlayQueueUpdate;
};

/**
 * Enum PlayQueueUpdateReason.
 */
export type PlayQueueUpdateReason = 'NewPlaylist' | 'SetCurrentItem' | 'RemoveItems' | 'MoveItem' | 'Queue' | 'QueueNext' | 'NextItem' | 'PreviousItem' | 'RepeatMode' | 'ShuffleMode';

/**
 * Class PlayRequest.
 */
export type PlayRequest = {
    /**
     * Gets or sets the item ids.
     */
    ItemIds?: Array<string> | null;
    /**
     * Gets or sets the start position ticks that the first item should be played at.
     */
    StartPositionTicks?: number | null;
    /**
     * Gets or sets the play command.
     */
    PlayCommand?: 'PlayNow' | 'PlayNext' | 'PlayLast' | 'PlayInstantMix' | 'PlayShuffle';
    /**
     * Gets or sets the controlling user identifier.
     */
    ControllingUserId?: string;
    SubtitleStreamIndex?: number | null;
    AudioStreamIndex?: number | null;
    MediaSourceId?: string | null;
    StartIndex?: number | null;
};

/**
 * Class PlayRequestDto.
 */
export type PlayRequestDto = {
    /**
     * Gets or sets the playing queue.
     */
    PlayingQueue?: Array<string>;
    /**
     * Gets or sets the position of the playing item in the queue.
     */
    PlayingItemPosition?: number;
    /**
     * Gets or sets the start position ticks.
     */
    StartPositionTicks?: number;
};

/**
 * Enum PlaystateCommand.
 */
export type PlaystateCommand = 'Stop' | 'Pause' | 'Unpause' | 'NextTrack' | 'PreviousTrack' | 'Seek' | 'Rewind' | 'FastForward' | 'PlayPause';

/**
 * Playstate message.
 */
export type PlaystateMessage = {
    /**
     * Gets or sets the data.
     */
    Data?: PlaystateRequest | null;
    /**
     * Gets or sets the message id.
     */
    MessageId?: string;
    /**
     * The different kinds of messages that are used in the WebSocket api.
     */
    MessageType?: 'ForceKeepAlive' | 'GeneralCommand' | 'UserDataChanged' | 'Sessions' | 'Play' | 'SyncPlayCommand' | 'SyncPlayGroupUpdate' | 'Playstate' | 'RestartRequired' | 'ServerShuttingDown' | 'ServerRestarting' | 'LibraryChanged' | 'UserDeleted' | 'UserUpdated' | 'SeriesTimerCreated' | 'TimerCreated' | 'SeriesTimerCancelled' | 'TimerCancelled' | 'RefreshProgress' | 'ScheduledTaskEnded' | 'PackageInstallationCancelled' | 'PackageInstallationFailed' | 'PackageInstallationCompleted' | 'PackageInstalling' | 'PackageUninstalled' | 'ActivityLogEntry' | 'ScheduledTasksInfo' | 'ActivityLogEntryStart' | 'ActivityLogEntryStop' | 'SessionsStart' | 'SessionsStop' | 'ScheduledTasksInfoStart' | 'ScheduledTasksInfoStop' | 'KeepAlive';
};

export type PlaystateRequest = {
    /**
     * Enum PlaystateCommand.
     */
    Command?: 'Stop' | 'Pause' | 'Unpause' | 'NextTrack' | 'PreviousTrack' | 'Seek' | 'Rewind' | 'FastForward' | 'PlayPause';
    SeekPositionTicks?: number | null;
    /**
     * Gets or sets the controlling user identifier.
     */
    ControllingUserId?: string | null;
};

/**
 * This is a serializable stub class that is used by the api to provide information about installed plugins.
 */
export type PluginInfo = {
    /**
     * Gets or sets the name.
     */
    Name?: string;
    /**
     * Gets or sets the version.
     */
    Version?: string;
    /**
     * Gets or sets the name of the configuration file.
     */
    ConfigurationFileName?: string | null;
    /**
     * Gets or sets the description.
     */
    Description?: string;
    /**
     * Gets or sets the unique id.
     */
    Id?: string;
    /**
     * Gets or sets a value indicating whether the plugin can be uninstalled.
     */
    CanUninstall?: boolean;
    /**
     * Gets or sets a value indicating whether this plugin has a valid image.
     */
    HasImage?: boolean;
    /**
     * Gets or sets a value indicating the status of the plugin.
     */
    Status?: 'Active' | 'Restart' | 'Deleted' | 'Superceded' | 'Malfunctioned' | 'NotSupported' | 'Disabled';
};

/**
 * Plugin installation cancelled message.
 */
export type PluginInstallationCancelledMessage = {
    /**
     * Gets or sets the data.
     */
    Data?: InstallationInfo | null;
    /**
     * Gets or sets the message id.
     */
    MessageId?: string;
    /**
     * The different kinds of messages that are used in the WebSocket api.
     */
    MessageType?: 'ForceKeepAlive' | 'GeneralCommand' | 'UserDataChanged' | 'Sessions' | 'Play' | 'SyncPlayCommand' | 'SyncPlayGroupUpdate' | 'Playstate' | 'RestartRequired' | 'ServerShuttingDown' | 'ServerRestarting' | 'LibraryChanged' | 'UserDeleted' | 'UserUpdated' | 'SeriesTimerCreated' | 'TimerCreated' | 'SeriesTimerCancelled' | 'TimerCancelled' | 'RefreshProgress' | 'ScheduledTaskEnded' | 'PackageInstallationCancelled' | 'PackageInstallationFailed' | 'PackageInstallationCompleted' | 'PackageInstalling' | 'PackageUninstalled' | 'ActivityLogEntry' | 'ScheduledTasksInfo' | 'ActivityLogEntryStart' | 'ActivityLogEntryStop' | 'SessionsStart' | 'SessionsStop' | 'ScheduledTasksInfoStart' | 'ScheduledTasksInfoStop' | 'KeepAlive';
};

/**
 * Plugin installation completed message.
 */
export type PluginInstallationCompletedMessage = {
    /**
     * Gets or sets the data.
     */
    Data?: InstallationInfo | null;
    /**
     * Gets or sets the message id.
     */
    MessageId?: string;
    /**
     * The different kinds of messages that are used in the WebSocket api.
     */
    MessageType?: 'ForceKeepAlive' | 'GeneralCommand' | 'UserDataChanged' | 'Sessions' | 'Play' | 'SyncPlayCommand' | 'SyncPlayGroupUpdate' | 'Playstate' | 'RestartRequired' | 'ServerShuttingDown' | 'ServerRestarting' | 'LibraryChanged' | 'UserDeleted' | 'UserUpdated' | 'SeriesTimerCreated' | 'TimerCreated' | 'SeriesTimerCancelled' | 'TimerCancelled' | 'RefreshProgress' | 'ScheduledTaskEnded' | 'PackageInstallationCancelled' | 'PackageInstallationFailed' | 'PackageInstallationCompleted' | 'PackageInstalling' | 'PackageUninstalled' | 'ActivityLogEntry' | 'ScheduledTasksInfo' | 'ActivityLogEntryStart' | 'ActivityLogEntryStop' | 'SessionsStart' | 'SessionsStop' | 'ScheduledTasksInfoStart' | 'ScheduledTasksInfoStop' | 'KeepAlive';
};

/**
 * Plugin installation failed message.
 */
export type PluginInstallationFailedMessage = {
    /**
     * Gets or sets the data.
     */
    Data?: InstallationInfo | null;
    /**
     * Gets or sets the message id.
     */
    MessageId?: string;
    /**
     * The different kinds of messages that are used in the WebSocket api.
     */
    MessageType?: 'ForceKeepAlive' | 'GeneralCommand' | 'UserDataChanged' | 'Sessions' | 'Play' | 'SyncPlayCommand' | 'SyncPlayGroupUpdate' | 'Playstate' | 'RestartRequired' | 'ServerShuttingDown' | 'ServerRestarting' | 'LibraryChanged' | 'UserDeleted' | 'UserUpdated' | 'SeriesTimerCreated' | 'TimerCreated' | 'SeriesTimerCancelled' | 'TimerCancelled' | 'RefreshProgress' | 'ScheduledTaskEnded' | 'PackageInstallationCancelled' | 'PackageInstallationFailed' | 'PackageInstallationCompleted' | 'PackageInstalling' | 'PackageUninstalled' | 'ActivityLogEntry' | 'ScheduledTasksInfo' | 'ActivityLogEntryStart' | 'ActivityLogEntryStop' | 'SessionsStart' | 'SessionsStop' | 'ScheduledTasksInfoStart' | 'ScheduledTasksInfoStop' | 'KeepAlive';
};

/**
 * Package installing message.
 */
export type PluginInstallingMessage = {
    /**
     * Gets or sets the data.
     */
    Data?: InstallationInfo | null;
    /**
     * Gets or sets the message id.
     */
    MessageId?: string;
    /**
     * The different kinds of messages that are used in the WebSocket api.
     */
    MessageType?: 'ForceKeepAlive' | 'GeneralCommand' | 'UserDataChanged' | 'Sessions' | 'Play' | 'SyncPlayCommand' | 'SyncPlayGroupUpdate' | 'Playstate' | 'RestartRequired' | 'ServerShuttingDown' | 'ServerRestarting' | 'LibraryChanged' | 'UserDeleted' | 'UserUpdated' | 'SeriesTimerCreated' | 'TimerCreated' | 'SeriesTimerCancelled' | 'TimerCancelled' | 'RefreshProgress' | 'ScheduledTaskEnded' | 'PackageInstallationCancelled' | 'PackageInstallationFailed' | 'PackageInstallationCompleted' | 'PackageInstalling' | 'PackageUninstalled' | 'ActivityLogEntry' | 'ScheduledTasksInfo' | 'ActivityLogEntryStart' | 'ActivityLogEntryStop' | 'SessionsStart' | 'SessionsStop' | 'ScheduledTasksInfoStart' | 'ScheduledTasksInfoStop' | 'KeepAlive';
};

/**
 * Plugin load status.
 */
export type PluginStatus = 'Active' | 'Restart' | 'Deleted' | 'Superceded' | 'Malfunctioned' | 'NotSupported' | 'Disabled';

/**
 * Plugin uninstalled message.
 */
export type PluginUninstalledMessage = {
    /**
     * Gets or sets the data.
     */
    Data?: PluginInfo | null;
    /**
     * Gets or sets the message id.
     */
    MessageId?: string;
    /**
     * The different kinds of messages that are used in the WebSocket api.
     */
    MessageType?: 'ForceKeepAlive' | 'GeneralCommand' | 'UserDataChanged' | 'Sessions' | 'Play' | 'SyncPlayCommand' | 'SyncPlayGroupUpdate' | 'Playstate' | 'RestartRequired' | 'ServerShuttingDown' | 'ServerRestarting' | 'LibraryChanged' | 'UserDeleted' | 'UserUpdated' | 'SeriesTimerCreated' | 'TimerCreated' | 'SeriesTimerCancelled' | 'TimerCancelled' | 'RefreshProgress' | 'ScheduledTaskEnded' | 'PackageInstallationCancelled' | 'PackageInstallationFailed' | 'PackageInstallationCompleted' | 'PackageInstalling' | 'PackageUninstalled' | 'ActivityLogEntry' | 'ScheduledTasksInfo' | 'ActivityLogEntryStart' | 'ActivityLogEntryStop' | 'SessionsStart' | 'SessionsStop' | 'ScheduledTasksInfoStart' | 'ScheduledTasksInfoStop' | 'KeepAlive';
};

/**
 * Class PreviousItemRequestDto.
 */
export type PreviousItemRequestDto = {
    /**
     * Gets or sets the playing item identifier.
     */
    PlaylistItemId?: string;
};

export type ProblemDetails = {
    type?: string | null;
    title?: string | null;
    status?: number | null;
    detail?: string | null;
    instance?: string | null;
    [key: string]: unknown | (string | null) | (string | null) | (number | null) | (string | null) | (string | null) | undefined;
};

export type ProcessPriorityClass = 'Normal' | 'Idle' | 'High' | 'RealTime' | 'BelowNormal' | 'AboveNormal';

export type ProfileCondition = {
    Condition?: 'Equals' | 'NotEquals' | 'LessThanEqual' | 'GreaterThanEqual' | 'EqualsAny';
    Property?: 'AudioChannels' | 'AudioBitrate' | 'AudioProfile' | 'Width' | 'Height' | 'Has64BitOffsets' | 'PacketLength' | 'VideoBitDepth' | 'VideoBitrate' | 'VideoFramerate' | 'VideoLevel' | 'VideoProfile' | 'VideoTimestamp' | 'IsAnamorphic' | 'RefFrames' | 'NumAudioStreams' | 'NumVideoStreams' | 'IsSecondaryAudio' | 'VideoCodecTag' | 'IsAvc' | 'IsInterlaced' | 'AudioSampleRate' | 'AudioBitDepth' | 'VideoRangeType';
    Value?: string | null;
    IsRequired?: boolean;
};

export type ProfileConditionType = 'Equals' | 'NotEquals' | 'LessThanEqual' | 'GreaterThanEqual' | 'EqualsAny';

export type ProfileConditionValue = 'AudioChannels' | 'AudioBitrate' | 'AudioProfile' | 'Width' | 'Height' | 'Has64BitOffsets' | 'PacketLength' | 'VideoBitDepth' | 'VideoBitrate' | 'VideoFramerate' | 'VideoLevel' | 'VideoProfile' | 'VideoTimestamp' | 'IsAnamorphic' | 'RefFrames' | 'NumAudioStreams' | 'NumVideoStreams' | 'IsSecondaryAudio' | 'VideoCodecTag' | 'IsAvc' | 'IsInterlaced' | 'AudioSampleRate' | 'AudioBitDepth' | 'VideoRangeType';

export type ProgramAudio = 'Mono' | 'Stereo' | 'Dolby' | 'DolbyDigital' | 'Thx' | 'Atmos';

export type PublicSystemInfo = {
    /**
     * Gets or sets the local address.
     */
    LocalAddress?: string | null;
    /**
     * Gets or sets the name of the server.
     */
    ServerName?: string | null;
    /**
     * Gets or sets the server version.
     */
    Version?: string | null;
    /**
     * Gets or sets the product name. This is the AssemblyProduct name.
     */
    ProductName?: string | null;
    /**
     * Gets or sets the operating system.
     * @deprecated
     */
    OperatingSystem?: string | null;
    /**
     * Gets or sets the id.
     */
    Id?: string | null;
    /**
     * Gets or sets a value indicating whether the startup wizard is completed.
     */
    StartupWizardCompleted?: boolean | null;
};

export type QueryFilters = {
    Genres?: Array<NameGuidPair> | null;
    Tags?: Array<string> | null;
};

export type QueryFiltersLegacy = {
    Genres?: Array<string> | null;
    Tags?: Array<string> | null;
    OfficialRatings?: Array<string> | null;
    Years?: Array<number> | null;
};

export type QueueItem = {
    Id?: string;
    PlaylistItemId?: string | null;
};

/**
 * Class QueueRequestDto.
 */
export type QueueRequestDto = {
    /**
     * Gets or sets the items to enqueue.
     */
    ItemIds?: Array<string>;
    /**
     * Gets or sets the mode in which to add the new items.
     */
    Mode?: 'Queue' | 'QueueNext';
};

/**
 * The quick connect request body.
 */
export type QuickConnectDto = {
    /**
     * Gets or sets the quick connect secret.
     */
    Secret: string;
};

/**
 * Stores the state of an quick connect request.
 */
export type QuickConnectResult = {
    /**
     * Gets or sets a value indicating whether this request is authorized.
     */
    Authenticated?: boolean;
    /**
     * Gets the secret value used to uniquely identify this request. Can be used to retrieve authentication information.
     */
    Secret?: string;
    /**
     * Gets the user facing code used so the user can quickly differentiate this request from others.
     */
    Code?: string;
    /**
     * Gets the requesting device id.
     */
    DeviceId?: string;
    /**
     * Gets the requesting device name.
     */
    DeviceName?: string;
    /**
     * Gets the requesting app name.
     */
    AppName?: string;
    /**
     * Gets the requesting app version.
     */
    AppVersion?: string;
    /**
     * Gets or sets the DateTime that this request was created.
     */
    DateAdded?: string;
};

export type RatingType = 'Score' | 'Likes';

/**
 * Class ReadyRequest.
 */
export type ReadyRequestDto = {
    /**
     * Gets or sets when the request has been made by the client.
     */
    When?: string;
    /**
     * Gets or sets the position ticks.
     */
    PositionTicks?: number;
    /**
     * Gets or sets a value indicating whether the client playback is unpaused.
     */
    IsPlaying?: boolean;
    /**
     * Gets or sets the playlist item identifier of the playing item.
     */
    PlaylistItemId?: string;
};

export type RecommendationDto = {
    Items?: Array<BaseItemDto> | null;
    RecommendationType?: 'SimilarToRecentlyPlayed' | 'SimilarToLikedItem' | 'HasDirectorFromRecentlyPlayed' | 'HasActorFromRecentlyPlayed' | 'HasLikedDirector' | 'HasLikedActor';
    BaselineItemName?: string | null;
    CategoryId?: string;
};

export type RecommendationType = 'SimilarToRecentlyPlayed' | 'SimilarToLikedItem' | 'HasDirectorFromRecentlyPlayed' | 'HasActorFromRecentlyPlayed' | 'HasLikedDirector' | 'HasLikedActor';

export type RecordingStatus = 'New' | 'InProgress' | 'Completed' | 'Cancelled' | 'ConflictedOk' | 'ConflictedNotOk' | 'Error';

/**
 * Refresh progress message.
 */
export type RefreshProgressMessage = {
    /**
     * Gets or sets the data.
     */
    Data?: {
        [key: string]: string | null;
    } | null;
    /**
     * Gets or sets the message id.
     */
    MessageId?: string;
    /**
     * The different kinds of messages that are used in the WebSocket api.
     */
    MessageType?: 'ForceKeepAlive' | 'GeneralCommand' | 'UserDataChanged' | 'Sessions' | 'Play' | 'SyncPlayCommand' | 'SyncPlayGroupUpdate' | 'Playstate' | 'RestartRequired' | 'ServerShuttingDown' | 'ServerRestarting' | 'LibraryChanged' | 'UserDeleted' | 'UserUpdated' | 'SeriesTimerCreated' | 'TimerCreated' | 'SeriesTimerCancelled' | 'TimerCancelled' | 'RefreshProgress' | 'ScheduledTaskEnded' | 'PackageInstallationCancelled' | 'PackageInstallationFailed' | 'PackageInstallationCompleted' | 'PackageInstalling' | 'PackageUninstalled' | 'ActivityLogEntry' | 'ScheduledTasksInfo' | 'ActivityLogEntryStart' | 'ActivityLogEntryStop' | 'SessionsStart' | 'SessionsStop' | 'ScheduledTasksInfoStart' | 'ScheduledTasksInfoStop' | 'KeepAlive';
};

/**
 * Class RemoteImageInfo.
 */
export type RemoteImageInfo = {
    /**
     * Gets or sets the name of the provider.
     */
    ProviderName?: string | null;
    /**
     * Gets or sets the URL.
     */
    Url?: string | null;
    /**
     * Gets or sets a url used for previewing a smaller version.
     */
    ThumbnailUrl?: string | null;
    /**
     * Gets or sets the height.
     */
    Height?: number | null;
    /**
     * Gets or sets the width.
     */
    Width?: number | null;
    /**
     * Gets or sets the community rating.
     */
    CommunityRating?: number | null;
    /**
     * Gets or sets the vote count.
     */
    VoteCount?: number | null;
    /**
     * Gets or sets the language.
     */
    Language?: string | null;
    /**
     * Gets or sets the type.
     */
    Type?: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Profile';
    /**
     * Gets or sets the type of the rating.
     */
    RatingType?: 'Score' | 'Likes';
};

/**
 * Class RemoteImageResult.
 */
export type RemoteImageResult = {
    /**
     * Gets or sets the images.
     */
    Images?: Array<RemoteImageInfo> | null;
    /**
     * Gets or sets the total record count.
     */
    TotalRecordCount?: number;
    /**
     * Gets or sets the providers.
     */
    Providers?: Array<string> | null;
};

/**
 * The remote lyric info dto.
 */
export type RemoteLyricInfoDto = {
    /**
     * Gets or sets the id for the lyric.
     */
    Id?: string;
    /**
     * Gets the provider name.
     */
    ProviderName?: string;
    /**
     * Gets the lyrics.
     */
    Lyrics?: LyricDto;
};

export type RemoteSearchResult = {
    /**
     * Gets or sets the name.
     */
    Name?: string | null;
    /**
     * Gets or sets the provider ids.
     */
    ProviderIds?: {
        [key: string]: string | null;
    } | null;
    /**
     * Gets or sets the year.
     */
    ProductionYear?: number | null;
    IndexNumber?: number | null;
    IndexNumberEnd?: number | null;
    ParentIndexNumber?: number | null;
    PremiereDate?: string | null;
    ImageUrl?: string | null;
    SearchProviderName?: string | null;
    Overview?: string | null;
    AlbumArtist?: RemoteSearchResult | null;
    Artists?: Array<RemoteSearchResult> | null;
};

export type RemoteSubtitleInfo = {
    ThreeLetterISOLanguageName?: string | null;
    Id?: string | null;
    ProviderName?: string | null;
    Name?: string | null;
    Format?: string | null;
    Author?: string | null;
    Comment?: string | null;
    DateCreated?: string | null;
    CommunityRating?: number | null;
    FrameRate?: number | null;
    DownloadCount?: number | null;
    IsHashMatch?: boolean | null;
    AiTranslated?: boolean | null;
    MachineTranslated?: boolean | null;
    Forced?: boolean | null;
    HearingImpaired?: boolean | null;
};

/**
 * Class RemoveFromPlaylistRequestDto.
 */
export type RemoveFromPlaylistRequestDto = {
    /**
     * Gets or sets the playlist identifiers of the items. Ignored when clearing the playlist.
     */
    PlaylistItemIds?: Array<string>;
    /**
     * Gets or sets a value indicating whether the entire playlist should be cleared.
     */
    ClearPlaylist?: boolean;
    /**
     * Gets or sets a value indicating whether the playing item should be removed as well. Used only when clearing the playlist.
     */
    ClearPlayingItem?: boolean;
};

export type RepeatMode = 'RepeatNone' | 'RepeatAll' | 'RepeatOne';

export type ReportPlaybackOptions = {
    MaxDataAge?: number;
    BackupPath?: string;
    MaxBackupFiles?: number;
};

/**
 * Class RepositoryInfo.
 */
export type RepositoryInfo = {
    /**
     * Gets or sets the name.
     */
    Name?: string | null;
    /**
     * Gets or sets the URL.
     */
    Url?: string | null;
    /**
     * Gets or sets a value indicating whether the repository is enabled.
     */
    Enabled?: boolean;
};

/**
 * Restart required.
 */
export type RestartRequiredMessage = {
    /**
     * Gets or sets the message id.
     */
    MessageId?: string;
    /**
     * The different kinds of messages that are used in the WebSocket api.
     */
    MessageType?: 'ForceKeepAlive' | 'GeneralCommand' | 'UserDataChanged' | 'Sessions' | 'Play' | 'SyncPlayCommand' | 'SyncPlayGroupUpdate' | 'Playstate' | 'RestartRequired' | 'ServerShuttingDown' | 'ServerRestarting' | 'LibraryChanged' | 'UserDeleted' | 'UserUpdated' | 'SeriesTimerCreated' | 'TimerCreated' | 'SeriesTimerCancelled' | 'TimerCancelled' | 'RefreshProgress' | 'ScheduledTaskEnded' | 'PackageInstallationCancelled' | 'PackageInstallationFailed' | 'PackageInstallationCompleted' | 'PackageInstalling' | 'PackageUninstalled' | 'ActivityLogEntry' | 'ScheduledTasksInfo' | 'ActivityLogEntryStart' | 'ActivityLogEntryStop' | 'SessionsStart' | 'SessionsStop' | 'ScheduledTasksInfoStart' | 'ScheduledTasksInfoStop' | 'KeepAlive';
};

/**
 * Scheduled task ended message.
 */
export type ScheduledTaskEndedMessage = {
    /**
     * Gets or sets the data.
     */
    Data?: TaskResult | null;
    /**
     * Gets or sets the message id.
     */
    MessageId?: string;
    /**
     * The different kinds of messages that are used in the WebSocket api.
     */
    MessageType?: 'ForceKeepAlive' | 'GeneralCommand' | 'UserDataChanged' | 'Sessions' | 'Play' | 'SyncPlayCommand' | 'SyncPlayGroupUpdate' | 'Playstate' | 'RestartRequired' | 'ServerShuttingDown' | 'ServerRestarting' | 'LibraryChanged' | 'UserDeleted' | 'UserUpdated' | 'SeriesTimerCreated' | 'TimerCreated' | 'SeriesTimerCancelled' | 'TimerCancelled' | 'RefreshProgress' | 'ScheduledTaskEnded' | 'PackageInstallationCancelled' | 'PackageInstallationFailed' | 'PackageInstallationCompleted' | 'PackageInstalling' | 'PackageUninstalled' | 'ActivityLogEntry' | 'ScheduledTasksInfo' | 'ActivityLogEntryStart' | 'ActivityLogEntryStop' | 'SessionsStart' | 'SessionsStop' | 'ScheduledTasksInfoStart' | 'ScheduledTasksInfoStop' | 'KeepAlive';
};

/**
 * Scheduled tasks info message.
 */
export type ScheduledTasksInfoMessage = {
    /**
     * Gets or sets the data.
     */
    Data?: Array<TaskInfo> | null;
    /**
     * Gets or sets the message id.
     */
    MessageId?: string;
    /**
     * The different kinds of messages that are used in the WebSocket api.
     */
    MessageType?: 'ForceKeepAlive' | 'GeneralCommand' | 'UserDataChanged' | 'Sessions' | 'Play' | 'SyncPlayCommand' | 'SyncPlayGroupUpdate' | 'Playstate' | 'RestartRequired' | 'ServerShuttingDown' | 'ServerRestarting' | 'LibraryChanged' | 'UserDeleted' | 'UserUpdated' | 'SeriesTimerCreated' | 'TimerCreated' | 'SeriesTimerCancelled' | 'TimerCancelled' | 'RefreshProgress' | 'ScheduledTaskEnded' | 'PackageInstallationCancelled' | 'PackageInstallationFailed' | 'PackageInstallationCompleted' | 'PackageInstalling' | 'PackageUninstalled' | 'ActivityLogEntry' | 'ScheduledTasksInfo' | 'ActivityLogEntryStart' | 'ActivityLogEntryStop' | 'SessionsStart' | 'SessionsStop' | 'ScheduledTasksInfoStart' | 'ScheduledTasksInfoStop' | 'KeepAlive';
};

/**
 * Scheduled tasks info start message.
 * Data is the timing data encoded as "$initialDelay,$interval" in ms.
 */
export type ScheduledTasksInfoStartMessage = {
    /**
     * Gets or sets the data.
     */
    Data?: string | null;
    /**
     * The different kinds of messages that are used in the WebSocket api.
     */
    MessageType?: 'ForceKeepAlive' | 'GeneralCommand' | 'UserDataChanged' | 'Sessions' | 'Play' | 'SyncPlayCommand' | 'SyncPlayGroupUpdate' | 'Playstate' | 'RestartRequired' | 'ServerShuttingDown' | 'ServerRestarting' | 'LibraryChanged' | 'UserDeleted' | 'UserUpdated' | 'SeriesTimerCreated' | 'TimerCreated' | 'SeriesTimerCancelled' | 'TimerCancelled' | 'RefreshProgress' | 'ScheduledTaskEnded' | 'PackageInstallationCancelled' | 'PackageInstallationFailed' | 'PackageInstallationCompleted' | 'PackageInstalling' | 'PackageUninstalled' | 'ActivityLogEntry' | 'ScheduledTasksInfo' | 'ActivityLogEntryStart' | 'ActivityLogEntryStop' | 'SessionsStart' | 'SessionsStop' | 'ScheduledTasksInfoStart' | 'ScheduledTasksInfoStop' | 'KeepAlive';
};

/**
 * Scheduled tasks info stop message.
 */
export type ScheduledTasksInfoStopMessage = {
    /**
     * The different kinds of messages that are used in the WebSocket api.
     */
    MessageType?: 'ForceKeepAlive' | 'GeneralCommand' | 'UserDataChanged' | 'Sessions' | 'Play' | 'SyncPlayCommand' | 'SyncPlayGroupUpdate' | 'Playstate' | 'RestartRequired' | 'ServerShuttingDown' | 'ServerRestarting' | 'LibraryChanged' | 'UserDeleted' | 'UserUpdated' | 'SeriesTimerCreated' | 'TimerCreated' | 'SeriesTimerCancelled' | 'TimerCancelled' | 'RefreshProgress' | 'ScheduledTaskEnded' | 'PackageInstallationCancelled' | 'PackageInstallationFailed' | 'PackageInstallationCompleted' | 'PackageInstalling' | 'PackageUninstalled' | 'ActivityLogEntry' | 'ScheduledTasksInfo' | 'ActivityLogEntryStart' | 'ActivityLogEntryStop' | 'SessionsStart' | 'SessionsStop' | 'ScheduledTasksInfoStart' | 'ScheduledTasksInfoStop' | 'KeepAlive';
};

/**
 * An enum representing the axis that should be scrolled.
 */
export type ScrollDirection = 'Horizontal' | 'Vertical';

/**
 * Class SearchHintResult.
 */
export type SearchHint = {
    /**
     * Gets or sets the item id.
     * @deprecated
     */
    ItemId?: string;
    /**
     * Gets or sets the item id.
     */
    Id?: string;
    /**
     * Gets or sets the name.
     */
    Name?: string;
    /**
     * Gets or sets the matched term.
     */
    MatchedTerm?: string | null;
    /**
     * Gets or sets the index number.
     */
    IndexNumber?: number | null;
    /**
     * Gets or sets the production year.
     */
    ProductionYear?: number | null;
    /**
     * Gets or sets the parent index number.
     */
    ParentIndexNumber?: number | null;
    /**
     * Gets or sets the image tag.
     */
    PrimaryImageTag?: string | null;
    /**
     * Gets or sets the thumb image tag.
     */
    ThumbImageTag?: string | null;
    /**
     * Gets or sets the thumb image item identifier.
     */
    ThumbImageItemId?: string | null;
    /**
     * Gets or sets the backdrop image tag.
     */
    BackdropImageTag?: string | null;
    /**
     * Gets or sets the backdrop image item identifier.
     */
    BackdropImageItemId?: string | null;
    /**
     * The base item kind.
     */
    Type?: 'AggregateFolder' | 'Audio' | 'AudioBook' | 'BasePluginFolder' | 'Book' | 'BoxSet' | 'Channel' | 'ChannelFolderItem' | 'CollectionFolder' | 'Episode' | 'Folder' | 'Genre' | 'ManualPlaylistsFolder' | 'Movie' | 'LiveTvChannel' | 'LiveTvProgram' | 'MusicAlbum' | 'MusicArtist' | 'MusicGenre' | 'MusicVideo' | 'Person' | 'Photo' | 'PhotoAlbum' | 'Playlist' | 'PlaylistsFolder' | 'Program' | 'Recording' | 'Season' | 'Series' | 'Studio' | 'Trailer' | 'TvChannel' | 'TvProgram' | 'UserRootFolder' | 'UserView' | 'Video' | 'Year';
    /**
     * Gets or sets a value indicating whether this instance is folder.
     */
    IsFolder?: boolean | null;
    /**
     * Gets or sets the run time ticks.
     */
    RunTimeTicks?: number | null;
    /**
     * Media types.
     */
    MediaType?: 'Unknown' | 'Video' | 'Audio' | 'Photo' | 'Book';
    /**
     * Gets or sets the start date.
     */
    StartDate?: string | null;
    /**
     * Gets or sets the end date.
     */
    EndDate?: string | null;
    /**
     * Gets or sets the series.
     */
    Series?: string | null;
    /**
     * Gets or sets the status.
     */
    Status?: string | null;
    /**
     * Gets or sets the album.
     */
    Album?: string | null;
    /**
     * Gets or sets the album id.
     */
    AlbumId?: string | null;
    /**
     * Gets or sets the album artist.
     */
    AlbumArtist?: string | null;
    /**
     * Gets or sets the artists.
     */
    Artists?: Array<string>;
    /**
     * Gets or sets the song count.
     */
    SongCount?: number | null;
    /**
     * Gets or sets the episode count.
     */
    EpisodeCount?: number | null;
    /**
     * Gets or sets the channel identifier.
     */
    ChannelId?: string | null;
    /**
     * Gets or sets the name of the channel.
     */
    ChannelName?: string | null;
    /**
     * Gets or sets the primary image aspect ratio.
     */
    PrimaryImageAspectRatio?: number | null;
};

/**
 * Class SearchHintResult.
 */
export type SearchHintResult = {
    /**
     * Gets the search hints.
     */
    SearchHints?: Array<SearchHint>;
    /**
     * Gets the total record count.
     */
    TotalRecordCount?: number;
};

/**
 * Class SeekRequestDto.
 */
export type SeekRequestDto = {
    /**
     * Gets or sets the position ticks.
     */
    PositionTicks?: number;
};

/**
 * Class SendCommand.
 */
export type SendCommand = {
    /**
     * Gets the group identifier.
     */
    GroupId?: string;
    /**
     * Gets the playlist identifier of the playing item.
     */
    PlaylistItemId?: string;
    /**
     * Gets or sets the UTC time when to execute the command.
     */
    When?: string;
    /**
     * Gets the position ticks.
     */
    PositionTicks?: number | null;
    /**
     * Gets the command.
     */
    Command?: 'Unpause' | 'Pause' | 'Stop' | 'Seek';
    /**
     * Gets the UTC time when this command has been emitted.
     */
    EmittedAt?: string;
};

/**
 * Enum SendCommandType.
 */
export type SendCommandType = 'Unpause' | 'Pause' | 'Stop' | 'Seek';

export type SeriesInfo = {
    /**
     * Gets or sets the name.
     */
    Name?: string | null;
    /**
     * Gets or sets the original title.
     */
    OriginalTitle?: string | null;
    /**
     * Gets or sets the path.
     */
    Path?: string | null;
    /**
     * Gets or sets the metadata language.
     */
    MetadataLanguage?: string | null;
    /**
     * Gets or sets the metadata country code.
     */
    MetadataCountryCode?: string | null;
    /**
     * Gets or sets the provider ids.
     */
    ProviderIds?: {
        [key: string]: string | null;
    } | null;
    /**
     * Gets or sets the year.
     */
    Year?: number | null;
    IndexNumber?: number | null;
    ParentIndexNumber?: number | null;
    PremiereDate?: string | null;
    IsAutomated?: boolean;
};

export type SeriesInfoRemoteSearchQuery = {
    SearchInfo?: SeriesInfo | null;
    ItemId?: string;
    /**
     * Gets or sets the provider name to search within if set.
     */
    SearchProviderName?: string | null;
    /**
     * Gets or sets a value indicating whether disabled providers should be included.
     */
    IncludeDisabledProviders?: boolean;
};

/**
 * The status of a series.
 */
export type SeriesStatus = 'Continuing' | 'Ended' | 'Unreleased';

/**
 * Series timer cancelled message.
 */
export type SeriesTimerCancelledMessage = {
    /**
     * Gets or sets the data.
     */
    Data?: TimerEventInfo | null;
    /**
     * Gets or sets the message id.
     */
    MessageId?: string;
    /**
     * The different kinds of messages that are used in the WebSocket api.
     */
    MessageType?: 'ForceKeepAlive' | 'GeneralCommand' | 'UserDataChanged' | 'Sessions' | 'Play' | 'SyncPlayCommand' | 'SyncPlayGroupUpdate' | 'Playstate' | 'RestartRequired' | 'ServerShuttingDown' | 'ServerRestarting' | 'LibraryChanged' | 'UserDeleted' | 'UserUpdated' | 'SeriesTimerCreated' | 'TimerCreated' | 'SeriesTimerCancelled' | 'TimerCancelled' | 'RefreshProgress' | 'ScheduledTaskEnded' | 'PackageInstallationCancelled' | 'PackageInstallationFailed' | 'PackageInstallationCompleted' | 'PackageInstalling' | 'PackageUninstalled' | 'ActivityLogEntry' | 'ScheduledTasksInfo' | 'ActivityLogEntryStart' | 'ActivityLogEntryStop' | 'SessionsStart' | 'SessionsStop' | 'ScheduledTasksInfoStart' | 'ScheduledTasksInfoStop' | 'KeepAlive';
};

/**
 * Series timer created message.
 */
export type SeriesTimerCreatedMessage = {
    /**
     * Gets or sets the data.
     */
    Data?: TimerEventInfo | null;
    /**
     * Gets or sets the message id.
     */
    MessageId?: string;
    /**
     * The different kinds of messages that are used in the WebSocket api.
     */
    MessageType?: 'ForceKeepAlive' | 'GeneralCommand' | 'UserDataChanged' | 'Sessions' | 'Play' | 'SyncPlayCommand' | 'SyncPlayGroupUpdate' | 'Playstate' | 'RestartRequired' | 'ServerShuttingDown' | 'ServerRestarting' | 'LibraryChanged' | 'UserDeleted' | 'UserUpdated' | 'SeriesTimerCreated' | 'TimerCreated' | 'SeriesTimerCancelled' | 'TimerCancelled' | 'RefreshProgress' | 'ScheduledTaskEnded' | 'PackageInstallationCancelled' | 'PackageInstallationFailed' | 'PackageInstallationCompleted' | 'PackageInstalling' | 'PackageUninstalled' | 'ActivityLogEntry' | 'ScheduledTasksInfo' | 'ActivityLogEntryStart' | 'ActivityLogEntryStop' | 'SessionsStart' | 'SessionsStop' | 'ScheduledTasksInfoStart' | 'ScheduledTasksInfoStop' | 'KeepAlive';
};

/**
 * Class SeriesTimerInfoDto.
 */
export type SeriesTimerInfoDto = {
    /**
     * Gets or sets the Id of the recording.
     */
    Id?: string | null;
    Type?: string | null;
    /**
     * Gets or sets the server identifier.
     */
    ServerId?: string | null;
    /**
     * Gets or sets the external identifier.
     */
    ExternalId?: string | null;
    /**
     * Gets or sets the channel id of the recording.
     */
    ChannelId?: string;
    /**
     * Gets or sets the external channel identifier.
     */
    ExternalChannelId?: string | null;
    /**
     * Gets or sets the channel name of the recording.
     */
    ChannelName?: string | null;
    ChannelPrimaryImageTag?: string | null;
    /**
     * Gets or sets the program identifier.
     */
    ProgramId?: string | null;
    /**
     * Gets or sets the external program identifier.
     */
    ExternalProgramId?: string | null;
    /**
     * Gets or sets the name of the recording.
     */
    Name?: string | null;
    /**
     * Gets or sets the description of the recording.
     */
    Overview?: string | null;
    /**
     * Gets or sets the start date of the recording, in UTC.
     */
    StartDate?: string;
    /**
     * Gets or sets the end date of the recording, in UTC.
     */
    EndDate?: string;
    /**
     * Gets or sets the name of the service.
     */
    ServiceName?: string | null;
    /**
     * Gets or sets the priority.
     */
    Priority?: number;
    /**
     * Gets or sets the pre padding seconds.
     */
    PrePaddingSeconds?: number;
    /**
     * Gets or sets the post padding seconds.
     */
    PostPaddingSeconds?: number;
    /**
     * Gets or sets a value indicating whether this instance is pre padding required.
     */
    IsPrePaddingRequired?: boolean;
    /**
     * Gets or sets the Id of the Parent that has a backdrop if the item does not have one.
     */
    ParentBackdropItemId?: string | null;
    /**
     * Gets or sets the parent backdrop image tags.
     */
    ParentBackdropImageTags?: Array<string> | null;
    /**
     * Gets or sets a value indicating whether this instance is post padding required.
     */
    IsPostPaddingRequired?: boolean;
    KeepUntil?: 'UntilDeleted' | 'UntilSpaceNeeded' | 'UntilWatched' | 'UntilDate';
    /**
     * Gets or sets a value indicating whether [record any time].
     */
    RecordAnyTime?: boolean;
    SkipEpisodesInLibrary?: boolean;
    /**
     * Gets or sets a value indicating whether [record any channel].
     */
    RecordAnyChannel?: boolean;
    KeepUpTo?: number;
    /**
     * Gets or sets a value indicating whether [record new only].
     */
    RecordNewOnly?: boolean;
    /**
     * Gets or sets the days.
     */
    Days?: Array<DayOfWeek> | null;
    /**
     * Gets or sets the day pattern.
     */
    DayPattern?: 'Daily' | 'Weekdays' | 'Weekends';
    /**
     * Gets or sets the image tags.
     */
    ImageTags?: {
        [key: string]: string;
    } | null;
    /**
     * Gets or sets the parent thumb item id.
     */
    ParentThumbItemId?: string | null;
    /**
     * Gets or sets the parent thumb image tag.
     */
    ParentThumbImageTag?: string | null;
    /**
     * Gets or sets the parent primary image item identifier.
     */
    ParentPrimaryImageItemId?: string | null;
    /**
     * Gets or sets the parent primary image tag.
     */
    ParentPrimaryImageTag?: string | null;
};

/**
 * Query result container.
 */
export type SeriesTimerInfoDtoQueryResult = {
    /**
     * Gets or sets the items.
     */
    Items?: Array<SeriesTimerInfoDto>;
    /**
     * Gets or sets the total number of records available.
     */
    TotalRecordCount?: number;
    /**
     * Gets or sets the index of the first record in Items.
     */
    StartIndex?: number;
};

/**
 * Represents the server configuration.
 */
export type ServerConfiguration = {
    /**
     * Gets or sets the number of days we should retain log files.
     */
    LogFileRetentionDays?: number;
    /**
     * Gets or sets a value indicating whether this instance is first run.
     */
    IsStartupWizardCompleted?: boolean;
    /**
     * Gets or sets the cache path.
     */
    CachePath?: string | null;
    /**
     * Gets or sets the last known version that was ran using the configuration.
     */
    PreviousVersion?: string | null;
    /**
     * Gets or sets the stringified PreviousVersion to be stored/loaded,
     * because System.Version itself isn't xml-serializable.
     */
    PreviousVersionStr?: string | null;
    /**
     * Gets or sets a value indicating whether to enable prometheus metrics exporting.
     */
    EnableMetrics?: boolean;
    EnableNormalizedItemByNameIds?: boolean;
    /**
     * Gets or sets a value indicating whether this instance is port authorized.
     */
    IsPortAuthorized?: boolean;
    /**
     * Gets or sets a value indicating whether quick connect is available for use on this server.
     */
    QuickConnectAvailable?: boolean;
    /**
     * Gets or sets a value indicating whether [enable case sensitive item ids].
     */
    EnableCaseSensitiveItemIds?: boolean;
    DisableLiveTvChannelUserDataName?: boolean;
    /**
     * Gets or sets the metadata path.
     */
    MetadataPath?: string;
    /**
     * Gets or sets the preferred metadata language.
     */
    PreferredMetadataLanguage?: string;
    /**
     * Gets or sets the metadata country code.
     */
    MetadataCountryCode?: string;
    /**
     * Gets or sets characters to be replaced with a ' ' in strings to create a sort name.
     */
    SortReplaceCharacters?: Array<string>;
    /**
     * Gets or sets characters to be removed from strings to create a sort name.
     */
    SortRemoveCharacters?: Array<string>;
    /**
     * Gets or sets words to be removed from strings to create a sort name.
     */
    SortRemoveWords?: Array<string>;
    /**
     * Gets or sets the minimum percentage of an item that must be played in order for playstate to be updated.
     */
    MinResumePct?: number;
    /**
     * Gets or sets the maximum percentage of an item that can be played while still saving playstate. If this percentage is crossed playstate will be reset to the beginning and the item will be marked watched.
     */
    MaxResumePct?: number;
    /**
     * Gets or sets the minimum duration that an item must have in order to be eligible for playstate updates..
     */
    MinResumeDurationSeconds?: number;
    /**
     * Gets or sets the minimum minutes of a book that must be played in order for playstate to be updated.
     */
    MinAudiobookResume?: number;
    /**
     * Gets or sets the remaining minutes of a book that can be played while still saving playstate. If this percentage is crossed playstate will be reset to the beginning and the item will be marked watched.
     */
    MaxAudiobookResume?: number;
    /**
     * Gets or sets the threshold in minutes after a inactive session gets closed automatically.
     * If set to 0 the check for inactive sessions gets disabled.
     */
    InactiveSessionThreshold?: number;
    /**
     * Gets or sets the delay in seconds that we will wait after a file system change to try and discover what has been added/removed
     * Some delay is necessary with some items because their creation is not atomic.  It involves the creation of several
     * different directories and files.
     */
    LibraryMonitorDelay?: number;
    /**
     * Gets or sets the duration in seconds that we will wait after a library updated event before executing the library changed notification.
     */
    LibraryUpdateDuration?: number;
    /**
     * Gets or sets the image saving convention.
     */
    ImageSavingConvention?: 'Legacy' | 'Compatible';
    MetadataOptions?: Array<MetadataOptions>;
    SkipDeserializationForBasicTypes?: boolean;
    ServerName?: string;
    UICulture?: string;
    SaveMetadataHidden?: boolean;
    ContentTypes?: Array<NameValuePair>;
    RemoteClientBitrateLimit?: number;
    EnableFolderView?: boolean;
    EnableGroupingIntoCollections?: boolean;
    DisplaySpecialsWithinSeasons?: boolean;
    CodecsUsed?: Array<string>;
    PluginRepositories?: Array<RepositoryInfo>;
    EnableExternalContentInSuggestions?: boolean;
    ImageExtractionTimeoutMs?: number;
    PathSubstitutions?: Array<PathSubstitution>;
    /**
     * Gets or sets a value indicating whether slow server responses should be logged as a warning.
     */
    EnableSlowResponseWarning?: boolean;
    /**
     * Gets or sets the threshold for the slow response time warning in ms.
     */
    SlowResponseThresholdMs?: number;
    /**
     * Gets or sets the cors hosts.
     */
    CorsHosts?: Array<string>;
    /**
     * Gets or sets the number of days we should retain activity logs.
     */
    ActivityLogRetentionDays?: number | null;
    /**
     * Gets or sets the how the library scan fans out.
     */
    LibraryScanFanoutConcurrency?: number;
    /**
     * Gets or sets the how many metadata refreshes can run concurrently.
     */
    LibraryMetadataRefreshConcurrency?: number;
    /**
     * Gets or sets a value indicating whether older plugins should automatically be deleted from the plugin folder.
     */
    RemoveOldPlugins?: boolean;
    /**
     * Gets or sets a value indicating whether clients should be allowed to upload logs.
     */
    AllowClientLogUpload?: boolean;
    /**
     * Gets or sets the dummy chapter duration in seconds, use 0 (zero) or less to disable generation alltogether.
     */
    DummyChapterDuration?: number;
    /**
     * Gets or sets the chapter image resolution.
     */
    ChapterImageResolution?: 'MatchSource' | 'P144' | 'P240' | 'P360' | 'P480' | 'P720' | 'P1080' | 'P1440' | 'P2160';
    /**
     * Gets or sets the limit for parallel image encoding.
     */
    ParallelImageEncodingLimit?: number;
    /**
     * Gets or sets the list of cast receiver applications.
     */
    CastReceiverApplications?: Array<CastReceiverApplication>;
    /**
     * Gets or sets the trickplay options.
     */
    TrickplayOptions?: TrickplayOptions;
};

/**
 * The server discovery info model.
 */
export type ServerDiscoveryInfo = {
    /**
     * Gets the address.
     */
    Address?: string;
    /**
     * Gets the server identifier.
     */
    Id?: string;
    /**
     * Gets the name.
     */
    Name?: string;
    /**
     * Gets the endpoint address.
     */
    EndpointAddress?: string | null;
};

/**
 * Server restarting down message.
 */
export type ServerRestartingMessage = {
    /**
     * Gets or sets the message id.
     */
    MessageId?: string;
    /**
     * The different kinds of messages that are used in the WebSocket api.
     */
    MessageType?: 'ForceKeepAlive' | 'GeneralCommand' | 'UserDataChanged' | 'Sessions' | 'Play' | 'SyncPlayCommand' | 'SyncPlayGroupUpdate' | 'Playstate' | 'RestartRequired' | 'ServerShuttingDown' | 'ServerRestarting' | 'LibraryChanged' | 'UserDeleted' | 'UserUpdated' | 'SeriesTimerCreated' | 'TimerCreated' | 'SeriesTimerCancelled' | 'TimerCancelled' | 'RefreshProgress' | 'ScheduledTaskEnded' | 'PackageInstallationCancelled' | 'PackageInstallationFailed' | 'PackageInstallationCompleted' | 'PackageInstalling' | 'PackageUninstalled' | 'ActivityLogEntry' | 'ScheduledTasksInfo' | 'ActivityLogEntryStart' | 'ActivityLogEntryStop' | 'SessionsStart' | 'SessionsStop' | 'ScheduledTasksInfoStart' | 'ScheduledTasksInfoStop' | 'KeepAlive';
};

/**
 * Server shutting down message.
 */
export type ServerShuttingDownMessage = {
    /**
     * Gets or sets the message id.
     */
    MessageId?: string;
    /**
     * The different kinds of messages that are used in the WebSocket api.
     */
    MessageType?: 'ForceKeepAlive' | 'GeneralCommand' | 'UserDataChanged' | 'Sessions' | 'Play' | 'SyncPlayCommand' | 'SyncPlayGroupUpdate' | 'Playstate' | 'RestartRequired' | 'ServerShuttingDown' | 'ServerRestarting' | 'LibraryChanged' | 'UserDeleted' | 'UserUpdated' | 'SeriesTimerCreated' | 'TimerCreated' | 'SeriesTimerCancelled' | 'TimerCancelled' | 'RefreshProgress' | 'ScheduledTaskEnded' | 'PackageInstallationCancelled' | 'PackageInstallationFailed' | 'PackageInstallationCompleted' | 'PackageInstalling' | 'PackageUninstalled' | 'ActivityLogEntry' | 'ScheduledTasksInfo' | 'ActivityLogEntryStart' | 'ActivityLogEntryStop' | 'SessionsStart' | 'SessionsStop' | 'ScheduledTasksInfoStart' | 'ScheduledTasksInfoStop' | 'KeepAlive';
};

/**
 * Session info DTO.
 */
export type SessionInfoDto = {
    /**
     * Gets or sets the play state.
     */
    PlayState?: PlayerStateInfo | null;
    /**
     * Gets or sets the additional users.
     */
    AdditionalUsers?: Array<SessionUserInfo> | null;
    /**
     * Gets or sets the client capabilities.
     */
    Capabilities?: ClientCapabilitiesDto | null;
    /**
     * Gets or sets the remote end point.
     */
    RemoteEndPoint?: string | null;
    /**
     * Gets or sets the playable media types.
     */
    PlayableMediaTypes?: Array<MediaType>;
    /**
     * Gets or sets the id.
     */
    Id?: string | null;
    /**
     * Gets or sets the user id.
     */
    UserId?: string;
    /**
     * Gets or sets the username.
     */
    UserName?: string | null;
    /**
     * Gets or sets the type of the client.
     */
    Client?: string | null;
    /**
     * Gets or sets the last activity date.
     */
    LastActivityDate?: string;
    /**
     * Gets or sets the last playback check in.
     */
    LastPlaybackCheckIn?: string;
    /**
     * Gets or sets the last paused date.
     */
    LastPausedDate?: string | null;
    /**
     * Gets or sets the name of the device.
     */
    DeviceName?: string | null;
    /**
     * Gets or sets the type of the device.
     */
    DeviceType?: string | null;
    /**
     * Gets or sets the now playing item.
     */
    NowPlayingItem?: BaseItemDto | null;
    /**
     * Gets or sets the now viewing item.
     */
    NowViewingItem?: BaseItemDto | null;
    /**
     * Gets or sets the device id.
     */
    DeviceId?: string | null;
    /**
     * Gets or sets the application version.
     */
    ApplicationVersion?: string | null;
    /**
     * Gets or sets the transcoding info.
     */
    TranscodingInfo?: TranscodingInfo | null;
    /**
     * Gets or sets a value indicating whether this session is active.
     */
    IsActive?: boolean;
    /**
     * Gets or sets a value indicating whether the session supports media control.
     */
    SupportsMediaControl?: boolean;
    /**
     * Gets or sets a value indicating whether the session supports remote control.
     */
    SupportsRemoteControl?: boolean;
    /**
     * Gets or sets the now playing queue.
     */
    NowPlayingQueue?: Array<QueueItem> | null;
    /**
     * Gets or sets the now playing queue full items.
     */
    NowPlayingQueueFullItems?: Array<BaseItemDto> | null;
    /**
     * Gets or sets a value indicating whether the session has a custom device name.
     */
    HasCustomDeviceName?: boolean;
    /**
     * Gets or sets the playlist item id.
     */
    PlaylistItemId?: string | null;
    /**
     * Gets or sets the server id.
     */
    ServerId?: string | null;
    /**
     * Gets or sets the user primary image tag.
     */
    UserPrimaryImageTag?: string | null;
    /**
     * Gets or sets the supported commands.
     */
    SupportedCommands?: Array<GeneralCommandType>;
};

/**
 * The different kinds of messages that are used in the WebSocket api.
 */
export type SessionMessageType = 'ForceKeepAlive' | 'GeneralCommand' | 'UserDataChanged' | 'Sessions' | 'Play' | 'SyncPlayCommand' | 'SyncPlayGroupUpdate' | 'Playstate' | 'RestartRequired' | 'ServerShuttingDown' | 'ServerRestarting' | 'LibraryChanged' | 'UserDeleted' | 'UserUpdated' | 'SeriesTimerCreated' | 'TimerCreated' | 'SeriesTimerCancelled' | 'TimerCancelled' | 'RefreshProgress' | 'ScheduledTaskEnded' | 'PackageInstallationCancelled' | 'PackageInstallationFailed' | 'PackageInstallationCompleted' | 'PackageInstalling' | 'PackageUninstalled' | 'ActivityLogEntry' | 'ScheduledTasksInfo' | 'ActivityLogEntryStart' | 'ActivityLogEntryStop' | 'SessionsStart' | 'SessionsStop' | 'ScheduledTasksInfoStart' | 'ScheduledTasksInfoStop' | 'KeepAlive';

/**
 * Sessions message.
 */
export type SessionsMessage = {
    /**
     * Gets or sets the data.
     */
    Data?: Array<SessionInfoDto> | null;
    /**
     * Gets or sets the message id.
     */
    MessageId?: string;
    /**
     * The different kinds of messages that are used in the WebSocket api.
     */
    MessageType?: 'ForceKeepAlive' | 'GeneralCommand' | 'UserDataChanged' | 'Sessions' | 'Play' | 'SyncPlayCommand' | 'SyncPlayGroupUpdate' | 'Playstate' | 'RestartRequired' | 'ServerShuttingDown' | 'ServerRestarting' | 'LibraryChanged' | 'UserDeleted' | 'UserUpdated' | 'SeriesTimerCreated' | 'TimerCreated' | 'SeriesTimerCancelled' | 'TimerCancelled' | 'RefreshProgress' | 'ScheduledTaskEnded' | 'PackageInstallationCancelled' | 'PackageInstallationFailed' | 'PackageInstallationCompleted' | 'PackageInstalling' | 'PackageUninstalled' | 'ActivityLogEntry' | 'ScheduledTasksInfo' | 'ActivityLogEntryStart' | 'ActivityLogEntryStop' | 'SessionsStart' | 'SessionsStop' | 'ScheduledTasksInfoStart' | 'ScheduledTasksInfoStop' | 'KeepAlive';
};

/**
 * Sessions start message.
 * Data is the timing data encoded as "$initialDelay,$interval" in ms.
 */
export type SessionsStartMessage = {
    /**
     * Gets or sets the data.
     */
    Data?: string | null;
    /**
     * The different kinds of messages that are used in the WebSocket api.
     */
    MessageType?: 'ForceKeepAlive' | 'GeneralCommand' | 'UserDataChanged' | 'Sessions' | 'Play' | 'SyncPlayCommand' | 'SyncPlayGroupUpdate' | 'Playstate' | 'RestartRequired' | 'ServerShuttingDown' | 'ServerRestarting' | 'LibraryChanged' | 'UserDeleted' | 'UserUpdated' | 'SeriesTimerCreated' | 'TimerCreated' | 'SeriesTimerCancelled' | 'TimerCancelled' | 'RefreshProgress' | 'ScheduledTaskEnded' | 'PackageInstallationCancelled' | 'PackageInstallationFailed' | 'PackageInstallationCompleted' | 'PackageInstalling' | 'PackageUninstalled' | 'ActivityLogEntry' | 'ScheduledTasksInfo' | 'ActivityLogEntryStart' | 'ActivityLogEntryStop' | 'SessionsStart' | 'SessionsStop' | 'ScheduledTasksInfoStart' | 'ScheduledTasksInfoStop' | 'KeepAlive';
};

/**
 * Sessions stop message.
 */
export type SessionsStopMessage = {
    /**
     * The different kinds of messages that are used in the WebSocket api.
     */
    MessageType?: 'ForceKeepAlive' | 'GeneralCommand' | 'UserDataChanged' | 'Sessions' | 'Play' | 'SyncPlayCommand' | 'SyncPlayGroupUpdate' | 'Playstate' | 'RestartRequired' | 'ServerShuttingDown' | 'ServerRestarting' | 'LibraryChanged' | 'UserDeleted' | 'UserUpdated' | 'SeriesTimerCreated' | 'TimerCreated' | 'SeriesTimerCancelled' | 'TimerCancelled' | 'RefreshProgress' | 'ScheduledTaskEnded' | 'PackageInstallationCancelled' | 'PackageInstallationFailed' | 'PackageInstallationCompleted' | 'PackageInstalling' | 'PackageUninstalled' | 'ActivityLogEntry' | 'ScheduledTasksInfo' | 'ActivityLogEntryStart' | 'ActivityLogEntryStop' | 'SessionsStart' | 'SessionsStop' | 'ScheduledTasksInfoStart' | 'ScheduledTasksInfoStop' | 'KeepAlive';
};

/**
 * Class SessionUserInfo.
 */
export type SessionUserInfo = {
    /**
     * Gets or sets the user identifier.
     */
    UserId?: string;
    /**
     * Gets or sets the name of the user.
     */
    UserName?: string | null;
};

/**
 * Set channel mapping dto.
 */
export type SetChannelMappingDto = {
    /**
     * Gets or sets the provider id.
     */
    ProviderId: string;
    /**
     * Gets or sets the tuner channel id.
     */
    TunerChannelId: string;
    /**
     * Gets or sets the provider channel id.
     */
    ProviderChannelId: string;
};

/**
 * Class SetPlaylistItemRequestDto.
 */
export type SetPlaylistItemRequestDto = {
    /**
     * Gets or sets the playlist identifier of the playing item.
     */
    PlaylistItemId?: string;
};

/**
 * Class SetRepeatModeRequestDto.
 */
export type SetRepeatModeRequestDto = {
    /**
     * Gets or sets the repeat mode.
     */
    Mode?: 'RepeatOne' | 'RepeatAll' | 'RepeatNone';
};

/**
 * Class SetShuffleModeRequestDto.
 */
export type SetShuffleModeRequestDto = {
    /**
     * Gets or sets the shuffle mode.
     */
    Mode?: 'Sorted' | 'Shuffle';
};

export type SongInfo = {
    /**
     * Gets or sets the name.
     */
    Name?: string | null;
    /**
     * Gets or sets the original title.
     */
    OriginalTitle?: string | null;
    /**
     * Gets or sets the path.
     */
    Path?: string | null;
    /**
     * Gets or sets the metadata language.
     */
    MetadataLanguage?: string | null;
    /**
     * Gets or sets the metadata country code.
     */
    MetadataCountryCode?: string | null;
    /**
     * Gets or sets the provider ids.
     */
    ProviderIds?: {
        [key: string]: string | null;
    } | null;
    /**
     * Gets or sets the year.
     */
    Year?: number | null;
    IndexNumber?: number | null;
    ParentIndexNumber?: number | null;
    PremiereDate?: string | null;
    IsAutomated?: boolean;
    AlbumArtists?: Array<string> | null;
    Album?: string | null;
    Artists?: Array<string> | null;
};

/**
 * An enum representing the sorting order.
 */
export type SortOrder = 'Ascending' | 'Descending';

/**
 * Special view option dto.
 */
export type SpecialViewOptionDto = {
    /**
     * Gets or sets view option name.
     */
    Name?: string | null;
    /**
     * Gets or sets view option id.
     */
    Id?: string | null;
};

/**
 * The startup configuration DTO.
 */
export type StartupConfigurationDto = {
    /**
     * Gets or sets UI language culture.
     */
    UICulture?: string | null;
    /**
     * Gets or sets the metadata country code.
     */
    MetadataCountryCode?: string | null;
    /**
     * Gets or sets the preferred language for the metadata.
     */
    PreferredMetadataLanguage?: string | null;
};

/**
 * Startup remote access dto.
 */
export type StartupRemoteAccessDto = {
    /**
     * Gets or sets a value indicating whether enable remote access.
     */
    EnableRemoteAccess: boolean;
    /**
     * Gets or sets a value indicating whether enable automatic port mapping.
     */
    EnableAutomaticPortMapping: boolean;
};

/**
 * The startup user DTO.
 */
export type StartupUserDto = {
    /**
     * Gets or sets the username.
     */
    Name?: string | null;
    /**
     * Gets or sets the user's password.
     */
    Password?: string | null;
};

/**
 * Class GroupUpdate.
 */
export type StringGroupUpdate = {
    /**
     * Gets the group identifier.
     */
    readonly GroupId?: string;
    /**
     * Gets the update type.
     */
    Type?: 'UserJoined' | 'UserLeft' | 'GroupJoined' | 'GroupLeft' | 'StateUpdate' | 'PlayQueue' | 'NotInGroup' | 'GroupDoesNotExist' | 'CreateGroupDenied' | 'JoinGroupDenied' | 'LibraryAccessDenied';
    /**
     * Gets the update data.
     */
    Data?: string;
};

/**
 * Delivery method to use during playback of a specific subtitle format.
 */
export type SubtitleDeliveryMethod = 'Encode' | 'Embed' | 'External' | 'Hls' | 'Drop';

export type SubtitleOptions = {
    SkipIfEmbeddedSubtitlesPresent?: boolean;
    SkipIfAudioTrackMatches?: boolean;
    DownloadLanguages?: Array<string> | null;
    DownloadMovieSubtitles?: boolean;
    DownloadEpisodeSubtitles?: boolean;
    OpenSubtitlesUsername?: string | null;
    OpenSubtitlesPasswordHash?: string | null;
    IsOpenSubtitleVipAccount?: boolean;
    RequirePerfectMatch?: boolean;
};

/**
 * An enum representing a subtitle playback mode.
 */
export type SubtitlePlaybackMode = 'Default' | 'Always' | 'OnlyForced' | 'None' | 'Smart';

/**
 * A class for subtitle profile information.
 */
export type SubtitleProfile = {
    /**
     * Gets or sets the format.
     */
    Format?: string | null;
    /**
     * Gets or sets the delivery method.
     */
    Method?: 'Encode' | 'Embed' | 'External' | 'Hls' | 'Drop';
    /**
     * Gets or sets the DIDL mode.
     */
    DidlMode?: string | null;
    /**
     * Gets or sets the language.
     */
    Language?: string | null;
    /**
     * Gets or sets the container.
     */
    Container?: string | null;
};

/**
 * Sync play command.
 */
export type SyncPlayCommandMessage = {
    /**
     * Gets or sets the data.
     */
    Data?: SendCommand | null;
    /**
     * Gets or sets the message id.
     */
    MessageId?: string;
    /**
     * The different kinds of messages that are used in the WebSocket api.
     */
    MessageType?: 'ForceKeepAlive' | 'GeneralCommand' | 'UserDataChanged' | 'Sessions' | 'Play' | 'SyncPlayCommand' | 'SyncPlayGroupUpdate' | 'Playstate' | 'RestartRequired' | 'ServerShuttingDown' | 'ServerRestarting' | 'LibraryChanged' | 'UserDeleted' | 'UserUpdated' | 'SeriesTimerCreated' | 'TimerCreated' | 'SeriesTimerCancelled' | 'TimerCancelled' | 'RefreshProgress' | 'ScheduledTaskEnded' | 'PackageInstallationCancelled' | 'PackageInstallationFailed' | 'PackageInstallationCompleted' | 'PackageInstalling' | 'PackageUninstalled' | 'ActivityLogEntry' | 'ScheduledTasksInfo' | 'ActivityLogEntryStart' | 'ActivityLogEntryStop' | 'SessionsStart' | 'SessionsStop' | 'ScheduledTasksInfoStart' | 'ScheduledTasksInfoStop' | 'KeepAlive';
};

/**
 * Untyped sync play command.
 */
export type SyncPlayGroupUpdateCommandMessage = {
    /**
     * Gets or sets the data.
     */
    Data?: (GroupUpdate & {
        Type?: 'SyncPlayGroupUpdateCommandMessage';
    }) | null;
    /**
     * Gets or sets the message id.
     */
    MessageId?: string;
    /**
     * The different kinds of messages that are used in the WebSocket api.
     */
    MessageType?: 'ForceKeepAlive' | 'GeneralCommand' | 'UserDataChanged' | 'Sessions' | 'Play' | 'SyncPlayCommand' | 'SyncPlayGroupUpdate' | 'Playstate' | 'RestartRequired' | 'ServerShuttingDown' | 'ServerRestarting' | 'LibraryChanged' | 'UserDeleted' | 'UserUpdated' | 'SeriesTimerCreated' | 'TimerCreated' | 'SeriesTimerCancelled' | 'TimerCancelled' | 'RefreshProgress' | 'ScheduledTaskEnded' | 'PackageInstallationCancelled' | 'PackageInstallationFailed' | 'PackageInstallationCompleted' | 'PackageInstalling' | 'PackageUninstalled' | 'ActivityLogEntry' | 'ScheduledTasksInfo' | 'ActivityLogEntryStart' | 'ActivityLogEntryStop' | 'SessionsStart' | 'SessionsStop' | 'ScheduledTasksInfoStart' | 'ScheduledTasksInfoStop' | 'KeepAlive';
};

/**
 * Class QueueItem.
 */
export type SyncPlayQueueItem = {
    /**
     * Gets the item identifier.
     */
    ItemId?: string;
    /**
     * Gets the playlist identifier of the item.
     */
    readonly PlaylistItemId?: string;
};

/**
 * Enum SyncPlayUserAccessType.
 */
export type SyncPlayUserAccessType = 'CreateAndJoinGroups' | 'JoinGroups' | 'None';

/**
 * Class SystemInfo.
 */
export type SystemInfo = {
    /**
     * Gets or sets the local address.
     */
    LocalAddress?: string | null;
    /**
     * Gets or sets the name of the server.
     */
    ServerName?: string | null;
    /**
     * Gets or sets the server version.
     */
    Version?: string | null;
    /**
     * Gets or sets the product name. This is the AssemblyProduct name.
     */
    ProductName?: string | null;
    /**
     * Gets or sets the operating system.
     * @deprecated
     */
    OperatingSystem?: string | null;
    /**
     * Gets or sets the id.
     */
    Id?: string | null;
    /**
     * Gets or sets a value indicating whether the startup wizard is completed.
     */
    StartupWizardCompleted?: boolean | null;
    /**
     * Gets or sets the display name of the operating system.
     * @deprecated
     */
    OperatingSystemDisplayName?: string | null;
    /**
     * Gets or sets the package name.
     */
    PackageName?: string | null;
    /**
     * Gets or sets a value indicating whether this instance has pending restart.
     */
    HasPendingRestart?: boolean;
    IsShuttingDown?: boolean;
    /**
     * Gets or sets a value indicating whether [supports library monitor].
     */
    SupportsLibraryMonitor?: boolean;
    /**
     * Gets or sets the web socket port number.
     */
    WebSocketPortNumber?: number;
    /**
     * Gets or sets the completed installations.
     */
    CompletedInstallations?: Array<InstallationInfo> | null;
    /**
     * Gets or sets a value indicating whether this instance can self restart.
     * @deprecated
     */
    CanSelfRestart?: boolean;
    /**
     * @deprecated
     */
    CanLaunchWebBrowser?: boolean;
    /**
     * Gets or sets the program data path.
     */
    ProgramDataPath?: string | null;
    /**
     * Gets or sets the web UI resources path.
     */
    WebPath?: string | null;
    /**
     * Gets or sets the items by name path.
     */
    ItemsByNamePath?: string | null;
    /**
     * Gets or sets the cache path.
     */
    CachePath?: string | null;
    /**
     * Gets or sets the log path.
     */
    LogPath?: string | null;
    /**
     * Gets or sets the internal metadata path.
     */
    InternalMetadataPath?: string | null;
    /**
     * Gets or sets the transcode path.
     */
    TranscodingTempPath?: string | null;
    /**
     * Gets or sets the list of cast receiver applications.
     */
    CastReceiverApplications?: Array<CastReceiverApplication> | null;
    /**
     * Gets or sets a value indicating whether this instance has update available.
     * @deprecated
     */
    HasUpdateAvailable?: boolean;
    /**
     * @deprecated
     */
    EncoderLocation?: string | null;
    /**
     * @deprecated
     */
    SystemArchitecture?: string | null;
};

/**
 * Enum TaskCompletionStatus.
 */
export type TaskCompletionStatus = 'Completed' | 'Failed' | 'Cancelled' | 'Aborted';

/**
 * Class TaskInfo.
 */
export type TaskInfo = {
    /**
     * Gets or sets the name.
     */
    Name?: string | null;
    /**
     * Gets or sets the state of the task.
     */
    State?: 'Idle' | 'Cancelling' | 'Running';
    /**
     * Gets or sets the progress.
     */
    CurrentProgressPercentage?: number | null;
    /**
     * Gets or sets the id.
     */
    Id?: string | null;
    /**
     * Gets or sets the last execution result.
     */
    LastExecutionResult?: TaskResult | null;
    /**
     * Gets or sets the triggers.
     */
    Triggers?: Array<TaskTriggerInfo> | null;
    /**
     * Gets or sets the description.
     */
    Description?: string | null;
    /**
     * Gets or sets the category.
     */
    Category?: string | null;
    /**
     * Gets or sets a value indicating whether this instance is hidden.
     */
    IsHidden?: boolean;
    /**
     * Gets or sets the key.
     */
    Key?: string | null;
};

/**
 * Class TaskExecutionInfo.
 */
export type TaskResult = {
    /**
     * Gets or sets the start time UTC.
     */
    StartTimeUtc?: string;
    /**
     * Gets or sets the end time UTC.
     */
    EndTimeUtc?: string;
    /**
     * Gets or sets the status.
     */
    Status?: 'Completed' | 'Failed' | 'Cancelled' | 'Aborted';
    /**
     * Gets or sets the name.
     */
    Name?: string | null;
    /**
     * Gets or sets the key.
     */
    Key?: string | null;
    /**
     * Gets or sets the id.
     */
    Id?: string | null;
    /**
     * Gets or sets the error message.
     */
    ErrorMessage?: string | null;
    /**
     * Gets or sets the long error message.
     */
    LongErrorMessage?: string | null;
};

/**
 * Enum TaskState.
 */
export type TaskState = 'Idle' | 'Cancelling' | 'Running';

/**
 * Class TaskTriggerInfo.
 */
export type TaskTriggerInfo = {
    /**
     * Gets or sets the type.
     */
    Type?: string | null;
    /**
     * Gets or sets the time of day.
     */
    TimeOfDayTicks?: number | null;
    /**
     * Gets or sets the interval.
     */
    IntervalTicks?: number | null;
    /**
     * Gets or sets the day of week.
     */
    DayOfWeek?: 'Sunday' | 'Monday' | 'Tuesday' | 'Wednesday' | 'Thursday' | 'Friday' | 'Saturday';
    /**
     * Gets or sets the maximum runtime ticks.
     */
    MaxRuntimeTicks?: number | null;
};

/**
 * Class ThemeMediaResult.
 */
export type ThemeMediaResult = {
    /**
     * Gets or sets the items.
     */
    Items?: Array<BaseItemDto>;
    /**
     * Gets or sets the total number of records available.
     */
    TotalRecordCount?: number;
    /**
     * Gets or sets the index of the first record in Items.
     */
    StartIndex?: number;
    /**
     * Gets or sets the owner id.
     */
    OwnerId?: string;
};

/**
 * Timer cancelled message.
 */
export type TimerCancelledMessage = {
    /**
     * Gets or sets the data.
     */
    Data?: TimerEventInfo | null;
    /**
     * Gets or sets the message id.
     */
    MessageId?: string;
    /**
     * The different kinds of messages that are used in the WebSocket api.
     */
    MessageType?: 'ForceKeepAlive' | 'GeneralCommand' | 'UserDataChanged' | 'Sessions' | 'Play' | 'SyncPlayCommand' | 'SyncPlayGroupUpdate' | 'Playstate' | 'RestartRequired' | 'ServerShuttingDown' | 'ServerRestarting' | 'LibraryChanged' | 'UserDeleted' | 'UserUpdated' | 'SeriesTimerCreated' | 'TimerCreated' | 'SeriesTimerCancelled' | 'TimerCancelled' | 'RefreshProgress' | 'ScheduledTaskEnded' | 'PackageInstallationCancelled' | 'PackageInstallationFailed' | 'PackageInstallationCompleted' | 'PackageInstalling' | 'PackageUninstalled' | 'ActivityLogEntry' | 'ScheduledTasksInfo' | 'ActivityLogEntryStart' | 'ActivityLogEntryStop' | 'SessionsStart' | 'SessionsStop' | 'ScheduledTasksInfoStart' | 'ScheduledTasksInfoStop' | 'KeepAlive';
};

/**
 * Timer created message.
 */
export type TimerCreatedMessage = {
    /**
     * Gets or sets the data.
     */
    Data?: TimerEventInfo | null;
    /**
     * Gets or sets the message id.
     */
    MessageId?: string;
    /**
     * The different kinds of messages that are used in the WebSocket api.
     */
    MessageType?: 'ForceKeepAlive' | 'GeneralCommand' | 'UserDataChanged' | 'Sessions' | 'Play' | 'SyncPlayCommand' | 'SyncPlayGroupUpdate' | 'Playstate' | 'RestartRequired' | 'ServerShuttingDown' | 'ServerRestarting' | 'LibraryChanged' | 'UserDeleted' | 'UserUpdated' | 'SeriesTimerCreated' | 'TimerCreated' | 'SeriesTimerCancelled' | 'TimerCancelled' | 'RefreshProgress' | 'ScheduledTaskEnded' | 'PackageInstallationCancelled' | 'PackageInstallationFailed' | 'PackageInstallationCompleted' | 'PackageInstalling' | 'PackageUninstalled' | 'ActivityLogEntry' | 'ScheduledTasksInfo' | 'ActivityLogEntryStart' | 'ActivityLogEntryStop' | 'SessionsStart' | 'SessionsStop' | 'ScheduledTasksInfoStart' | 'ScheduledTasksInfoStop' | 'KeepAlive';
};

export type TimerEventInfo = {
    Id?: string;
    ProgramId?: string | null;
};

export type TimerInfoDto = {
    /**
     * Gets or sets the Id of the recording.
     */
    Id?: string | null;
    Type?: string | null;
    /**
     * Gets or sets the server identifier.
     */
    ServerId?: string | null;
    /**
     * Gets or sets the external identifier.
     */
    ExternalId?: string | null;
    /**
     * Gets or sets the channel id of the recording.
     */
    ChannelId?: string;
    /**
     * Gets or sets the external channel identifier.
     */
    ExternalChannelId?: string | null;
    /**
     * Gets or sets the channel name of the recording.
     */
    ChannelName?: string | null;
    ChannelPrimaryImageTag?: string | null;
    /**
     * Gets or sets the program identifier.
     */
    ProgramId?: string | null;
    /**
     * Gets or sets the external program identifier.
     */
    ExternalProgramId?: string | null;
    /**
     * Gets or sets the name of the recording.
     */
    Name?: string | null;
    /**
     * Gets or sets the description of the recording.
     */
    Overview?: string | null;
    /**
     * Gets or sets the start date of the recording, in UTC.
     */
    StartDate?: string;
    /**
     * Gets or sets the end date of the recording, in UTC.
     */
    EndDate?: string;
    /**
     * Gets or sets the name of the service.
     */
    ServiceName?: string | null;
    /**
     * Gets or sets the priority.
     */
    Priority?: number;
    /**
     * Gets or sets the pre padding seconds.
     */
    PrePaddingSeconds?: number;
    /**
     * Gets or sets the post padding seconds.
     */
    PostPaddingSeconds?: number;
    /**
     * Gets or sets a value indicating whether this instance is pre padding required.
     */
    IsPrePaddingRequired?: boolean;
    /**
     * Gets or sets the Id of the Parent that has a backdrop if the item does not have one.
     */
    ParentBackdropItemId?: string | null;
    /**
     * Gets or sets the parent backdrop image tags.
     */
    ParentBackdropImageTags?: Array<string> | null;
    /**
     * Gets or sets a value indicating whether this instance is post padding required.
     */
    IsPostPaddingRequired?: boolean;
    KeepUntil?: 'UntilDeleted' | 'UntilSpaceNeeded' | 'UntilWatched' | 'UntilDate';
    /**
     * Gets or sets the status.
     */
    Status?: 'New' | 'InProgress' | 'Completed' | 'Cancelled' | 'ConflictedOk' | 'ConflictedNotOk' | 'Error';
    /**
     * Gets or sets the series timer identifier.
     */
    SeriesTimerId?: string | null;
    /**
     * Gets or sets the external series timer identifier.
     */
    ExternalSeriesTimerId?: string | null;
    /**
     * Gets or sets the run time ticks.
     */
    RunTimeTicks?: number | null;
    /**
     * Gets or sets the program information.
     */
    ProgramInfo?: BaseItemDto | null;
};

/**
 * Query result container.
 */
export type TimerInfoDtoQueryResult = {
    /**
     * Gets or sets the items.
     */
    Items?: Array<TimerInfoDto>;
    /**
     * Gets or sets the total number of records available.
     */
    TotalRecordCount?: number;
    /**
     * Gets or sets the index of the first record in Items.
     */
    StartIndex?: number;
};

/**
 * Enum containing tonemapping algorithms.
 */
export type TonemappingAlgorithm = 'none' | 'clip' | 'linear' | 'gamma' | 'reinhard' | 'hable' | 'mobius' | 'bt2390';

/**
 * Enum containing tonemapping modes.
 */
export type TonemappingMode = 'auto' | 'max' | 'rgb' | 'lum' | 'itp';

/**
 * Enum containing tonemapping ranges.
 */
export type TonemappingRange = 'auto' | 'tv' | 'pc';

export type TrailerInfo = {
    /**
     * Gets or sets the name.
     */
    Name?: string | null;
    /**
     * Gets or sets the original title.
     */
    OriginalTitle?: string | null;
    /**
     * Gets or sets the path.
     */
    Path?: string | null;
    /**
     * Gets or sets the metadata language.
     */
    MetadataLanguage?: string | null;
    /**
     * Gets or sets the metadata country code.
     */
    MetadataCountryCode?: string | null;
    /**
     * Gets or sets the provider ids.
     */
    ProviderIds?: {
        [key: string]: string | null;
    } | null;
    /**
     * Gets or sets the year.
     */
    Year?: number | null;
    IndexNumber?: number | null;
    ParentIndexNumber?: number | null;
    PremiereDate?: string | null;
    IsAutomated?: boolean;
};

export type TrailerInfoRemoteSearchQuery = {
    SearchInfo?: TrailerInfo | null;
    ItemId?: string;
    /**
     * Gets or sets the provider name to search within if set.
     */
    SearchProviderName?: string | null;
    /**
     * Gets or sets a value indicating whether disabled providers should be included.
     */
    IncludeDisabledProviders?: boolean;
};

export type TranscodeReason = 'ContainerNotSupported' | 'VideoCodecNotSupported' | 'AudioCodecNotSupported' | 'SubtitleCodecNotSupported' | 'AudioIsExternal' | 'SecondaryAudioNotSupported' | 'VideoProfileNotSupported' | 'VideoLevelNotSupported' | 'VideoResolutionNotSupported' | 'VideoBitDepthNotSupported' | 'VideoFramerateNotSupported' | 'RefFramesNotSupported' | 'AnamorphicVideoNotSupported' | 'InterlacedVideoNotSupported' | 'AudioChannelsNotSupported' | 'AudioProfileNotSupported' | 'AudioSampleRateNotSupported' | 'AudioBitDepthNotSupported' | 'ContainerBitrateExceedsLimit' | 'VideoBitrateNotSupported' | 'AudioBitrateNotSupported' | 'UnknownVideoStreamInfo' | 'UnknownAudioStreamInfo' | 'DirectPlayError' | 'VideoRangeTypeNotSupported' | 'VideoCodecTagNotSupported';

export type TranscodeSeekInfo = 'Auto' | 'Bytes';

/**
 * Class holding information on a runnning transcode.
 */
export type TranscodingInfo = {
    /**
     * Gets or sets the thread count used for encoding.
     */
    AudioCodec?: string | null;
    /**
     * Gets or sets the thread count used for encoding.
     */
    VideoCodec?: string | null;
    /**
     * Gets or sets the thread count used for encoding.
     */
    Container?: string | null;
    /**
     * Gets or sets a value indicating whether the video is passed through.
     */
    IsVideoDirect?: boolean;
    /**
     * Gets or sets a value indicating whether the audio is passed through.
     */
    IsAudioDirect?: boolean;
    /**
     * Gets or sets the bitrate.
     */
    Bitrate?: number | null;
    /**
     * Gets or sets the framerate.
     */
    Framerate?: number | null;
    /**
     * Gets or sets the completion percentage.
     */
    CompletionPercentage?: number | null;
    /**
     * Gets or sets the video width.
     */
    Width?: number | null;
    /**
     * Gets or sets the video height.
     */
    Height?: number | null;
    /**
     * Gets or sets the audio channels.
     */
    AudioChannels?: number | null;
    /**
     * Gets or sets the hardware acceleration type.
     */
    HardwareAccelerationType?: 'none' | 'amf' | 'qsv' | 'nvenc' | 'v4l2m2m' | 'vaapi' | 'videotoolbox' | 'rkmpp';
    /**
     * Gets or sets the transcode reasons.
     */
    TranscodeReasons?: 'ContainerNotSupported' | 'VideoCodecNotSupported' | 'AudioCodecNotSupported' | 'SubtitleCodecNotSupported' | 'AudioIsExternal' | 'SecondaryAudioNotSupported' | 'VideoProfileNotSupported' | 'VideoLevelNotSupported' | 'VideoResolutionNotSupported' | 'VideoBitDepthNotSupported' | 'VideoFramerateNotSupported' | 'RefFramesNotSupported' | 'AnamorphicVideoNotSupported' | 'InterlacedVideoNotSupported' | 'AudioChannelsNotSupported' | 'AudioProfileNotSupported' | 'AudioSampleRateNotSupported' | 'AudioBitDepthNotSupported' | 'ContainerBitrateExceedsLimit' | 'VideoBitrateNotSupported' | 'AudioBitrateNotSupported' | 'UnknownVideoStreamInfo' | 'UnknownAudioStreamInfo' | 'DirectPlayError' | 'VideoRangeTypeNotSupported' | 'VideoCodecTagNotSupported';
};

/**
 * A class for transcoding profile information.
 * Note for client developers: Conditions defined in MediaBrowser.Model.Dlna.CodecProfile has higher priority and can override values defined here.
 */
export type TranscodingProfile = {
    /**
     * Gets or sets the container.
     */
    Container?: string;
    /**
     * Gets or sets the DLNA profile type.
     */
    Type?: 'Audio' | 'Video' | 'Photo' | 'Subtitle' | 'Lyric';
    /**
     * Gets or sets the video codec.
     */
    VideoCodec?: string;
    /**
     * Gets or sets the audio codec.
     */
    AudioCodec?: string;
    /**
     * Media streaming protocol.
     * Lowercase for backwards compatibility.
     */
    Protocol?: 'http' | 'hls';
    /**
     * Gets or sets a value indicating whether the content length should be estimated.
     */
    EstimateContentLength?: boolean;
    /**
     * Gets or sets a value indicating whether M2TS mode is enabled.
     */
    EnableMpegtsM2TsMode?: boolean;
    /**
     * Gets or sets the transcoding seek info mode.
     */
    TranscodeSeekInfo?: 'Auto' | 'Bytes';
    /**
     * Gets or sets a value indicating whether timestamps should be copied.
     */
    CopyTimestamps?: boolean;
    /**
     * Gets or sets the encoding context.
     */
    Context?: 'Streaming' | 'Static';
    /**
     * Gets or sets a value indicating whether subtitles are allowed in the manifest.
     */
    EnableSubtitlesInManifest?: boolean;
    /**
     * Gets or sets the maximum audio channels.
     */
    MaxAudioChannels?: string | null;
    /**
     * Gets or sets the minimum amount of segments.
     */
    MinSegments?: number;
    /**
     * Gets or sets the segment length.
     */
    SegmentLength?: number;
    /**
     * Gets or sets a value indicating whether breaking the video stream on non-keyframes is supported.
     */
    BreakOnNonKeyFrames?: boolean;
    /**
     * Gets or sets the profile conditions.
     */
    Conditions?: Array<ProfileCondition>;
    /**
     * Gets or sets a value indicating whether variable bitrate encoding is supported.
     */
    EnableAudioVbrEncoding?: boolean;
};

export type TransportStreamTimestamp = 'None' | 'Zero' | 'Valid';

/**
 * An entity representing the metadata for a group of trickplay tiles.
 */
export type TrickplayInfo = {
    /**
     * Gets or sets width of an individual thumbnail.
     */
    Width?: number;
    /**
     * Gets or sets height of an individual thumbnail.
     */
    Height?: number;
    /**
     * Gets or sets amount of thumbnails per row.
     */
    TileWidth?: number;
    /**
     * Gets or sets amount of thumbnails per column.
     */
    TileHeight?: number;
    /**
     * Gets or sets total amount of non-black thumbnails.
     */
    ThumbnailCount?: number;
    /**
     * Gets or sets interval in milliseconds between each trickplay thumbnail.
     */
    Interval?: number;
    /**
     * Gets or sets peak bandwith usage in bits per second.
     */
    Bandwidth?: number;
};

/**
 * Class TrickplayOptions.
 */
export type TrickplayOptions = {
    /**
     * Gets or sets a value indicating whether or not to use HW acceleration.
     */
    EnableHwAcceleration?: boolean;
    /**
     * Gets or sets a value indicating whether or not to use HW accelerated MJPEG encoding.
     */
    EnableHwEncoding?: boolean;
    /**
     * Gets or sets a value indicating whether to only extract key frames.
     * Significantly faster, but is not compatible with all decoders and/or video files.
     */
    EnableKeyFrameOnlyExtraction?: boolean;
    /**
     * Gets or sets the behavior used by trickplay provider on library scan/update.
     */
    ScanBehavior?: 'Blocking' | 'NonBlocking';
    /**
     * Gets or sets the process priority for the ffmpeg process.
     */
    ProcessPriority?: 'Normal' | 'Idle' | 'High' | 'RealTime' | 'BelowNormal' | 'AboveNormal';
    /**
     * Gets or sets the interval, in ms, between each new trickplay image.
     */
    Interval?: number;
    /**
     * Gets or sets the target width resolutions, in px, to generates preview images for.
     */
    WidthResolutions?: Array<number>;
    /**
     * Gets or sets number of tile images to allow in X dimension.
     */
    TileWidth?: number;
    /**
     * Gets or sets number of tile images to allow in Y dimension.
     */
    TileHeight?: number;
    /**
     * Gets or sets the ffmpeg output quality level.
     */
    Qscale?: number;
    /**
     * Gets or sets the jpeg quality to use for image tiles.
     */
    JpegQuality?: number;
    /**
     * Gets or sets the number of threads to be used by ffmpeg.
     */
    ProcessThreads?: number;
};

/**
 * Enum TrickplayScanBehavior.
 */
export type TrickplayScanBehavior = 'Blocking' | 'NonBlocking';

export type TunerChannelMapping = {
    Name?: string | null;
    ProviderChannelName?: string | null;
    ProviderChannelId?: string | null;
    Id?: string | null;
};

export type TunerHostInfo = {
    Id?: string | null;
    Url?: string | null;
    Type?: string | null;
    DeviceId?: string | null;
    FriendlyName?: string | null;
    ImportFavoritesOnly?: boolean;
    AllowHWTranscoding?: boolean;
    AllowFmp4TranscodingContainer?: boolean;
    AllowStreamSharing?: boolean;
    FallbackMaxStreamingBitrate?: number;
    EnableStreamLooping?: boolean;
    Source?: string | null;
    TunerCount?: number;
    UserAgent?: string | null;
    IgnoreDts?: boolean;
};

export type TypeOptions = {
    Type?: string | null;
    MetadataFetchers?: Array<string> | null;
    MetadataFetcherOrder?: Array<string> | null;
    ImageFetchers?: Array<string> | null;
    ImageFetcherOrder?: Array<string> | null;
    ImageOptions?: Array<ImageOption> | null;
};

/**
 * An enum representing an unrated item.
 */
export type UnratedItem = 'Movie' | 'Trailer' | 'Series' | 'Music' | 'Book' | 'LiveTvChannel' | 'LiveTvProgram' | 'ChannelContent' | 'Other';

/**
 * Update library options dto.
 */
export type UpdateLibraryOptionsDto = {
    /**
     * Gets or sets the library item id.
     */
    Id?: string;
    /**
     * Gets or sets library options.
     */
    LibraryOptions?: LibraryOptions | null;
};

/**
 * Update library options dto.
 */
export type UpdateMediaPathRequestDto = {
    /**
     * Gets or sets the library name.
     */
    Name: string;
    /**
     * Gets or sets library folder path information.
     */
    PathInfo: MediaPathInfo;
};

/**
 * Update existing playlist dto. Fields set to `null` will not be updated and keep their current values.
 */
export type UpdatePlaylistDto = {
    /**
     * Gets or sets the name of the new playlist.
     */
    Name?: string | null;
    /**
     * Gets or sets item ids of the playlist.
     */
    Ids?: Array<string> | null;
    /**
     * Gets or sets the playlist users.
     */
    Users?: Array<PlaylistUserPermissions> | null;
    /**
     * Gets or sets a value indicating whether the playlist is public.
     */
    IsPublic?: boolean | null;
};

/**
 * Update existing playlist user dto. Fields set to `null` will not be updated and keep their current values.
 */
export type UpdatePlaylistUserDto = {
    /**
     * Gets or sets a value indicating whether the user can edit the playlist.
     */
    CanEdit?: boolean | null;
};

/**
 * This is used by the api to get information about a item user data.
 */
export type UpdateUserItemDataDto = {
    /**
     * Gets or sets the rating.
     */
    Rating?: number | null;
    /**
     * Gets or sets the played percentage.
     */
    PlayedPercentage?: number | null;
    /**
     * Gets or sets the unplayed item count.
     */
    UnplayedItemCount?: number | null;
    /**
     * Gets or sets the playback position ticks.
     */
    PlaybackPositionTicks?: number | null;
    /**
     * Gets or sets the play count.
     */
    PlayCount?: number | null;
    /**
     * Gets or sets a value indicating whether this instance is favorite.
     */
    IsFavorite?: boolean | null;
    /**
     * Gets or sets a value indicating whether this MediaBrowser.Model.Dto.UpdateUserItemDataDto is likes.
     */
    Likes?: boolean | null;
    /**
     * Gets or sets the last played date.
     */
    LastPlayedDate?: string | null;
    /**
     * Gets or sets a value indicating whether this MediaBrowser.Model.Dto.UserItemDataDto is played.
     */
    Played?: boolean | null;
    /**
     * Gets or sets the key.
     */
    Key?: string | null;
    /**
     * Gets or sets the item identifier.
     */
    ItemId?: string | null;
};

/**
 * The update user password request body.
 */
export type UpdateUserPassword = {
    /**
     * Gets or sets the current sha1-hashed password.
     */
    CurrentPassword?: string | null;
    /**
     * Gets or sets the current plain text password.
     */
    CurrentPw?: string | null;
    /**
     * Gets or sets the new plain text password.
     */
    NewPw?: string | null;
    /**
     * Gets or sets a value indicating whether to reset the password.
     */
    ResetPassword?: boolean;
};

/**
 * Upload subtitles dto.
 */
export type UploadSubtitleDto = {
    /**
     * Gets or sets the subtitle language.
     */
    Language: string;
    /**
     * Gets or sets the subtitle format.
     */
    Format: string;
    /**
     * Gets or sets a value indicating whether the subtitle is forced.
     */
    IsForced: boolean;
    /**
     * Gets or sets a value indicating whether the subtitle is for hearing impaired.
     */
    IsHearingImpaired: boolean;
    /**
     * Gets or sets the subtitle data.
     */
    Data: string;
};

/**
 * Class UserConfiguration.
 */
export type UserConfiguration = {
    /**
     * Gets or sets the audio language preference.
     */
    AudioLanguagePreference?: string | null;
    /**
     * Gets or sets a value indicating whether [play default audio track].
     */
    PlayDefaultAudioTrack?: boolean;
    /**
     * Gets or sets the subtitle language preference.
     */
    SubtitleLanguagePreference?: string | null;
    DisplayMissingEpisodes?: boolean;
    GroupedFolders?: Array<string>;
    /**
     * An enum representing a subtitle playback mode.
     */
    SubtitleMode?: 'Default' | 'Always' | 'OnlyForced' | 'None' | 'Smart';
    DisplayCollectionsView?: boolean;
    EnableLocalPassword?: boolean;
    OrderedViews?: Array<string>;
    LatestItemsExcludes?: Array<string>;
    MyMediaExcludes?: Array<string>;
    HidePlayedInLatest?: boolean;
    RememberAudioSelections?: boolean;
    RememberSubtitleSelections?: boolean;
    EnableNextEpisodeAutoPlay?: boolean;
    /**
     * Gets or sets the id of the selected cast receiver.
     */
    CastReceiverId?: string | null;
};

/**
 * User data changed message.
 */
export type UserDataChangedMessage = {
    /**
     * Gets or sets the data.
     */
    Data?: UserDataChangeInfo | null;
    /**
     * Gets or sets the message id.
     */
    MessageId?: string;
    /**
     * The different kinds of messages that are used in the WebSocket api.
     */
    MessageType?: 'ForceKeepAlive' | 'GeneralCommand' | 'UserDataChanged' | 'Sessions' | 'Play' | 'SyncPlayCommand' | 'SyncPlayGroupUpdate' | 'Playstate' | 'RestartRequired' | 'ServerShuttingDown' | 'ServerRestarting' | 'LibraryChanged' | 'UserDeleted' | 'UserUpdated' | 'SeriesTimerCreated' | 'TimerCreated' | 'SeriesTimerCancelled' | 'TimerCancelled' | 'RefreshProgress' | 'ScheduledTaskEnded' | 'PackageInstallationCancelled' | 'PackageInstallationFailed' | 'PackageInstallationCompleted' | 'PackageInstalling' | 'PackageUninstalled' | 'ActivityLogEntry' | 'ScheduledTasksInfo' | 'ActivityLogEntryStart' | 'ActivityLogEntryStop' | 'SessionsStart' | 'SessionsStop' | 'ScheduledTasksInfoStart' | 'ScheduledTasksInfoStop' | 'KeepAlive';
};

/**
 * Class UserDataChangeInfo.
 */
export type UserDataChangeInfo = {
    /**
     * Gets or sets the user id.
     */
    UserId?: string;
    /**
     * Gets or sets the user data list.
     */
    UserDataList?: Array<UserItemDataDto>;
};

/**
 * User deleted message.
 */
export type UserDeletedMessage = {
    /**
     * Gets or sets the data.
     */
    Data?: string;
    /**
     * Gets or sets the message id.
     */
    MessageId?: string;
    /**
     * The different kinds of messages that are used in the WebSocket api.
     */
    MessageType?: 'ForceKeepAlive' | 'GeneralCommand' | 'UserDataChanged' | 'Sessions' | 'Play' | 'SyncPlayCommand' | 'SyncPlayGroupUpdate' | 'Playstate' | 'RestartRequired' | 'ServerShuttingDown' | 'ServerRestarting' | 'LibraryChanged' | 'UserDeleted' | 'UserUpdated' | 'SeriesTimerCreated' | 'TimerCreated' | 'SeriesTimerCancelled' | 'TimerCancelled' | 'RefreshProgress' | 'ScheduledTaskEnded' | 'PackageInstallationCancelled' | 'PackageInstallationFailed' | 'PackageInstallationCompleted' | 'PackageInstalling' | 'PackageUninstalled' | 'ActivityLogEntry' | 'ScheduledTasksInfo' | 'ActivityLogEntryStart' | 'ActivityLogEntryStop' | 'SessionsStart' | 'SessionsStop' | 'ScheduledTasksInfoStart' | 'ScheduledTasksInfoStop' | 'KeepAlive';
};

/**
 * Class UserDto.
 */
export type UserDto = {
    /**
     * Gets or sets the name.
     */
    Name?: string | null;
    /**
     * Gets or sets the server identifier.
     */
    ServerId?: string | null;
    /**
     * Gets or sets the name of the server.
     * This is not used by the server and is for client-side usage only.
     */
    ServerName?: string | null;
    /**
     * Gets or sets the id.
     */
    Id?: string;
    /**
     * Gets or sets the primary image tag.
     */
    PrimaryImageTag?: string | null;
    /**
     * Gets or sets a value indicating whether this instance has password.
     */
    HasPassword?: boolean;
    /**
     * Gets or sets a value indicating whether this instance has configured password.
     */
    HasConfiguredPassword?: boolean;
    /**
     * Gets or sets a value indicating whether this instance has configured easy password.
     * @deprecated
     */
    HasConfiguredEasyPassword?: boolean;
    /**
     * Gets or sets whether async login is enabled or not.
     */
    EnableAutoLogin?: boolean | null;
    /**
     * Gets or sets the last login date.
     */
    LastLoginDate?: string | null;
    /**
     * Gets or sets the last activity date.
     */
    LastActivityDate?: string | null;
    /**
     * Gets or sets the configuration.
     */
    Configuration?: UserConfiguration | null;
    /**
     * Gets or sets the policy.
     */
    Policy?: UserPolicy | null;
    /**
     * Gets or sets the primary image aspect ratio.
     */
    PrimaryImageAspectRatio?: number | null;
};

/**
 * Class UserItemDataDto.
 */
export type UserItemDataDto = {
    /**
     * Gets or sets the rating.
     */
    Rating?: number | null;
    /**
     * Gets or sets the played percentage.
     */
    PlayedPercentage?: number | null;
    /**
     * Gets or sets the unplayed item count.
     */
    UnplayedItemCount?: number | null;
    /**
     * Gets or sets the playback position ticks.
     */
    PlaybackPositionTicks?: number;
    /**
     * Gets or sets the play count.
     */
    PlayCount?: number;
    /**
     * Gets or sets a value indicating whether this instance is favorite.
     */
    IsFavorite?: boolean;
    /**
     * Gets or sets a value indicating whether this MediaBrowser.Model.Dto.UserItemDataDto is likes.
     */
    Likes?: boolean | null;
    /**
     * Gets or sets the last played date.
     */
    LastPlayedDate?: string | null;
    /**
     * Gets or sets a value indicating whether this MediaBrowser.Model.Dto.UserItemDataDto is played.
     */
    Played?: boolean;
    /**
     * Gets or sets the key.
     */
    Key?: string;
    /**
     * Gets or sets the item identifier.
     */
    ItemId?: string;
};

export type UserPolicy = {
    /**
     * Gets or sets a value indicating whether this instance is administrator.
     */
    IsAdministrator?: boolean;
    /**
     * Gets or sets a value indicating whether this instance is hidden.
     */
    IsHidden?: boolean;
    /**
     * Gets or sets a value indicating whether this instance can manage collections.
     */
    EnableCollectionManagement?: boolean;
    /**
     * Gets or sets a value indicating whether this instance can manage subtitles.
     */
    EnableSubtitleManagement?: boolean;
    /**
     * Gets or sets a value indicating whether this user can manage lyrics.
     */
    EnableLyricManagement?: boolean;
    /**
     * Gets or sets a value indicating whether this instance is disabled.
     */
    IsDisabled?: boolean;
    /**
     * Gets or sets the max parental rating.
     */
    MaxParentalRating?: number | null;
    BlockedTags?: Array<string> | null;
    AllowedTags?: Array<string> | null;
    EnableUserPreferenceAccess?: boolean;
    AccessSchedules?: Array<AccessSchedule> | null;
    BlockUnratedItems?: Array<UnratedItem> | null;
    EnableRemoteControlOfOtherUsers?: boolean;
    EnableSharedDeviceControl?: boolean;
    EnableRemoteAccess?: boolean;
    EnableLiveTvManagement?: boolean;
    EnableLiveTvAccess?: boolean;
    EnableMediaPlayback?: boolean;
    EnableAudioPlaybackTranscoding?: boolean;
    EnableVideoPlaybackTranscoding?: boolean;
    EnablePlaybackRemuxing?: boolean;
    ForceRemoteSourceTranscoding?: boolean;
    EnableContentDeletion?: boolean;
    EnableContentDeletionFromFolders?: Array<string> | null;
    EnableContentDownloading?: boolean;
    /**
     * Gets or sets a value indicating whether [enable synchronize].
     */
    EnableSyncTranscoding?: boolean;
    EnableMediaConversion?: boolean;
    EnabledDevices?: Array<string> | null;
    EnableAllDevices?: boolean;
    EnabledChannels?: Array<string> | null;
    EnableAllChannels?: boolean;
    EnabledFolders?: Array<string> | null;
    EnableAllFolders?: boolean;
    InvalidLoginAttemptCount?: number;
    LoginAttemptsBeforeLockout?: number;
    MaxActiveSessions?: number;
    EnablePublicSharing?: boolean;
    BlockedMediaFolders?: Array<string> | null;
    BlockedChannels?: Array<string> | null;
    RemoteClientBitrateLimit?: number;
    AuthenticationProviderId: string;
    PasswordResetProviderId: string;
    /**
     * Enum SyncPlayUserAccessType.
     */
    SyncPlayAccess?: 'CreateAndJoinGroups' | 'JoinGroups' | 'None';
};

/**
 * User updated message.
 */
export type UserUpdatedMessage = {
    /**
     * Gets or sets the data.
     */
    Data?: UserDto | null;
    /**
     * Gets or sets the message id.
     */
    MessageId?: string;
    /**
     * The different kinds of messages that are used in the WebSocket api.
     */
    MessageType?: 'ForceKeepAlive' | 'GeneralCommand' | 'UserDataChanged' | 'Sessions' | 'Play' | 'SyncPlayCommand' | 'SyncPlayGroupUpdate' | 'Playstate' | 'RestartRequired' | 'ServerShuttingDown' | 'ServerRestarting' | 'LibraryChanged' | 'UserDeleted' | 'UserUpdated' | 'SeriesTimerCreated' | 'TimerCreated' | 'SeriesTimerCancelled' | 'TimerCancelled' | 'RefreshProgress' | 'ScheduledTaskEnded' | 'PackageInstallationCancelled' | 'PackageInstallationFailed' | 'PackageInstallationCompleted' | 'PackageInstalling' | 'PackageUninstalled' | 'ActivityLogEntry' | 'ScheduledTasksInfo' | 'ActivityLogEntryStart' | 'ActivityLogEntryStop' | 'SessionsStart' | 'SessionsStop' | 'ScheduledTasksInfoStart' | 'ScheduledTasksInfoStop' | 'KeepAlive';
};

/**
 * Class UtcTimeResponse.
 */
export type UtcTimeResponse = {
    /**
     * Gets the UTC time when request has been received.
     */
    RequestReceptionTime?: string;
    /**
     * Gets the UTC time when response has been sent.
     */
    ResponseTransmissionTime?: string;
};

/**
 * Validate path object.
 */
export type ValidatePathDto = {
    /**
     * Gets or sets a value indicating whether validate if path is writable.
     */
    ValidateWritable?: boolean;
    /**
     * Gets or sets the path.
     */
    Path?: string | null;
    /**
     * Gets or sets is path file.
     */
    IsFile?: boolean | null;
};

/**
 * Defines the MediaBrowser.Model.Updates.VersionInfo class.
 */
export type VersionInfo = {
    /**
     * Gets or sets the version.
     */
    version?: string;
    /**
     * Gets the version as a System.Version.
     */
    readonly VersionNumber?: string;
    /**
     * Gets or sets the changelog for this version.
     */
    changelog?: string | null;
    /**
     * Gets or sets the ABI that this version was built against.
     */
    targetAbi?: string | null;
    /**
     * Gets or sets the source URL.
     */
    sourceUrl?: string | null;
    /**
     * Gets or sets a checksum for the binary.
     */
    checksum?: string | null;
    /**
     * Gets or sets a timestamp of when the binary was built.
     */
    timestamp?: string | null;
    /**
     * Gets or sets the repository name.
     */
    repositoryName?: string;
    /**
     * Gets or sets the repository url.
     */
    repositoryUrl?: string;
};

export type Video3dFormat = 'HalfSideBySide' | 'FullSideBySide' | 'FullTopAndBottom' | 'HalfTopAndBottom' | 'MVC';

/**
 * An enum representing video ranges.
 */
export type VideoRange = 'Unknown' | 'SDR' | 'HDR';

/**
 * An enum representing types of video ranges.
 */
export type VideoRangeType = 'Unknown' | 'SDR' | 'HDR10' | 'HLG' | 'DOVI' | 'DOVIWithHDR10' | 'DOVIWithHLG' | 'DOVIWithSDR' | 'HDR10Plus';

/**
 * Enum VideoType.
 */
export type VideoType = 'VideoFile' | 'Iso' | 'Dvd' | 'BluRay';

/**
 * Used to hold information about a user's list of configured virtual folders.
 */
export type VirtualFolderInfo = {
    /**
     * Gets or sets the name.
     */
    Name?: string | null;
    /**
     * Gets or sets the locations.
     */
    Locations?: Array<string> | null;
    /**
     * Gets or sets the type of the collection.
     */
    CollectionType?: 'movies' | 'tvshows' | 'music' | 'musicvideos' | 'homevideos' | 'boxsets' | 'books' | 'mixed';
    LibraryOptions?: LibraryOptions | null;
    /**
     * Gets or sets the item identifier.
     */
    ItemId?: string | null;
    /**
     * Gets or sets the primary image item identifier.
     */
    PrimaryImageItemId?: string | null;
    RefreshProgress?: number | null;
    RefreshStatus?: string | null;
};

/**
 * Provides the MAC address and port for wake-on-LAN functionality.
 */
export type WakeOnLanInfo = {
    /**
     * Gets the MAC address of the device.
     */
    MacAddress?: string | null;
    /**
     * Gets or sets the wake-on-LAN port.
     */
    Port?: number;
};

/**
 * Represents the possible websocket types
 */
export type WebSocketMessage = InboundWebSocketMessage | OutboundWebSocketMessage;

export type XbmcMetadataOptions = {
    UserId?: string | null;
    ReleaseDateFormat?: string;
    SaveImagePathsInNfo?: boolean;
    EnablePathSubstitution?: boolean;
    EnableExtraThumbsDuplication?: boolean;
};

export type GetLogEntriesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        startIndex?: number;
        /**
         * Optional. The maximum number of records to return.
         */
        limit?: number;
        /**
         * Optional. The minimum date. Format = ISO.
         */
        minDate?: string;
        /**
         * Optional. Filter log entries if it has user id, or not.
         */
        hasUserId?: boolean;
    };
    url: '/System/ActivityLog/Entries';
};

export type GetLogEntriesErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetLogEntriesResponses = {
    /**
     * Activity log returned.
     */
    200: ActivityLogEntryQueryResult;
};

export type GetLogEntriesResponse = GetLogEntriesResponses[keyof GetLogEntriesResponses];

export type GetKeysData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Auth/Keys';
};

export type GetKeysErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetKeysResponses = {
    /**
     * Api keys retrieved.
     */
    200: AuthenticationInfoQueryResult;
};

export type GetKeysResponse = GetKeysResponses[keyof GetKeysResponses];

export type CreateKeyData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Name of the app using the authentication key.
         */
        app: string;
    };
    url: '/Auth/Keys';
};

export type CreateKeyErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type CreateKeyResponses = {
    /**
     * Api key created.
     */
    204: void;
};

export type CreateKeyResponse = CreateKeyResponses[keyof CreateKeyResponses];

export type RevokeKeyData = {
    body?: never;
    path: {
        /**
         * The access token to delete.
         */
        key: string;
    };
    query?: never;
    url: '/Auth/Keys/{key}';
};

export type RevokeKeyErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type RevokeKeyResponses = {
    /**
     * Api key deleted.
     */
    204: void;
};

export type RevokeKeyResponse = RevokeKeyResponses[keyof RevokeKeyResponses];

export type GetArtistsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional filter by minimum community rating.
         */
        minCommunityRating?: number;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        startIndex?: number;
        /**
         * Optional. The maximum number of records to return.
         */
        limit?: number;
        /**
         * Optional. Search term.
         */
        searchTerm?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root.
         */
        parentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output.
         */
        fields?: Array<ItemFields>;
        /**
         * Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
         */
        excludeItemTypes?: Array<BaseItemKind>;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
         */
        includeItemTypes?: Array<BaseItemKind>;
        /**
         * Optional. Specify additional filters to apply.
         */
        filters?: Array<ItemFilter>;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        isFavorite?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        mediaTypes?: Array<MediaType>;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
         */
        genres?: Array<string>;
        /**
         * Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
         */
        genreIds?: Array<string>;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
         */
        officialRatings?: Array<string>;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
         */
        tags?: Array<string>;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
         */
        years?: Array<number>;
        /**
         * Optional, include user data.
         */
        enableUserData?: boolean;
        /**
         * Optional, the max number of images to return, per image type.
         */
        imageTypeLimit?: number;
        /**
         * Optional. The image types to include in the output.
         */
        enableImageTypes?: Array<ImageType>;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person ids.
         */
        personIds?: Array<string>;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
         */
        personTypes?: Array<string>;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
         */
        studios?: Array<string>;
        /**
         * Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
         */
        studioIds?: Array<string>;
        /**
         * User id.
         */
        userId?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        nameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        nameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        nameLessThan?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimited.
         */
        sortBy?: Array<ItemSortBy>;
        /**
         * Sort Order - Ascending,Descending.
         */
        sortOrder?: Array<SortOrder>;
        /**
         * Optional, include image information in output.
         */
        enableImages?: boolean;
        /**
         * Total record count.
         */
        enableTotalRecordCount?: boolean;
    };
    url: '/Artists';
};

export type GetArtistsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetArtistsResponses = {
    /**
     * Artists returned.
     */
    200: BaseItemDtoQueryResult;
};

export type GetArtistsResponse = GetArtistsResponses[keyof GetArtistsResponses];

export type GetArtistByNameData = {
    body?: never;
    path: {
        /**
         * Studio name.
         */
        name: string;
    };
    query?: {
        /**
         * Optional. Filter by user id, and attach user data.
         */
        userId?: string;
    };
    url: '/Artists/{name}';
};

export type GetArtistByNameErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetArtistByNameResponses = {
    /**
     * Artist returned.
     */
    200: BaseItemDto;
};

export type GetArtistByNameResponse = GetArtistByNameResponses[keyof GetArtistByNameResponses];

export type GetAlbumArtistsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional filter by minimum community rating.
         */
        minCommunityRating?: number;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        startIndex?: number;
        /**
         * Optional. The maximum number of records to return.
         */
        limit?: number;
        /**
         * Optional. Search term.
         */
        searchTerm?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root.
         */
        parentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output.
         */
        fields?: Array<ItemFields>;
        /**
         * Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
         */
        excludeItemTypes?: Array<BaseItemKind>;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
         */
        includeItemTypes?: Array<BaseItemKind>;
        /**
         * Optional. Specify additional filters to apply.
         */
        filters?: Array<ItemFilter>;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        isFavorite?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        mediaTypes?: Array<MediaType>;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
         */
        genres?: Array<string>;
        /**
         * Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
         */
        genreIds?: Array<string>;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
         */
        officialRatings?: Array<string>;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
         */
        tags?: Array<string>;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
         */
        years?: Array<number>;
        /**
         * Optional, include user data.
         */
        enableUserData?: boolean;
        /**
         * Optional, the max number of images to return, per image type.
         */
        imageTypeLimit?: number;
        /**
         * Optional. The image types to include in the output.
         */
        enableImageTypes?: Array<ImageType>;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person ids.
         */
        personIds?: Array<string>;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
         */
        personTypes?: Array<string>;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
         */
        studios?: Array<string>;
        /**
         * Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
         */
        studioIds?: Array<string>;
        /**
         * User id.
         */
        userId?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        nameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        nameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        nameLessThan?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimited.
         */
        sortBy?: Array<ItemSortBy>;
        /**
         * Sort Order - Ascending,Descending.
         */
        sortOrder?: Array<SortOrder>;
        /**
         * Optional, include image information in output.
         */
        enableImages?: boolean;
        /**
         * Total record count.
         */
        enableTotalRecordCount?: boolean;
    };
    url: '/Artists/AlbumArtists';
};

export type GetAlbumArtistsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetAlbumArtistsResponses = {
    /**
     * Album artists returned.
     */
    200: BaseItemDtoQueryResult;
};

export type GetAlbumArtistsResponse = GetAlbumArtistsResponses[keyof GetAlbumArtistsResponses];

export type GetAudioStreamData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
    };
    query?: {
        /**
         * The audio container.
         */
        container?: string;
        /**
         * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         */
        static?: boolean;
        /**
         * The streaming parameters.
         */
        params?: string;
        /**
         * The tag.
         */
        tag?: string;
        /**
         * Optional. The dlna device profile id to utilize.
         * @deprecated
         */
        deviceProfileId?: string;
        /**
         * The play session id.
         */
        playSessionId?: string;
        /**
         * The segment container.
         */
        segmentContainer?: string;
        /**
         * The segment length.
         */
        segmentLength?: number;
        /**
         * The minimum number of segments.
         */
        minSegments?: number;
        /**
         * The media version id, if playing an alternate version.
         */
        mediaSourceId?: string;
        /**
         * The device id of the client requesting. Used to stop encoding processes when needed.
         */
        deviceId?: string;
        /**
         * Optional. Specify an audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension.
         */
        audioCodec?: string;
        /**
         * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         */
        enableAutoStreamCopy?: boolean;
        /**
         * Whether or not to allow copying of the video stream url.
         */
        allowVideoStreamCopy?: boolean;
        /**
         * Whether or not to allow copying of the audio stream url.
         */
        allowAudioStreamCopy?: boolean;
        /**
         * Optional. Whether to break on non key frames.
         */
        breakOnNonKeyFrames?: boolean;
        /**
         * Optional. Specify a specific audio sample rate, e.g. 44100.
         */
        audioSampleRate?: number;
        /**
         * Optional. The maximum audio bit depth.
         */
        maxAudioBitDepth?: number;
        /**
         * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         */
        audioBitRate?: number;
        /**
         * Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         */
        audioChannels?: number;
        /**
         * Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         */
        maxAudioChannels?: number;
        /**
         * Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         */
        profile?: string;
        /**
         * Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         */
        level?: string;
        /**
         * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         */
        framerate?: number;
        /**
         * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         */
        maxFramerate?: number;
        /**
         * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         */
        copyTimestamps?: boolean;
        /**
         * Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
         */
        startTimeTicks?: number;
        /**
         * Optional. The fixed horizontal resolution of the encoded video.
         */
        width?: number;
        /**
         * Optional. The fixed vertical resolution of the encoded video.
         */
        height?: number;
        /**
         * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         */
        videoBitRate?: number;
        /**
         * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         */
        subtitleStreamIndex?: number;
        /**
         * Optional. Specify the subtitle delivery method.
         */
        subtitleMethod?: 'Encode' | 'Embed' | 'External' | 'Hls' | 'Drop';
        /**
         * Optional.
         */
        maxRefFrames?: number;
        /**
         * Optional. The maximum video bit depth.
         */
        maxVideoBitDepth?: number;
        /**
         * Optional. Whether to require avc.
         */
        requireAvc?: boolean;
        /**
         * Optional. Whether to deinterlace the video.
         */
        deInterlace?: boolean;
        /**
         * Optional. Whether to require a non anamorphic stream.
         */
        requireNonAnamorphic?: boolean;
        /**
         * Optional. The maximum number of audio channels to transcode.
         */
        transcodingMaxAudioChannels?: number;
        /**
         * Optional. The limit of how many cpu cores to use.
         */
        cpuCoreLimit?: number;
        /**
         * The live stream id.
         */
        liveStreamId?: string;
        /**
         * Optional. Whether to enable the MpegtsM2Ts mode.
         */
        enableMpegtsM2TsMode?: boolean;
        /**
         * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension.
         */
        videoCodec?: string;
        /**
         * Optional. Specify a subtitle codec to encode to.
         */
        subtitleCodec?: string;
        /**
         * Optional. The transcoding reason.
         */
        transcodeReasons?: string;
        /**
         * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         */
        audioStreamIndex?: number;
        /**
         * Optional. The index of the video stream to use. If omitted the first video stream will be used.
         */
        videoStreamIndex?: number;
        /**
         * Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         */
        context?: 'Streaming' | 'Static';
        /**
         * Optional. The streaming options.
         */
        streamOptions?: {
            [key: string]: string | null;
        };
        /**
         * Optional. Whether to enable Audio Encoding.
         */
        enableAudioVbrEncoding?: boolean;
    };
    url: '/Audio/{itemId}/stream';
};

export type GetAudioStreamResponses = {
    /**
     * Audio stream returned.
     */
    200: Blob | File;
};

export type GetAudioStreamResponse = GetAudioStreamResponses[keyof GetAudioStreamResponses];

export type HeadAudioStreamData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
    };
    query?: {
        /**
         * The audio container.
         */
        container?: string;
        /**
         * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         */
        static?: boolean;
        /**
         * The streaming parameters.
         */
        params?: string;
        /**
         * The tag.
         */
        tag?: string;
        /**
         * Optional. The dlna device profile id to utilize.
         * @deprecated
         */
        deviceProfileId?: string;
        /**
         * The play session id.
         */
        playSessionId?: string;
        /**
         * The segment container.
         */
        segmentContainer?: string;
        /**
         * The segment length.
         */
        segmentLength?: number;
        /**
         * The minimum number of segments.
         */
        minSegments?: number;
        /**
         * The media version id, if playing an alternate version.
         */
        mediaSourceId?: string;
        /**
         * The device id of the client requesting. Used to stop encoding processes when needed.
         */
        deviceId?: string;
        /**
         * Optional. Specify an audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension.
         */
        audioCodec?: string;
        /**
         * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         */
        enableAutoStreamCopy?: boolean;
        /**
         * Whether or not to allow copying of the video stream url.
         */
        allowVideoStreamCopy?: boolean;
        /**
         * Whether or not to allow copying of the audio stream url.
         */
        allowAudioStreamCopy?: boolean;
        /**
         * Optional. Whether to break on non key frames.
         */
        breakOnNonKeyFrames?: boolean;
        /**
         * Optional. Specify a specific audio sample rate, e.g. 44100.
         */
        audioSampleRate?: number;
        /**
         * Optional. The maximum audio bit depth.
         */
        maxAudioBitDepth?: number;
        /**
         * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         */
        audioBitRate?: number;
        /**
         * Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         */
        audioChannels?: number;
        /**
         * Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         */
        maxAudioChannels?: number;
        /**
         * Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         */
        profile?: string;
        /**
         * Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         */
        level?: string;
        /**
         * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         */
        framerate?: number;
        /**
         * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         */
        maxFramerate?: number;
        /**
         * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         */
        copyTimestamps?: boolean;
        /**
         * Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
         */
        startTimeTicks?: number;
        /**
         * Optional. The fixed horizontal resolution of the encoded video.
         */
        width?: number;
        /**
         * Optional. The fixed vertical resolution of the encoded video.
         */
        height?: number;
        /**
         * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         */
        videoBitRate?: number;
        /**
         * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         */
        subtitleStreamIndex?: number;
        /**
         * Optional. Specify the subtitle delivery method.
         */
        subtitleMethod?: 'Encode' | 'Embed' | 'External' | 'Hls' | 'Drop';
        /**
         * Optional.
         */
        maxRefFrames?: number;
        /**
         * Optional. The maximum video bit depth.
         */
        maxVideoBitDepth?: number;
        /**
         * Optional. Whether to require avc.
         */
        requireAvc?: boolean;
        /**
         * Optional. Whether to deinterlace the video.
         */
        deInterlace?: boolean;
        /**
         * Optional. Whether to require a non anamorphic stream.
         */
        requireNonAnamorphic?: boolean;
        /**
         * Optional. The maximum number of audio channels to transcode.
         */
        transcodingMaxAudioChannels?: number;
        /**
         * Optional. The limit of how many cpu cores to use.
         */
        cpuCoreLimit?: number;
        /**
         * The live stream id.
         */
        liveStreamId?: string;
        /**
         * Optional. Whether to enable the MpegtsM2Ts mode.
         */
        enableMpegtsM2TsMode?: boolean;
        /**
         * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension.
         */
        videoCodec?: string;
        /**
         * Optional. Specify a subtitle codec to encode to.
         */
        subtitleCodec?: string;
        /**
         * Optional. The transcoding reason.
         */
        transcodeReasons?: string;
        /**
         * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         */
        audioStreamIndex?: number;
        /**
         * Optional. The index of the video stream to use. If omitted the first video stream will be used.
         */
        videoStreamIndex?: number;
        /**
         * Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         */
        context?: 'Streaming' | 'Static';
        /**
         * Optional. The streaming options.
         */
        streamOptions?: {
            [key: string]: string | null;
        };
        /**
         * Optional. Whether to enable Audio Encoding.
         */
        enableAudioVbrEncoding?: boolean;
    };
    url: '/Audio/{itemId}/stream';
};

export type HeadAudioStreamResponses = {
    /**
     * Audio stream returned.
     */
    200: Blob | File;
};

export type HeadAudioStreamResponse = HeadAudioStreamResponses[keyof HeadAudioStreamResponses];

export type GetAudioStreamByContainerData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
        /**
         * The audio container.
         */
        container: string;
    };
    query?: {
        /**
         * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         */
        static?: boolean;
        /**
         * The streaming parameters.
         */
        params?: string;
        /**
         * The tag.
         */
        tag?: string;
        /**
         * Optional. The dlna device profile id to utilize.
         * @deprecated
         */
        deviceProfileId?: string;
        /**
         * The play session id.
         */
        playSessionId?: string;
        /**
         * The segment container.
         */
        segmentContainer?: string;
        /**
         * The segment length.
         */
        segmentLength?: number;
        /**
         * The minimum number of segments.
         */
        minSegments?: number;
        /**
         * The media version id, if playing an alternate version.
         */
        mediaSourceId?: string;
        /**
         * The device id of the client requesting. Used to stop encoding processes when needed.
         */
        deviceId?: string;
        /**
         * Optional. Specify an audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension.
         */
        audioCodec?: string;
        /**
         * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         */
        enableAutoStreamCopy?: boolean;
        /**
         * Whether or not to allow copying of the video stream url.
         */
        allowVideoStreamCopy?: boolean;
        /**
         * Whether or not to allow copying of the audio stream url.
         */
        allowAudioStreamCopy?: boolean;
        /**
         * Optional. Whether to break on non key frames.
         */
        breakOnNonKeyFrames?: boolean;
        /**
         * Optional. Specify a specific audio sample rate, e.g. 44100.
         */
        audioSampleRate?: number;
        /**
         * Optional. The maximum audio bit depth.
         */
        maxAudioBitDepth?: number;
        /**
         * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         */
        audioBitRate?: number;
        /**
         * Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         */
        audioChannels?: number;
        /**
         * Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         */
        maxAudioChannels?: number;
        /**
         * Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         */
        profile?: string;
        /**
         * Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         */
        level?: string;
        /**
         * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         */
        framerate?: number;
        /**
         * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         */
        maxFramerate?: number;
        /**
         * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         */
        copyTimestamps?: boolean;
        /**
         * Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
         */
        startTimeTicks?: number;
        /**
         * Optional. The fixed horizontal resolution of the encoded video.
         */
        width?: number;
        /**
         * Optional. The fixed vertical resolution of the encoded video.
         */
        height?: number;
        /**
         * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         */
        videoBitRate?: number;
        /**
         * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         */
        subtitleStreamIndex?: number;
        /**
         * Optional. Specify the subtitle delivery method.
         */
        subtitleMethod?: 'Encode' | 'Embed' | 'External' | 'Hls' | 'Drop';
        /**
         * Optional.
         */
        maxRefFrames?: number;
        /**
         * Optional. The maximum video bit depth.
         */
        maxVideoBitDepth?: number;
        /**
         * Optional. Whether to require avc.
         */
        requireAvc?: boolean;
        /**
         * Optional. Whether to deinterlace the video.
         */
        deInterlace?: boolean;
        /**
         * Optional. Whether to require a non anamporphic stream.
         */
        requireNonAnamorphic?: boolean;
        /**
         * Optional. The maximum number of audio channels to transcode.
         */
        transcodingMaxAudioChannels?: number;
        /**
         * Optional. The limit of how many cpu cores to use.
         */
        cpuCoreLimit?: number;
        /**
         * The live stream id.
         */
        liveStreamId?: string;
        /**
         * Optional. Whether to enable the MpegtsM2Ts mode.
         */
        enableMpegtsM2TsMode?: boolean;
        /**
         * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension.
         */
        videoCodec?: string;
        /**
         * Optional. Specify a subtitle codec to encode to.
         */
        subtitleCodec?: string;
        /**
         * Optional. The transcoding reason.
         */
        transcodeReasons?: string;
        /**
         * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         */
        audioStreamIndex?: number;
        /**
         * Optional. The index of the video stream to use. If omitted the first video stream will be used.
         */
        videoStreamIndex?: number;
        /**
         * Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         */
        context?: 'Streaming' | 'Static';
        /**
         * Optional. The streaming options.
         */
        streamOptions?: {
            [key: string]: string | null;
        };
        /**
         * Optional. Whether to enable Audio Encoding.
         */
        enableAudioVbrEncoding?: boolean;
    };
    url: '/Audio/{itemId}/stream.{container}';
};

export type GetAudioStreamByContainerResponses = {
    /**
     * Audio stream returned.
     */
    200: Blob | File;
};

export type GetAudioStreamByContainerResponse = GetAudioStreamByContainerResponses[keyof GetAudioStreamByContainerResponses];

export type HeadAudioStreamByContainerData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
        /**
         * The audio container.
         */
        container: string;
    };
    query?: {
        /**
         * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         */
        static?: boolean;
        /**
         * The streaming parameters.
         */
        params?: string;
        /**
         * The tag.
         */
        tag?: string;
        /**
         * Optional. The dlna device profile id to utilize.
         * @deprecated
         */
        deviceProfileId?: string;
        /**
         * The play session id.
         */
        playSessionId?: string;
        /**
         * The segment container.
         */
        segmentContainer?: string;
        /**
         * The segment length.
         */
        segmentLength?: number;
        /**
         * The minimum number of segments.
         */
        minSegments?: number;
        /**
         * The media version id, if playing an alternate version.
         */
        mediaSourceId?: string;
        /**
         * The device id of the client requesting. Used to stop encoding processes when needed.
         */
        deviceId?: string;
        /**
         * Optional. Specify an audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension.
         */
        audioCodec?: string;
        /**
         * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         */
        enableAutoStreamCopy?: boolean;
        /**
         * Whether or not to allow copying of the video stream url.
         */
        allowVideoStreamCopy?: boolean;
        /**
         * Whether or not to allow copying of the audio stream url.
         */
        allowAudioStreamCopy?: boolean;
        /**
         * Optional. Whether to break on non key frames.
         */
        breakOnNonKeyFrames?: boolean;
        /**
         * Optional. Specify a specific audio sample rate, e.g. 44100.
         */
        audioSampleRate?: number;
        /**
         * Optional. The maximum audio bit depth.
         */
        maxAudioBitDepth?: number;
        /**
         * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         */
        audioBitRate?: number;
        /**
         * Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         */
        audioChannels?: number;
        /**
         * Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         */
        maxAudioChannels?: number;
        /**
         * Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         */
        profile?: string;
        /**
         * Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         */
        level?: string;
        /**
         * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         */
        framerate?: number;
        /**
         * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         */
        maxFramerate?: number;
        /**
         * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         */
        copyTimestamps?: boolean;
        /**
         * Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
         */
        startTimeTicks?: number;
        /**
         * Optional. The fixed horizontal resolution of the encoded video.
         */
        width?: number;
        /**
         * Optional. The fixed vertical resolution of the encoded video.
         */
        height?: number;
        /**
         * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         */
        videoBitRate?: number;
        /**
         * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         */
        subtitleStreamIndex?: number;
        /**
         * Optional. Specify the subtitle delivery method.
         */
        subtitleMethod?: 'Encode' | 'Embed' | 'External' | 'Hls' | 'Drop';
        /**
         * Optional.
         */
        maxRefFrames?: number;
        /**
         * Optional. The maximum video bit depth.
         */
        maxVideoBitDepth?: number;
        /**
         * Optional. Whether to require avc.
         */
        requireAvc?: boolean;
        /**
         * Optional. Whether to deinterlace the video.
         */
        deInterlace?: boolean;
        /**
         * Optional. Whether to require a non anamporphic stream.
         */
        requireNonAnamorphic?: boolean;
        /**
         * Optional. The maximum number of audio channels to transcode.
         */
        transcodingMaxAudioChannels?: number;
        /**
         * Optional. The limit of how many cpu cores to use.
         */
        cpuCoreLimit?: number;
        /**
         * The live stream id.
         */
        liveStreamId?: string;
        /**
         * Optional. Whether to enable the MpegtsM2Ts mode.
         */
        enableMpegtsM2TsMode?: boolean;
        /**
         * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension.
         */
        videoCodec?: string;
        /**
         * Optional. Specify a subtitle codec to encode to.
         */
        subtitleCodec?: string;
        /**
         * Optional. The transcoding reason.
         */
        transcodeReasons?: string;
        /**
         * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         */
        audioStreamIndex?: number;
        /**
         * Optional. The index of the video stream to use. If omitted the first video stream will be used.
         */
        videoStreamIndex?: number;
        /**
         * Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         */
        context?: 'Streaming' | 'Static';
        /**
         * Optional. The streaming options.
         */
        streamOptions?: {
            [key: string]: string | null;
        };
        /**
         * Optional. Whether to enable Audio Encoding.
         */
        enableAudioVbrEncoding?: boolean;
    };
    url: '/Audio/{itemId}/stream.{container}';
};

export type HeadAudioStreamByContainerResponses = {
    /**
     * Audio stream returned.
     */
    200: Blob | File;
};

export type HeadAudioStreamByContainerResponse = HeadAudioStreamByContainerResponses[keyof HeadAudioStreamByContainerResponses];

export type GetBrandingOptionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Branding/Configuration';
};

export type GetBrandingOptionsResponses = {
    /**
     * Branding configuration returned.
     */
    200: BrandingOptions;
};

export type GetBrandingOptionsResponse = GetBrandingOptionsResponses[keyof GetBrandingOptionsResponses];

export type GetBrandingCssData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Branding/Css';
};

export type GetBrandingCssResponses = {
    /**
     * Branding css returned.
     */
    200: string;
    /**
     * No branding css configured.
     */
    204: void;
};

export type GetBrandingCssResponse = GetBrandingCssResponses[keyof GetBrandingCssResponses];

export type GetBrandingCss2Data = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Branding/Css.css';
};

export type GetBrandingCss2Responses = {
    /**
     * Branding css returned.
     */
    200: string;
    /**
     * No branding css configured.
     */
    204: void;
};

export type GetBrandingCss2Response = GetBrandingCss2Responses[keyof GetBrandingCss2Responses];

export type GetChannelsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * User Id to filter by. Use System.Guid.Empty to not filter by user.
         */
        userId?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        startIndex?: number;
        /**
         * Optional. The maximum number of records to return.
         */
        limit?: number;
        /**
         * Optional. Filter by channels that support getting latest items.
         */
        supportsLatestItems?: boolean;
        /**
         * Optional. Filter by channels that support media deletion.
         */
        supportsMediaDeletion?: boolean;
        /**
         * Optional. Filter by channels that are favorite.
         */
        isFavorite?: boolean;
    };
    url: '/Channels';
};

export type GetChannelsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetChannelsResponses = {
    /**
     * Channels returned.
     */
    200: BaseItemDtoQueryResult;
};

export type GetChannelsResponse = GetChannelsResponses[keyof GetChannelsResponses];

export type GetChannelFeaturesData = {
    body?: never;
    path: {
        /**
         * Channel id.
         */
        channelId: string;
    };
    query?: never;
    url: '/Channels/{channelId}/Features';
};

export type GetChannelFeaturesErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetChannelFeaturesResponses = {
    /**
     * Channel features returned.
     */
    200: ChannelFeatures;
};

export type GetChannelFeaturesResponse = GetChannelFeaturesResponses[keyof GetChannelFeaturesResponses];

export type GetChannelItemsData = {
    body?: never;
    path: {
        /**
         * Channel Id.
         */
        channelId: string;
    };
    query?: {
        /**
         * Optional. Folder Id.
         */
        folderId?: string;
        /**
         * Optional. User Id.
         */
        userId?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        startIndex?: number;
        /**
         * Optional. The maximum number of records to return.
         */
        limit?: number;
        /**
         * Optional. Sort Order - Ascending,Descending.
         */
        sortOrder?: Array<SortOrder>;
        /**
         * Optional. Specify additional filters to apply.
         */
        filters?: Array<ItemFilter>;
        /**
         * Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         */
        sortBy?: Array<ItemSortBy>;
        /**
         * Optional. Specify additional fields of information to return in the output.
         */
        fields?: Array<ItemFields>;
    };
    url: '/Channels/{channelId}/Items';
};

export type GetChannelItemsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetChannelItemsResponses = {
    /**
     * Channel items returned.
     */
    200: BaseItemDtoQueryResult;
};

export type GetChannelItemsResponse = GetChannelItemsResponses[keyof GetChannelItemsResponses];

export type GetAllChannelFeaturesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Channels/Features';
};

export type GetAllChannelFeaturesErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetAllChannelFeaturesResponses = {
    /**
     * All channel features returned.
     */
    200: Array<ChannelFeatures>;
};

export type GetAllChannelFeaturesResponse = GetAllChannelFeaturesResponses[keyof GetAllChannelFeaturesResponses];

export type GetLatestChannelItemsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional. User Id.
         */
        userId?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        startIndex?: number;
        /**
         * Optional. The maximum number of records to return.
         */
        limit?: number;
        /**
         * Optional. Specify additional filters to apply.
         */
        filters?: Array<ItemFilter>;
        /**
         * Optional. Specify additional fields of information to return in the output.
         */
        fields?: Array<ItemFields>;
        /**
         * Optional. Specify one or more channel id's, comma delimited.
         */
        channelIds?: Array<string>;
    };
    url: '/Channels/Items/Latest';
};

export type GetLatestChannelItemsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetLatestChannelItemsResponses = {
    /**
     * Latest channel items returned.
     */
    200: BaseItemDtoQueryResult;
};

export type GetLatestChannelItemsResponse = GetLatestChannelItemsResponses[keyof GetLatestChannelItemsResponses];

export type LogFileData = {
    body?: Blob | File;
    path?: never;
    query?: never;
    url: '/ClientLog/Document';
};

export type LogFileErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Event logging disabled.
     */
    403: ProblemDetails;
    /**
     * Upload size too large.
     */
    413: ProblemDetails;
};

export type LogFileError = LogFileErrors[keyof LogFileErrors];

export type LogFileResponses = {
    /**
     * Document saved.
     */
    200: ClientLogDocumentResponseDto;
};

export type LogFileResponse = LogFileResponses[keyof LogFileResponses];

export type CreateCollectionData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The name of the collection.
         */
        name?: string;
        /**
         * Item Ids to add to the collection.
         */
        ids?: Array<string>;
        /**
         * Optional. Create the collection within a specific folder.
         */
        parentId?: string;
        /**
         * Whether or not to lock the new collection.
         */
        isLocked?: boolean;
    };
    url: '/Collections';
};

export type CreateCollectionErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type CreateCollectionResponses = {
    /**
     * Collection created.
     */
    200: CollectionCreationResult;
};

export type CreateCollectionResponse = CreateCollectionResponses[keyof CreateCollectionResponses];

export type RemoveFromCollectionData = {
    body?: never;
    path: {
        /**
         * The collection id.
         */
        collectionId: string;
    };
    query: {
        /**
         * Item ids, comma delimited.
         */
        ids: Array<string>;
    };
    url: '/Collections/{collectionId}/Items';
};

export type RemoveFromCollectionErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type RemoveFromCollectionResponses = {
    /**
     * Items removed from collection.
     */
    204: void;
};

export type RemoveFromCollectionResponse = RemoveFromCollectionResponses[keyof RemoveFromCollectionResponses];

export type AddToCollectionData = {
    body?: never;
    path: {
        /**
         * The collection id.
         */
        collectionId: string;
    };
    query: {
        /**
         * Item ids, comma delimited.
         */
        ids: Array<string>;
    };
    url: '/Collections/{collectionId}/Items';
};

export type AddToCollectionErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type AddToCollectionResponses = {
    /**
     * Items added to collection.
     */
    204: void;
};

export type AddToCollectionResponse = AddToCollectionResponses[keyof AddToCollectionResponses];

export type GetConfigurationData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/System/Configuration';
};

export type GetConfigurationErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetConfigurationResponses = {
    /**
     * Application configuration returned.
     */
    200: ServerConfiguration;
};

export type GetConfigurationResponse = GetConfigurationResponses[keyof GetConfigurationResponses];

export type UpdateConfigurationData = {
    /**
     * Represents the server configuration.
     */
    body: ServerConfiguration;
    path?: never;
    query?: never;
    url: '/System/Configuration';
};

export type UpdateConfigurationErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type UpdateConfigurationResponses = {
    /**
     * Configuration updated.
     */
    204: void;
};

export type UpdateConfigurationResponse = UpdateConfigurationResponses[keyof UpdateConfigurationResponses];

export type GetNamedConfigurationData = {
    body?: never;
    path: {
        /**
         * Configuration key.
         */
        key: string;
    };
    query?: never;
    url: '/System/Configuration/{key}';
};

export type GetNamedConfigurationErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetNamedConfigurationResponses = {
    /**
     * Configuration returned.
     */
    200: Blob | File;
};

export type GetNamedConfigurationResponse = GetNamedConfigurationResponses[keyof GetNamedConfigurationResponses];

export type UpdateNamedConfigurationData = {
    /**
     * Configuration.
     */
    body: unknown;
    path: {
        /**
         * Configuration key.
         */
        key: string;
    };
    query?: never;
    url: '/System/Configuration/{key}';
};

export type UpdateNamedConfigurationErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type UpdateNamedConfigurationResponses = {
    /**
     * Named configuration updated.
     */
    204: void;
};

export type UpdateNamedConfigurationResponse = UpdateNamedConfigurationResponses[keyof UpdateNamedConfigurationResponses];

export type GetDefaultMetadataOptionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/System/Configuration/MetadataOptions/Default';
};

export type GetDefaultMetadataOptionsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetDefaultMetadataOptionsResponses = {
    /**
     * Metadata options returned.
     */
    200: MetadataOptions;
};

export type GetDefaultMetadataOptionsResponse = GetDefaultMetadataOptionsResponses[keyof GetDefaultMetadataOptionsResponses];

export type GetDashboardConfigurationPageData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The name of the page.
         */
        name?: string;
    };
    url: '/web/ConfigurationPage';
};

export type GetDashboardConfigurationPageErrors = {
    /**
     * Plugin configuration page not found.
     */
    404: ProblemDetails;
};

export type GetDashboardConfigurationPageError = GetDashboardConfigurationPageErrors[keyof GetDashboardConfigurationPageErrors];

export type GetDashboardConfigurationPageResponses = {
    /**
     * ConfigurationPage returned.
     */
    200: Blob | File;
};

export type GetDashboardConfigurationPageResponse = GetDashboardConfigurationPageResponses[keyof GetDashboardConfigurationPageResponses];

export type GetConfigurationPagesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Whether to enable in the main menu.
         */
        enableInMainMenu?: boolean;
    };
    url: '/web/ConfigurationPages';
};

export type GetConfigurationPagesErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Server still loading.
     */
    404: ProblemDetails;
};

export type GetConfigurationPagesError = GetConfigurationPagesErrors[keyof GetConfigurationPagesErrors];

export type GetConfigurationPagesResponses = {
    /**
     * ConfigurationPages returned.
     */
    200: Array<ConfigurationPageInfo>;
};

export type GetConfigurationPagesResponse = GetConfigurationPagesResponses[keyof GetConfigurationPagesResponses];

export type DeleteDeviceData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Device Id.
         */
        id: string;
    };
    url: '/Devices';
};

export type DeleteDeviceErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Device not found.
     */
    404: ProblemDetails;
};

export type DeleteDeviceError = DeleteDeviceErrors[keyof DeleteDeviceErrors];

export type DeleteDeviceResponses = {
    /**
     * Device deleted.
     */
    204: void;
};

export type DeleteDeviceResponse = DeleteDeviceResponses[keyof DeleteDeviceResponses];

export type GetDevicesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Gets or sets the user identifier.
         */
        userId?: string;
    };
    url: '/Devices';
};

export type GetDevicesErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetDevicesResponses = {
    /**
     * Devices retrieved.
     */
    200: DeviceInfoDtoQueryResult;
};

export type GetDevicesResponse = GetDevicesResponses[keyof GetDevicesResponses];

export type GetDeviceInfoData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Device Id.
         */
        id: string;
    };
    url: '/Devices/Info';
};

export type GetDeviceInfoErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Device not found.
     */
    404: ProblemDetails;
};

export type GetDeviceInfoError = GetDeviceInfoErrors[keyof GetDeviceInfoErrors];

export type GetDeviceInfoResponses = {
    /**
     * Device info retrieved.
     */
    200: DeviceInfoDto;
};

export type GetDeviceInfoResponse = GetDeviceInfoResponses[keyof GetDeviceInfoResponses];

export type GetDeviceOptionsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Device Id.
         */
        id: string;
    };
    url: '/Devices/Options';
};

export type GetDeviceOptionsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Device not found.
     */
    404: ProblemDetails;
};

export type GetDeviceOptionsError = GetDeviceOptionsErrors[keyof GetDeviceOptionsErrors];

export type GetDeviceOptionsResponses = {
    /**
     * Device options retrieved.
     */
    200: DeviceOptionsDto;
};

export type GetDeviceOptionsResponse = GetDeviceOptionsResponses[keyof GetDeviceOptionsResponses];

export type UpdateDeviceOptionsData = {
    /**
     * A dto representing custom options for a device.
     */
    body: DeviceOptionsDto;
    path?: never;
    query: {
        /**
         * Device Id.
         */
        id: string;
    };
    url: '/Devices/Options';
};

export type UpdateDeviceOptionsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type UpdateDeviceOptionsResponses = {
    /**
     * Device options updated.
     */
    204: void;
};

export type UpdateDeviceOptionsResponse = UpdateDeviceOptionsResponses[keyof UpdateDeviceOptionsResponses];

export type GetDisplayPreferencesData = {
    body?: never;
    path: {
        /**
         * Display preferences id.
         */
        displayPreferencesId: string;
    };
    query: {
        /**
         * User id.
         */
        userId?: string;
        /**
         * Client.
         */
        client: string;
    };
    url: '/DisplayPreferences/{displayPreferencesId}';
};

export type GetDisplayPreferencesErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetDisplayPreferencesResponses = {
    /**
     * Display preferences retrieved.
     */
    200: DisplayPreferencesDto;
};

export type GetDisplayPreferencesResponse = GetDisplayPreferencesResponses[keyof GetDisplayPreferencesResponses];

export type UpdateDisplayPreferencesData = {
    /**
     * Defines the display preferences for any item that supports them (usually Folders).
     */
    body: DisplayPreferencesDto;
    path: {
        /**
         * Display preferences id.
         */
        displayPreferencesId: string;
    };
    query: {
        /**
         * User Id.
         */
        userId?: string;
        /**
         * Client.
         */
        client: string;
    };
    url: '/DisplayPreferences/{displayPreferencesId}';
};

export type UpdateDisplayPreferencesErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type UpdateDisplayPreferencesResponses = {
    /**
     * Display preferences updated.
     */
    204: void;
};

export type UpdateDisplayPreferencesResponse = UpdateDisplayPreferencesResponses[keyof UpdateDisplayPreferencesResponses];

export type GetHlsAudioSegmentData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
        /**
         * The playlist id.
         */
        playlistId: string;
        /**
         * The segment id.
         */
        segmentId: number;
        /**
         * The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
         */
        container: string;
    };
    query: {
        /**
         * The position of the requested segment in ticks.
         */
        runtimeTicks: number;
        /**
         * The length of the requested segment in ticks.
         */
        actualSegmentLengthTicks: number;
        /**
         * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         */
        static?: boolean;
        /**
         * The streaming parameters.
         */
        params?: string;
        /**
         * The tag.
         */
        tag?: string;
        /**
         * Optional. The dlna device profile id to utilize.
         * @deprecated
         */
        deviceProfileId?: string;
        /**
         * The play session id.
         */
        playSessionId?: string;
        /**
         * The segment container.
         */
        segmentContainer?: string;
        /**
         * The segment length.
         */
        segmentLength?: number;
        /**
         * The minimum number of segments.
         */
        minSegments?: number;
        /**
         * The media version id, if playing an alternate version.
         */
        mediaSourceId?: string;
        /**
         * The device id of the client requesting. Used to stop encoding processes when needed.
         */
        deviceId?: string;
        /**
         * Optional. Specify an audio codec to encode to, e.g. mp3.
         */
        audioCodec?: string;
        /**
         * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         */
        enableAutoStreamCopy?: boolean;
        /**
         * Whether or not to allow copying of the video stream url.
         */
        allowVideoStreamCopy?: boolean;
        /**
         * Whether or not to allow copying of the audio stream url.
         */
        allowAudioStreamCopy?: boolean;
        /**
         * Optional. Whether to break on non key frames.
         */
        breakOnNonKeyFrames?: boolean;
        /**
         * Optional. Specify a specific audio sample rate, e.g. 44100.
         */
        audioSampleRate?: number;
        /**
         * Optional. The maximum audio bit depth.
         */
        maxAudioBitDepth?: number;
        /**
         * Optional. The maximum streaming bitrate.
         */
        maxStreamingBitrate?: number;
        /**
         * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         */
        audioBitRate?: number;
        /**
         * Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         */
        audioChannels?: number;
        /**
         * Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         */
        maxAudioChannels?: number;
        /**
         * Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         */
        profile?: string;
        /**
         * Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         */
        level?: string;
        /**
         * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         */
        framerate?: number;
        /**
         * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         */
        maxFramerate?: number;
        /**
         * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         */
        copyTimestamps?: boolean;
        /**
         * Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
         */
        startTimeTicks?: number;
        /**
         * Optional. The fixed horizontal resolution of the encoded video.
         */
        width?: number;
        /**
         * Optional. The fixed vertical resolution of the encoded video.
         */
        height?: number;
        /**
         * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         */
        videoBitRate?: number;
        /**
         * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         */
        subtitleStreamIndex?: number;
        /**
         * Optional. Specify the subtitle delivery method.
         */
        subtitleMethod?: 'Encode' | 'Embed' | 'External' | 'Hls' | 'Drop';
        /**
         * Optional.
         */
        maxRefFrames?: number;
        /**
         * Optional. The maximum video bit depth.
         */
        maxVideoBitDepth?: number;
        /**
         * Optional. Whether to require avc.
         */
        requireAvc?: boolean;
        /**
         * Optional. Whether to deinterlace the video.
         */
        deInterlace?: boolean;
        /**
         * Optional. Whether to require a non anamorphic stream.
         */
        requireNonAnamorphic?: boolean;
        /**
         * Optional. The maximum number of audio channels to transcode.
         */
        transcodingMaxAudioChannels?: number;
        /**
         * Optional. The limit of how many cpu cores to use.
         */
        cpuCoreLimit?: number;
        /**
         * The live stream id.
         */
        liveStreamId?: string;
        /**
         * Optional. Whether to enable the MpegtsM2Ts mode.
         */
        enableMpegtsM2TsMode?: boolean;
        /**
         * Optional. Specify a video codec to encode to, e.g. h264.
         */
        videoCodec?: string;
        /**
         * Optional. Specify a subtitle codec to encode to.
         */
        subtitleCodec?: string;
        /**
         * Optional. The transcoding reason.
         */
        transcodeReasons?: string;
        /**
         * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         */
        audioStreamIndex?: number;
        /**
         * Optional. The index of the video stream to use. If omitted the first video stream will be used.
         */
        videoStreamIndex?: number;
        /**
         * Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         */
        context?: 'Streaming' | 'Static';
        /**
         * Optional. The streaming options.
         */
        streamOptions?: {
            [key: string]: string | null;
        };
        /**
         * Optional. Whether to enable Audio Encoding.
         */
        enableAudioVbrEncoding?: boolean;
    };
    url: '/Audio/{itemId}/hls1/{playlistId}/{segmentId}.{container}';
};

export type GetHlsAudioSegmentErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetHlsAudioSegmentResponses = {
    /**
     * Video stream returned.
     */
    200: Blob | File;
};

export type GetHlsAudioSegmentResponse = GetHlsAudioSegmentResponses[keyof GetHlsAudioSegmentResponses];

export type GetVariantHlsAudioPlaylistData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
    };
    query?: {
        /**
         * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         */
        static?: boolean;
        /**
         * The streaming parameters.
         */
        params?: string;
        /**
         * The tag.
         */
        tag?: string;
        /**
         * Optional. The dlna device profile id to utilize.
         * @deprecated
         */
        deviceProfileId?: string;
        /**
         * The play session id.
         */
        playSessionId?: string;
        /**
         * The segment container.
         */
        segmentContainer?: string;
        /**
         * The segment length.
         */
        segmentLength?: number;
        /**
         * The minimum number of segments.
         */
        minSegments?: number;
        /**
         * The media version id, if playing an alternate version.
         */
        mediaSourceId?: string;
        /**
         * The device id of the client requesting. Used to stop encoding processes when needed.
         */
        deviceId?: string;
        /**
         * Optional. Specify an audio codec to encode to, e.g. mp3.
         */
        audioCodec?: string;
        /**
         * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         */
        enableAutoStreamCopy?: boolean;
        /**
         * Whether or not to allow copying of the video stream url.
         */
        allowVideoStreamCopy?: boolean;
        /**
         * Whether or not to allow copying of the audio stream url.
         */
        allowAudioStreamCopy?: boolean;
        /**
         * Optional. Whether to break on non key frames.
         */
        breakOnNonKeyFrames?: boolean;
        /**
         * Optional. Specify a specific audio sample rate, e.g. 44100.
         */
        audioSampleRate?: number;
        /**
         * Optional. The maximum audio bit depth.
         */
        maxAudioBitDepth?: number;
        /**
         * Optional. The maximum streaming bitrate.
         */
        maxStreamingBitrate?: number;
        /**
         * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         */
        audioBitRate?: number;
        /**
         * Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         */
        audioChannels?: number;
        /**
         * Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         */
        maxAudioChannels?: number;
        /**
         * Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         */
        profile?: string;
        /**
         * Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         */
        level?: string;
        /**
         * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         */
        framerate?: number;
        /**
         * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         */
        maxFramerate?: number;
        /**
         * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         */
        copyTimestamps?: boolean;
        /**
         * Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
         */
        startTimeTicks?: number;
        /**
         * Optional. The fixed horizontal resolution of the encoded video.
         */
        width?: number;
        /**
         * Optional. The fixed vertical resolution of the encoded video.
         */
        height?: number;
        /**
         * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         */
        videoBitRate?: number;
        /**
         * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         */
        subtitleStreamIndex?: number;
        /**
         * Optional. Specify the subtitle delivery method.
         */
        subtitleMethod?: 'Encode' | 'Embed' | 'External' | 'Hls' | 'Drop';
        /**
         * Optional.
         */
        maxRefFrames?: number;
        /**
         * Optional. The maximum video bit depth.
         */
        maxVideoBitDepth?: number;
        /**
         * Optional. Whether to require avc.
         */
        requireAvc?: boolean;
        /**
         * Optional. Whether to deinterlace the video.
         */
        deInterlace?: boolean;
        /**
         * Optional. Whether to require a non anamorphic stream.
         */
        requireNonAnamorphic?: boolean;
        /**
         * Optional. The maximum number of audio channels to transcode.
         */
        transcodingMaxAudioChannels?: number;
        /**
         * Optional. The limit of how many cpu cores to use.
         */
        cpuCoreLimit?: number;
        /**
         * The live stream id.
         */
        liveStreamId?: string;
        /**
         * Optional. Whether to enable the MpegtsM2Ts mode.
         */
        enableMpegtsM2TsMode?: boolean;
        /**
         * Optional. Specify a video codec to encode to, e.g. h264.
         */
        videoCodec?: string;
        /**
         * Optional. Specify a subtitle codec to encode to.
         */
        subtitleCodec?: string;
        /**
         * Optional. The transcoding reason.
         */
        transcodeReasons?: string;
        /**
         * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         */
        audioStreamIndex?: number;
        /**
         * Optional. The index of the video stream to use. If omitted the first video stream will be used.
         */
        videoStreamIndex?: number;
        /**
         * Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         */
        context?: 'Streaming' | 'Static';
        /**
         * Optional. The streaming options.
         */
        streamOptions?: {
            [key: string]: string | null;
        };
        /**
         * Optional. Whether to enable Audio Encoding.
         */
        enableAudioVbrEncoding?: boolean;
    };
    url: '/Audio/{itemId}/main.m3u8';
};

export type GetVariantHlsAudioPlaylistErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetVariantHlsAudioPlaylistResponses = {
    /**
     * Audio stream returned.
     */
    200: Blob | File;
};

export type GetVariantHlsAudioPlaylistResponse = GetVariantHlsAudioPlaylistResponses[keyof GetVariantHlsAudioPlaylistResponses];

export type GetMasterHlsAudioPlaylistData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
    };
    query: {
        /**
         * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         */
        static?: boolean;
        /**
         * The streaming parameters.
         */
        params?: string;
        /**
         * The tag.
         */
        tag?: string;
        /**
         * Optional. The dlna device profile id to utilize.
         * @deprecated
         */
        deviceProfileId?: string;
        /**
         * The play session id.
         */
        playSessionId?: string;
        /**
         * The segment container.
         */
        segmentContainer?: string;
        /**
         * The segment length.
         */
        segmentLength?: number;
        /**
         * The minimum number of segments.
         */
        minSegments?: number;
        /**
         * The media version id, if playing an alternate version.
         */
        mediaSourceId: string;
        /**
         * The device id of the client requesting. Used to stop encoding processes when needed.
         */
        deviceId?: string;
        /**
         * Optional. Specify an audio codec to encode to, e.g. mp3.
         */
        audioCodec?: string;
        /**
         * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         */
        enableAutoStreamCopy?: boolean;
        /**
         * Whether or not to allow copying of the video stream url.
         */
        allowVideoStreamCopy?: boolean;
        /**
         * Whether or not to allow copying of the audio stream url.
         */
        allowAudioStreamCopy?: boolean;
        /**
         * Optional. Whether to break on non key frames.
         */
        breakOnNonKeyFrames?: boolean;
        /**
         * Optional. Specify a specific audio sample rate, e.g. 44100.
         */
        audioSampleRate?: number;
        /**
         * Optional. The maximum audio bit depth.
         */
        maxAudioBitDepth?: number;
        /**
         * Optional. The maximum streaming bitrate.
         */
        maxStreamingBitrate?: number;
        /**
         * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         */
        audioBitRate?: number;
        /**
         * Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         */
        audioChannels?: number;
        /**
         * Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         */
        maxAudioChannels?: number;
        /**
         * Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         */
        profile?: string;
        /**
         * Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         */
        level?: string;
        /**
         * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         */
        framerate?: number;
        /**
         * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         */
        maxFramerate?: number;
        /**
         * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         */
        copyTimestamps?: boolean;
        /**
         * Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
         */
        startTimeTicks?: number;
        /**
         * Optional. The fixed horizontal resolution of the encoded video.
         */
        width?: number;
        /**
         * Optional. The fixed vertical resolution of the encoded video.
         */
        height?: number;
        /**
         * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         */
        videoBitRate?: number;
        /**
         * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         */
        subtitleStreamIndex?: number;
        /**
         * Optional. Specify the subtitle delivery method.
         */
        subtitleMethod?: 'Encode' | 'Embed' | 'External' | 'Hls' | 'Drop';
        /**
         * Optional.
         */
        maxRefFrames?: number;
        /**
         * Optional. The maximum video bit depth.
         */
        maxVideoBitDepth?: number;
        /**
         * Optional. Whether to require avc.
         */
        requireAvc?: boolean;
        /**
         * Optional. Whether to deinterlace the video.
         */
        deInterlace?: boolean;
        /**
         * Optional. Whether to require a non anamorphic stream.
         */
        requireNonAnamorphic?: boolean;
        /**
         * Optional. The maximum number of audio channels to transcode.
         */
        transcodingMaxAudioChannels?: number;
        /**
         * Optional. The limit of how many cpu cores to use.
         */
        cpuCoreLimit?: number;
        /**
         * The live stream id.
         */
        liveStreamId?: string;
        /**
         * Optional. Whether to enable the MpegtsM2Ts mode.
         */
        enableMpegtsM2TsMode?: boolean;
        /**
         * Optional. Specify a video codec to encode to, e.g. h264.
         */
        videoCodec?: string;
        /**
         * Optional. Specify a subtitle codec to encode to.
         */
        subtitleCodec?: string;
        /**
         * Optional. The transcoding reason.
         */
        transcodeReasons?: string;
        /**
         * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         */
        audioStreamIndex?: number;
        /**
         * Optional. The index of the video stream to use. If omitted the first video stream will be used.
         */
        videoStreamIndex?: number;
        /**
         * Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         */
        context?: 'Streaming' | 'Static';
        /**
         * Optional. The streaming options.
         */
        streamOptions?: {
            [key: string]: string | null;
        };
        /**
         * Enable adaptive bitrate streaming.
         */
        enableAdaptiveBitrateStreaming?: boolean;
        /**
         * Optional. Whether to enable Audio Encoding.
         */
        enableAudioVbrEncoding?: boolean;
    };
    url: '/Audio/{itemId}/master.m3u8';
};

export type GetMasterHlsAudioPlaylistErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetMasterHlsAudioPlaylistResponses = {
    /**
     * Audio stream returned.
     */
    200: Blob | File;
};

export type GetMasterHlsAudioPlaylistResponse = GetMasterHlsAudioPlaylistResponses[keyof GetMasterHlsAudioPlaylistResponses];

export type HeadMasterHlsAudioPlaylistData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
    };
    query: {
        /**
         * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         */
        static?: boolean;
        /**
         * The streaming parameters.
         */
        params?: string;
        /**
         * The tag.
         */
        tag?: string;
        /**
         * Optional. The dlna device profile id to utilize.
         * @deprecated
         */
        deviceProfileId?: string;
        /**
         * The play session id.
         */
        playSessionId?: string;
        /**
         * The segment container.
         */
        segmentContainer?: string;
        /**
         * The segment length.
         */
        segmentLength?: number;
        /**
         * The minimum number of segments.
         */
        minSegments?: number;
        /**
         * The media version id, if playing an alternate version.
         */
        mediaSourceId: string;
        /**
         * The device id of the client requesting. Used to stop encoding processes when needed.
         */
        deviceId?: string;
        /**
         * Optional. Specify an audio codec to encode to, e.g. mp3.
         */
        audioCodec?: string;
        /**
         * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         */
        enableAutoStreamCopy?: boolean;
        /**
         * Whether or not to allow copying of the video stream url.
         */
        allowVideoStreamCopy?: boolean;
        /**
         * Whether or not to allow copying of the audio stream url.
         */
        allowAudioStreamCopy?: boolean;
        /**
         * Optional. Whether to break on non key frames.
         */
        breakOnNonKeyFrames?: boolean;
        /**
         * Optional. Specify a specific audio sample rate, e.g. 44100.
         */
        audioSampleRate?: number;
        /**
         * Optional. The maximum audio bit depth.
         */
        maxAudioBitDepth?: number;
        /**
         * Optional. The maximum streaming bitrate.
         */
        maxStreamingBitrate?: number;
        /**
         * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         */
        audioBitRate?: number;
        /**
         * Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         */
        audioChannels?: number;
        /**
         * Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         */
        maxAudioChannels?: number;
        /**
         * Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         */
        profile?: string;
        /**
         * Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         */
        level?: string;
        /**
         * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         */
        framerate?: number;
        /**
         * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         */
        maxFramerate?: number;
        /**
         * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         */
        copyTimestamps?: boolean;
        /**
         * Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
         */
        startTimeTicks?: number;
        /**
         * Optional. The fixed horizontal resolution of the encoded video.
         */
        width?: number;
        /**
         * Optional. The fixed vertical resolution of the encoded video.
         */
        height?: number;
        /**
         * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         */
        videoBitRate?: number;
        /**
         * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         */
        subtitleStreamIndex?: number;
        /**
         * Optional. Specify the subtitle delivery method.
         */
        subtitleMethod?: 'Encode' | 'Embed' | 'External' | 'Hls' | 'Drop';
        /**
         * Optional.
         */
        maxRefFrames?: number;
        /**
         * Optional. The maximum video bit depth.
         */
        maxVideoBitDepth?: number;
        /**
         * Optional. Whether to require avc.
         */
        requireAvc?: boolean;
        /**
         * Optional. Whether to deinterlace the video.
         */
        deInterlace?: boolean;
        /**
         * Optional. Whether to require a non anamorphic stream.
         */
        requireNonAnamorphic?: boolean;
        /**
         * Optional. The maximum number of audio channels to transcode.
         */
        transcodingMaxAudioChannels?: number;
        /**
         * Optional. The limit of how many cpu cores to use.
         */
        cpuCoreLimit?: number;
        /**
         * The live stream id.
         */
        liveStreamId?: string;
        /**
         * Optional. Whether to enable the MpegtsM2Ts mode.
         */
        enableMpegtsM2TsMode?: boolean;
        /**
         * Optional. Specify a video codec to encode to, e.g. h264.
         */
        videoCodec?: string;
        /**
         * Optional. Specify a subtitle codec to encode to.
         */
        subtitleCodec?: string;
        /**
         * Optional. The transcoding reason.
         */
        transcodeReasons?: string;
        /**
         * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         */
        audioStreamIndex?: number;
        /**
         * Optional. The index of the video stream to use. If omitted the first video stream will be used.
         */
        videoStreamIndex?: number;
        /**
         * Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         */
        context?: 'Streaming' | 'Static';
        /**
         * Optional. The streaming options.
         */
        streamOptions?: {
            [key: string]: string | null;
        };
        /**
         * Enable adaptive bitrate streaming.
         */
        enableAdaptiveBitrateStreaming?: boolean;
        /**
         * Optional. Whether to enable Audio Encoding.
         */
        enableAudioVbrEncoding?: boolean;
    };
    url: '/Audio/{itemId}/master.m3u8';
};

export type HeadMasterHlsAudioPlaylistErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type HeadMasterHlsAudioPlaylistResponses = {
    /**
     * Audio stream returned.
     */
    200: Blob | File;
};

export type HeadMasterHlsAudioPlaylistResponse = HeadMasterHlsAudioPlaylistResponses[keyof HeadMasterHlsAudioPlaylistResponses];

export type GetHlsVideoSegmentData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
        /**
         * The playlist id.
         */
        playlistId: string;
        /**
         * The segment id.
         */
        segmentId: number;
        /**
         * The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
         */
        container: string;
    };
    query: {
        /**
         * The position of the requested segment in ticks.
         */
        runtimeTicks: number;
        /**
         * The length of the requested segment in ticks.
         */
        actualSegmentLengthTicks: number;
        /**
         * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         */
        static?: boolean;
        /**
         * The streaming parameters.
         */
        params?: string;
        /**
         * The tag.
         */
        tag?: string;
        /**
         * Optional. The dlna device profile id to utilize.
         * @deprecated
         */
        deviceProfileId?: string;
        /**
         * The play session id.
         */
        playSessionId?: string;
        /**
         * The segment container.
         */
        segmentContainer?: string;
        /**
         * The desired segment length.
         */
        segmentLength?: number;
        /**
         * The minimum number of segments.
         */
        minSegments?: number;
        /**
         * The media version id, if playing an alternate version.
         */
        mediaSourceId?: string;
        /**
         * The device id of the client requesting. Used to stop encoding processes when needed.
         */
        deviceId?: string;
        /**
         * Optional. Specify an audio codec to encode to, e.g. mp3.
         */
        audioCodec?: string;
        /**
         * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         */
        enableAutoStreamCopy?: boolean;
        /**
         * Whether or not to allow copying of the video stream url.
         */
        allowVideoStreamCopy?: boolean;
        /**
         * Whether or not to allow copying of the audio stream url.
         */
        allowAudioStreamCopy?: boolean;
        /**
         * Optional. Whether to break on non key frames.
         */
        breakOnNonKeyFrames?: boolean;
        /**
         * Optional. Specify a specific audio sample rate, e.g. 44100.
         */
        audioSampleRate?: number;
        /**
         * Optional. The maximum audio bit depth.
         */
        maxAudioBitDepth?: number;
        /**
         * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         */
        audioBitRate?: number;
        /**
         * Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         */
        audioChannels?: number;
        /**
         * Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         */
        maxAudioChannels?: number;
        /**
         * Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         */
        profile?: string;
        /**
         * Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         */
        level?: string;
        /**
         * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         */
        framerate?: number;
        /**
         * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         */
        maxFramerate?: number;
        /**
         * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         */
        copyTimestamps?: boolean;
        /**
         * Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
         */
        startTimeTicks?: number;
        /**
         * Optional. The fixed horizontal resolution of the encoded video.
         */
        width?: number;
        /**
         * Optional. The fixed vertical resolution of the encoded video.
         */
        height?: number;
        /**
         * Optional. The maximum horizontal resolution of the encoded video.
         */
        maxWidth?: number;
        /**
         * Optional. The maximum vertical resolution of the encoded video.
         */
        maxHeight?: number;
        /**
         * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         */
        videoBitRate?: number;
        /**
         * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         */
        subtitleStreamIndex?: number;
        /**
         * Optional. Specify the subtitle delivery method.
         */
        subtitleMethod?: 'Encode' | 'Embed' | 'External' | 'Hls' | 'Drop';
        /**
         * Optional.
         */
        maxRefFrames?: number;
        /**
         * Optional. The maximum video bit depth.
         */
        maxVideoBitDepth?: number;
        /**
         * Optional. Whether to require avc.
         */
        requireAvc?: boolean;
        /**
         * Optional. Whether to deinterlace the video.
         */
        deInterlace?: boolean;
        /**
         * Optional. Whether to require a non anamorphic stream.
         */
        requireNonAnamorphic?: boolean;
        /**
         * Optional. The maximum number of audio channels to transcode.
         */
        transcodingMaxAudioChannels?: number;
        /**
         * Optional. The limit of how many cpu cores to use.
         */
        cpuCoreLimit?: number;
        /**
         * The live stream id.
         */
        liveStreamId?: string;
        /**
         * Optional. Whether to enable the MpegtsM2Ts mode.
         */
        enableMpegtsM2TsMode?: boolean;
        /**
         * Optional. Specify a video codec to encode to, e.g. h264.
         */
        videoCodec?: string;
        /**
         * Optional. Specify a subtitle codec to encode to.
         */
        subtitleCodec?: string;
        /**
         * Optional. The transcoding reason.
         */
        transcodeReasons?: string;
        /**
         * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         */
        audioStreamIndex?: number;
        /**
         * Optional. The index of the video stream to use. If omitted the first video stream will be used.
         */
        videoStreamIndex?: number;
        /**
         * Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         */
        context?: 'Streaming' | 'Static';
        /**
         * Optional. The streaming options.
         */
        streamOptions?: {
            [key: string]: string | null;
        };
        /**
         * Optional. Whether to enable Audio Encoding.
         */
        enableAudioVbrEncoding?: boolean;
        /**
         * Whether to always burn in subtitles when transcoding.
         */
        alwaysBurnInSubtitleWhenTranscoding?: boolean;
    };
    url: '/Videos/{itemId}/hls1/{playlistId}/{segmentId}.{container}';
};

export type GetHlsVideoSegmentErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetHlsVideoSegmentResponses = {
    /**
     * Video stream returned.
     */
    200: Blob | File;
};

export type GetHlsVideoSegmentResponse = GetHlsVideoSegmentResponses[keyof GetHlsVideoSegmentResponses];

export type GetLiveHlsStreamData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
    };
    query?: {
        /**
         * The audio container.
         */
        container?: string;
        /**
         * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         */
        static?: boolean;
        /**
         * The streaming parameters.
         */
        params?: string;
        /**
         * The tag.
         */
        tag?: string;
        /**
         * Optional. The dlna device profile id to utilize.
         * @deprecated
         */
        deviceProfileId?: string;
        /**
         * The play session id.
         */
        playSessionId?: string;
        /**
         * The segment container.
         */
        segmentContainer?: string;
        /**
         * The segment length.
         */
        segmentLength?: number;
        /**
         * The minimum number of segments.
         */
        minSegments?: number;
        /**
         * The media version id, if playing an alternate version.
         */
        mediaSourceId?: string;
        /**
         * The device id of the client requesting. Used to stop encoding processes when needed.
         */
        deviceId?: string;
        /**
         * Optional. Specify an audio codec to encode to, e.g. mp3.
         */
        audioCodec?: string;
        /**
         * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         */
        enableAutoStreamCopy?: boolean;
        /**
         * Whether or not to allow copying of the video stream url.
         */
        allowVideoStreamCopy?: boolean;
        /**
         * Whether or not to allow copying of the audio stream url.
         */
        allowAudioStreamCopy?: boolean;
        /**
         * Optional. Whether to break on non key frames.
         */
        breakOnNonKeyFrames?: boolean;
        /**
         * Optional. Specify a specific audio sample rate, e.g. 44100.
         */
        audioSampleRate?: number;
        /**
         * Optional. The maximum audio bit depth.
         */
        maxAudioBitDepth?: number;
        /**
         * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         */
        audioBitRate?: number;
        /**
         * Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         */
        audioChannels?: number;
        /**
         * Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         */
        maxAudioChannels?: number;
        /**
         * Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         */
        profile?: string;
        /**
         * Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         */
        level?: string;
        /**
         * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         */
        framerate?: number;
        /**
         * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         */
        maxFramerate?: number;
        /**
         * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         */
        copyTimestamps?: boolean;
        /**
         * Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
         */
        startTimeTicks?: number;
        /**
         * Optional. The fixed horizontal resolution of the encoded video.
         */
        width?: number;
        /**
         * Optional. The fixed vertical resolution of the encoded video.
         */
        height?: number;
        /**
         * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         */
        videoBitRate?: number;
        /**
         * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         */
        subtitleStreamIndex?: number;
        /**
         * Optional. Specify the subtitle delivery method.
         */
        subtitleMethod?: 'Encode' | 'Embed' | 'External' | 'Hls' | 'Drop';
        /**
         * Optional.
         */
        maxRefFrames?: number;
        /**
         * Optional. The maximum video bit depth.
         */
        maxVideoBitDepth?: number;
        /**
         * Optional. Whether to require avc.
         */
        requireAvc?: boolean;
        /**
         * Optional. Whether to deinterlace the video.
         */
        deInterlace?: boolean;
        /**
         * Optional. Whether to require a non anamorphic stream.
         */
        requireNonAnamorphic?: boolean;
        /**
         * Optional. The maximum number of audio channels to transcode.
         */
        transcodingMaxAudioChannels?: number;
        /**
         * Optional. The limit of how many cpu cores to use.
         */
        cpuCoreLimit?: number;
        /**
         * The live stream id.
         */
        liveStreamId?: string;
        /**
         * Optional. Whether to enable the MpegtsM2Ts mode.
         */
        enableMpegtsM2TsMode?: boolean;
        /**
         * Optional. Specify a video codec to encode to, e.g. h264.
         */
        videoCodec?: string;
        /**
         * Optional. Specify a subtitle codec to encode to.
         */
        subtitleCodec?: string;
        /**
         * Optional. The transcoding reason.
         */
        transcodeReasons?: string;
        /**
         * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         */
        audioStreamIndex?: number;
        /**
         * Optional. The index of the video stream to use. If omitted the first video stream will be used.
         */
        videoStreamIndex?: number;
        /**
         * Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         */
        context?: 'Streaming' | 'Static';
        /**
         * Optional. The streaming options.
         */
        streamOptions?: {
            [key: string]: string | null;
        };
        /**
         * Optional. The max width.
         */
        maxWidth?: number;
        /**
         * Optional. The max height.
         */
        maxHeight?: number;
        /**
         * Optional. Whether to enable subtitles in the manifest.
         */
        enableSubtitlesInManifest?: boolean;
        /**
         * Optional. Whether to enable Audio Encoding.
         */
        enableAudioVbrEncoding?: boolean;
        /**
         * Whether to always burn in subtitles when transcoding.
         */
        alwaysBurnInSubtitleWhenTranscoding?: boolean;
    };
    url: '/Videos/{itemId}/live.m3u8';
};

export type GetLiveHlsStreamErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetLiveHlsStreamResponses = {
    /**
     * Hls live stream retrieved.
     */
    200: Blob | File;
};

export type GetLiveHlsStreamResponse = GetLiveHlsStreamResponses[keyof GetLiveHlsStreamResponses];

export type GetVariantHlsVideoPlaylistData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
    };
    query?: {
        /**
         * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         */
        static?: boolean;
        /**
         * The streaming parameters.
         */
        params?: string;
        /**
         * The tag.
         */
        tag?: string;
        /**
         * Optional. The dlna device profile id to utilize.
         * @deprecated
         */
        deviceProfileId?: string;
        /**
         * The play session id.
         */
        playSessionId?: string;
        /**
         * The segment container.
         */
        segmentContainer?: string;
        /**
         * The segment length.
         */
        segmentLength?: number;
        /**
         * The minimum number of segments.
         */
        minSegments?: number;
        /**
         * The media version id, if playing an alternate version.
         */
        mediaSourceId?: string;
        /**
         * The device id of the client requesting. Used to stop encoding processes when needed.
         */
        deviceId?: string;
        /**
         * Optional. Specify an audio codec to encode to, e.g. mp3.
         */
        audioCodec?: string;
        /**
         * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         */
        enableAutoStreamCopy?: boolean;
        /**
         * Whether or not to allow copying of the video stream url.
         */
        allowVideoStreamCopy?: boolean;
        /**
         * Whether or not to allow copying of the audio stream url.
         */
        allowAudioStreamCopy?: boolean;
        /**
         * Optional. Whether to break on non key frames.
         */
        breakOnNonKeyFrames?: boolean;
        /**
         * Optional. Specify a specific audio sample rate, e.g. 44100.
         */
        audioSampleRate?: number;
        /**
         * Optional. The maximum audio bit depth.
         */
        maxAudioBitDepth?: number;
        /**
         * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         */
        audioBitRate?: number;
        /**
         * Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         */
        audioChannels?: number;
        /**
         * Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         */
        maxAudioChannels?: number;
        /**
         * Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         */
        profile?: string;
        /**
         * Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         */
        level?: string;
        /**
         * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         */
        framerate?: number;
        /**
         * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         */
        maxFramerate?: number;
        /**
         * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         */
        copyTimestamps?: boolean;
        /**
         * Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
         */
        startTimeTicks?: number;
        /**
         * Optional. The fixed horizontal resolution of the encoded video.
         */
        width?: number;
        /**
         * Optional. The fixed vertical resolution of the encoded video.
         */
        height?: number;
        /**
         * Optional. The maximum horizontal resolution of the encoded video.
         */
        maxWidth?: number;
        /**
         * Optional. The maximum vertical resolution of the encoded video.
         */
        maxHeight?: number;
        /**
         * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         */
        videoBitRate?: number;
        /**
         * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         */
        subtitleStreamIndex?: number;
        /**
         * Optional. Specify the subtitle delivery method.
         */
        subtitleMethod?: 'Encode' | 'Embed' | 'External' | 'Hls' | 'Drop';
        /**
         * Optional.
         */
        maxRefFrames?: number;
        /**
         * Optional. The maximum video bit depth.
         */
        maxVideoBitDepth?: number;
        /**
         * Optional. Whether to require avc.
         */
        requireAvc?: boolean;
        /**
         * Optional. Whether to deinterlace the video.
         */
        deInterlace?: boolean;
        /**
         * Optional. Whether to require a non anamorphic stream.
         */
        requireNonAnamorphic?: boolean;
        /**
         * Optional. The maximum number of audio channels to transcode.
         */
        transcodingMaxAudioChannels?: number;
        /**
         * Optional. The limit of how many cpu cores to use.
         */
        cpuCoreLimit?: number;
        /**
         * The live stream id.
         */
        liveStreamId?: string;
        /**
         * Optional. Whether to enable the MpegtsM2Ts mode.
         */
        enableMpegtsM2TsMode?: boolean;
        /**
         * Optional. Specify a video codec to encode to, e.g. h264.
         */
        videoCodec?: string;
        /**
         * Optional. Specify a subtitle codec to encode to.
         */
        subtitleCodec?: string;
        /**
         * Optional. The transcoding reason.
         */
        transcodeReasons?: string;
        /**
         * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         */
        audioStreamIndex?: number;
        /**
         * Optional. The index of the video stream to use. If omitted the first video stream will be used.
         */
        videoStreamIndex?: number;
        /**
         * Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         */
        context?: 'Streaming' | 'Static';
        /**
         * Optional. The streaming options.
         */
        streamOptions?: {
            [key: string]: string | null;
        };
        /**
         * Optional. Whether to enable Audio Encoding.
         */
        enableAudioVbrEncoding?: boolean;
        /**
         * Whether to always burn in subtitles when transcoding.
         */
        alwaysBurnInSubtitleWhenTranscoding?: boolean;
    };
    url: '/Videos/{itemId}/main.m3u8';
};

export type GetVariantHlsVideoPlaylistErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetVariantHlsVideoPlaylistResponses = {
    /**
     * Video stream returned.
     */
    200: Blob | File;
};

export type GetVariantHlsVideoPlaylistResponse = GetVariantHlsVideoPlaylistResponses[keyof GetVariantHlsVideoPlaylistResponses];

export type GetMasterHlsVideoPlaylistData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
    };
    query: {
        /**
         * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         */
        static?: boolean;
        /**
         * The streaming parameters.
         */
        params?: string;
        /**
         * The tag.
         */
        tag?: string;
        /**
         * Optional. The dlna device profile id to utilize.
         * @deprecated
         */
        deviceProfileId?: string;
        /**
         * The play session id.
         */
        playSessionId?: string;
        /**
         * The segment container.
         */
        segmentContainer?: string;
        /**
         * The segment length.
         */
        segmentLength?: number;
        /**
         * The minimum number of segments.
         */
        minSegments?: number;
        /**
         * The media version id, if playing an alternate version.
         */
        mediaSourceId: string;
        /**
         * The device id of the client requesting. Used to stop encoding processes when needed.
         */
        deviceId?: string;
        /**
         * Optional. Specify an audio codec to encode to, e.g. mp3.
         */
        audioCodec?: string;
        /**
         * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         */
        enableAutoStreamCopy?: boolean;
        /**
         * Whether or not to allow copying of the video stream url.
         */
        allowVideoStreamCopy?: boolean;
        /**
         * Whether or not to allow copying of the audio stream url.
         */
        allowAudioStreamCopy?: boolean;
        /**
         * Optional. Whether to break on non key frames.
         */
        breakOnNonKeyFrames?: boolean;
        /**
         * Optional. Specify a specific audio sample rate, e.g. 44100.
         */
        audioSampleRate?: number;
        /**
         * Optional. The maximum audio bit depth.
         */
        maxAudioBitDepth?: number;
        /**
         * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         */
        audioBitRate?: number;
        /**
         * Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         */
        audioChannels?: number;
        /**
         * Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         */
        maxAudioChannels?: number;
        /**
         * Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         */
        profile?: string;
        /**
         * Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         */
        level?: string;
        /**
         * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         */
        framerate?: number;
        /**
         * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         */
        maxFramerate?: number;
        /**
         * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         */
        copyTimestamps?: boolean;
        /**
         * Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
         */
        startTimeTicks?: number;
        /**
         * Optional. The fixed horizontal resolution of the encoded video.
         */
        width?: number;
        /**
         * Optional. The fixed vertical resolution of the encoded video.
         */
        height?: number;
        /**
         * Optional. The maximum horizontal resolution of the encoded video.
         */
        maxWidth?: number;
        /**
         * Optional. The maximum vertical resolution of the encoded video.
         */
        maxHeight?: number;
        /**
         * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         */
        videoBitRate?: number;
        /**
         * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         */
        subtitleStreamIndex?: number;
        /**
         * Optional. Specify the subtitle delivery method.
         */
        subtitleMethod?: 'Encode' | 'Embed' | 'External' | 'Hls' | 'Drop';
        /**
         * Optional.
         */
        maxRefFrames?: number;
        /**
         * Optional. The maximum video bit depth.
         */
        maxVideoBitDepth?: number;
        /**
         * Optional. Whether to require avc.
         */
        requireAvc?: boolean;
        /**
         * Optional. Whether to deinterlace the video.
         */
        deInterlace?: boolean;
        /**
         * Optional. Whether to require a non anamorphic stream.
         */
        requireNonAnamorphic?: boolean;
        /**
         * Optional. The maximum number of audio channels to transcode.
         */
        transcodingMaxAudioChannels?: number;
        /**
         * Optional. The limit of how many cpu cores to use.
         */
        cpuCoreLimit?: number;
        /**
         * The live stream id.
         */
        liveStreamId?: string;
        /**
         * Optional. Whether to enable the MpegtsM2Ts mode.
         */
        enableMpegtsM2TsMode?: boolean;
        /**
         * Optional. Specify a video codec to encode to, e.g. h264.
         */
        videoCodec?: string;
        /**
         * Optional. Specify a subtitle codec to encode to.
         */
        subtitleCodec?: string;
        /**
         * Optional. The transcoding reason.
         */
        transcodeReasons?: string;
        /**
         * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         */
        audioStreamIndex?: number;
        /**
         * Optional. The index of the video stream to use. If omitted the first video stream will be used.
         */
        videoStreamIndex?: number;
        /**
         * Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         */
        context?: 'Streaming' | 'Static';
        /**
         * Optional. The streaming options.
         */
        streamOptions?: {
            [key: string]: string | null;
        };
        /**
         * Enable adaptive bitrate streaming.
         */
        enableAdaptiveBitrateStreaming?: boolean;
        /**
         * Enable trickplay image playlists being added to master playlist.
         */
        enableTrickplay?: boolean;
        /**
         * Whether to enable Audio Encoding.
         */
        enableAudioVbrEncoding?: boolean;
        /**
         * Whether to always burn in subtitles when transcoding.
         */
        alwaysBurnInSubtitleWhenTranscoding?: boolean;
    };
    url: '/Videos/{itemId}/master.m3u8';
};

export type GetMasterHlsVideoPlaylistErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetMasterHlsVideoPlaylistResponses = {
    /**
     * Video stream returned.
     */
    200: Blob | File;
};

export type GetMasterHlsVideoPlaylistResponse = GetMasterHlsVideoPlaylistResponses[keyof GetMasterHlsVideoPlaylistResponses];

export type HeadMasterHlsVideoPlaylistData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
    };
    query: {
        /**
         * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         */
        static?: boolean;
        /**
         * The streaming parameters.
         */
        params?: string;
        /**
         * The tag.
         */
        tag?: string;
        /**
         * Optional. The dlna device profile id to utilize.
         * @deprecated
         */
        deviceProfileId?: string;
        /**
         * The play session id.
         */
        playSessionId?: string;
        /**
         * The segment container.
         */
        segmentContainer?: string;
        /**
         * The segment length.
         */
        segmentLength?: number;
        /**
         * The minimum number of segments.
         */
        minSegments?: number;
        /**
         * The media version id, if playing an alternate version.
         */
        mediaSourceId: string;
        /**
         * The device id of the client requesting. Used to stop encoding processes when needed.
         */
        deviceId?: string;
        /**
         * Optional. Specify an audio codec to encode to, e.g. mp3.
         */
        audioCodec?: string;
        /**
         * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         */
        enableAutoStreamCopy?: boolean;
        /**
         * Whether or not to allow copying of the video stream url.
         */
        allowVideoStreamCopy?: boolean;
        /**
         * Whether or not to allow copying of the audio stream url.
         */
        allowAudioStreamCopy?: boolean;
        /**
         * Optional. Whether to break on non key frames.
         */
        breakOnNonKeyFrames?: boolean;
        /**
         * Optional. Specify a specific audio sample rate, e.g. 44100.
         */
        audioSampleRate?: number;
        /**
         * Optional. The maximum audio bit depth.
         */
        maxAudioBitDepth?: number;
        /**
         * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         */
        audioBitRate?: number;
        /**
         * Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         */
        audioChannels?: number;
        /**
         * Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         */
        maxAudioChannels?: number;
        /**
         * Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         */
        profile?: string;
        /**
         * Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         */
        level?: string;
        /**
         * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         */
        framerate?: number;
        /**
         * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         */
        maxFramerate?: number;
        /**
         * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         */
        copyTimestamps?: boolean;
        /**
         * Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
         */
        startTimeTicks?: number;
        /**
         * Optional. The fixed horizontal resolution of the encoded video.
         */
        width?: number;
        /**
         * Optional. The fixed vertical resolution of the encoded video.
         */
        height?: number;
        /**
         * Optional. The maximum horizontal resolution of the encoded video.
         */
        maxWidth?: number;
        /**
         * Optional. The maximum vertical resolution of the encoded video.
         */
        maxHeight?: number;
        /**
         * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         */
        videoBitRate?: number;
        /**
         * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         */
        subtitleStreamIndex?: number;
        /**
         * Optional. Specify the subtitle delivery method.
         */
        subtitleMethod?: 'Encode' | 'Embed' | 'External' | 'Hls' | 'Drop';
        /**
         * Optional.
         */
        maxRefFrames?: number;
        /**
         * Optional. The maximum video bit depth.
         */
        maxVideoBitDepth?: number;
        /**
         * Optional. Whether to require avc.
         */
        requireAvc?: boolean;
        /**
         * Optional. Whether to deinterlace the video.
         */
        deInterlace?: boolean;
        /**
         * Optional. Whether to require a non anamorphic stream.
         */
        requireNonAnamorphic?: boolean;
        /**
         * Optional. The maximum number of audio channels to transcode.
         */
        transcodingMaxAudioChannels?: number;
        /**
         * Optional. The limit of how many cpu cores to use.
         */
        cpuCoreLimit?: number;
        /**
         * The live stream id.
         */
        liveStreamId?: string;
        /**
         * Optional. Whether to enable the MpegtsM2Ts mode.
         */
        enableMpegtsM2TsMode?: boolean;
        /**
         * Optional. Specify a video codec to encode to, e.g. h264.
         */
        videoCodec?: string;
        /**
         * Optional. Specify a subtitle codec to encode to.
         */
        subtitleCodec?: string;
        /**
         * Optional. The transcoding reason.
         */
        transcodeReasons?: string;
        /**
         * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         */
        audioStreamIndex?: number;
        /**
         * Optional. The index of the video stream to use. If omitted the first video stream will be used.
         */
        videoStreamIndex?: number;
        /**
         * Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         */
        context?: 'Streaming' | 'Static';
        /**
         * Optional. The streaming options.
         */
        streamOptions?: {
            [key: string]: string | null;
        };
        /**
         * Enable adaptive bitrate streaming.
         */
        enableAdaptiveBitrateStreaming?: boolean;
        /**
         * Enable trickplay image playlists being added to master playlist.
         */
        enableTrickplay?: boolean;
        /**
         * Whether to enable Audio Encoding.
         */
        enableAudioVbrEncoding?: boolean;
        /**
         * Whether to always burn in subtitles when transcoding.
         */
        alwaysBurnInSubtitleWhenTranscoding?: boolean;
    };
    url: '/Videos/{itemId}/master.m3u8';
};

export type HeadMasterHlsVideoPlaylistErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type HeadMasterHlsVideoPlaylistResponses = {
    /**
     * Video stream returned.
     */
    200: Blob | File;
};

export type HeadMasterHlsVideoPlaylistResponse = HeadMasterHlsVideoPlaylistResponses[keyof HeadMasterHlsVideoPlaylistResponses];

export type GetDefaultDirectoryBrowserData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Environment/DefaultDirectoryBrowser';
};

export type GetDefaultDirectoryBrowserErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetDefaultDirectoryBrowserResponses = {
    /**
     * Default directory browser returned.
     */
    200: DefaultDirectoryBrowserInfoDto;
};

export type GetDefaultDirectoryBrowserResponse = GetDefaultDirectoryBrowserResponses[keyof GetDefaultDirectoryBrowserResponses];

export type GetDirectoryContentsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The path.
         */
        path: string;
        /**
         * An optional filter to include or exclude files from the results. true/false.
         */
        includeFiles?: boolean;
        /**
         * An optional filter to include or exclude folders from the results. true/false.
         */
        includeDirectories?: boolean;
    };
    url: '/Environment/DirectoryContents';
};

export type GetDirectoryContentsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetDirectoryContentsResponses = {
    /**
     * Directory contents returned.
     */
    200: Array<FileSystemEntryInfo>;
};

export type GetDirectoryContentsResponse = GetDirectoryContentsResponses[keyof GetDirectoryContentsResponses];

export type GetDrivesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Environment/Drives';
};

export type GetDrivesErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetDrivesResponses = {
    /**
     * List of entries returned.
     */
    200: Array<FileSystemEntryInfo>;
};

export type GetDrivesResponse = GetDrivesResponses[keyof GetDrivesResponses];

export type GetNetworkSharesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Environment/NetworkShares';
};

export type GetNetworkSharesErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetNetworkSharesResponses = {
    /**
     * Empty array returned.
     */
    200: Array<FileSystemEntryInfo>;
};

export type GetNetworkSharesResponse = GetNetworkSharesResponses[keyof GetNetworkSharesResponses];

export type GetParentPathData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The path.
         */
        path: string;
    };
    url: '/Environment/ParentPath';
};

export type GetParentPathErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetParentPathResponses = {
    /**
     * Success
     */
    200: string;
};

export type GetParentPathResponse = GetParentPathResponses[keyof GetParentPathResponses];

export type ValidatePathData = {
    /**
     * Validate path object.
     */
    body: ValidatePathDto;
    path?: never;
    query?: never;
    url: '/Environment/ValidatePath';
};

export type ValidatePathErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Path not found.
     */
    404: ProblemDetails;
};

export type ValidatePathError = ValidatePathErrors[keyof ValidatePathErrors];

export type ValidatePathResponses = {
    /**
     * Path validated.
     */
    204: void;
};

export type ValidatePathResponse = ValidatePathResponses[keyof ValidatePathResponses];

export type GetQueryFiltersLegacyData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional. User id.
         */
        userId?: string;
        /**
         * Optional. Parent id.
         */
        parentId?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
         */
        includeItemTypes?: Array<BaseItemKind>;
        /**
         * Optional. Filter by MediaType. Allows multiple, comma delimited.
         */
        mediaTypes?: Array<MediaType>;
    };
    url: '/Items/Filters';
};

export type GetQueryFiltersLegacyErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetQueryFiltersLegacyResponses = {
    /**
     * Legacy filters retrieved.
     */
    200: QueryFiltersLegacy;
};

export type GetQueryFiltersLegacyResponse = GetQueryFiltersLegacyResponses[keyof GetQueryFiltersLegacyResponses];

export type GetQueryFiltersData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional. User id.
         */
        userId?: string;
        /**
         * Optional. Specify this to localize the search to a specific item or folder. Omit to use the root.
         */
        parentId?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
         */
        includeItemTypes?: Array<BaseItemKind>;
        /**
         * Optional. Is item airing.
         */
        isAiring?: boolean;
        /**
         * Optional. Is item movie.
         */
        isMovie?: boolean;
        /**
         * Optional. Is item sports.
         */
        isSports?: boolean;
        /**
         * Optional. Is item kids.
         */
        isKids?: boolean;
        /**
         * Optional. Is item news.
         */
        isNews?: boolean;
        /**
         * Optional. Is item series.
         */
        isSeries?: boolean;
        /**
         * Optional. Search recursive.
         */
        recursive?: boolean;
    };
    url: '/Items/Filters2';
};

export type GetQueryFiltersErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetQueryFiltersResponses = {
    /**
     * Filters retrieved.
     */
    200: QueryFilters;
};

export type GetQueryFiltersResponse = GetQueryFiltersResponses[keyof GetQueryFiltersResponses];

export type GetGenresData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        startIndex?: number;
        /**
         * Optional. The maximum number of records to return.
         */
        limit?: number;
        /**
         * The search term.
         */
        searchTerm?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root.
         */
        parentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output.
         */
        fields?: Array<ItemFields>;
        /**
         * Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
         */
        excludeItemTypes?: Array<BaseItemKind>;
        /**
         * Optional. If specified, results will be filtered in based on item type. This allows multiple, comma delimited.
         */
        includeItemTypes?: Array<BaseItemKind>;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        isFavorite?: boolean;
        /**
         * Optional, the max number of images to return, per image type.
         */
        imageTypeLimit?: number;
        /**
         * Optional. The image types to include in the output.
         */
        enableImageTypes?: Array<ImageType>;
        /**
         * User id.
         */
        userId?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        nameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        nameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        nameLessThan?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimited.
         */
        sortBy?: Array<ItemSortBy>;
        /**
         * Sort Order - Ascending,Descending.
         */
        sortOrder?: Array<SortOrder>;
        /**
         * Optional, include image information in output.
         */
        enableImages?: boolean;
        /**
         * Optional. Include total record count.
         */
        enableTotalRecordCount?: boolean;
    };
    url: '/Genres';
};

export type GetGenresErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetGenresResponses = {
    /**
     * Genres returned.
     */
    200: BaseItemDtoQueryResult;
};

export type GetGenresResponse = GetGenresResponses[keyof GetGenresResponses];

export type GetGenreData = {
    body?: never;
    path: {
        /**
         * The genre name.
         */
        genreName: string;
    };
    query?: {
        /**
         * The user id.
         */
        userId?: string;
    };
    url: '/Genres/{genreName}';
};

export type GetGenreErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetGenreResponses = {
    /**
     * Genres returned.
     */
    200: BaseItemDto;
};

export type GetGenreResponse = GetGenreResponses[keyof GetGenreResponses];

export type GetHlsAudioSegmentLegacyAacData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
        /**
         * The segment id.
         */
        segmentId: string;
    };
    query?: never;
    url: '/Audio/{itemId}/hls/{segmentId}/stream.aac';
};

export type GetHlsAudioSegmentLegacyAacResponses = {
    /**
     * Hls audio segment returned.
     */
    200: Blob | File;
};

export type GetHlsAudioSegmentLegacyAacResponse = GetHlsAudioSegmentLegacyAacResponses[keyof GetHlsAudioSegmentLegacyAacResponses];

export type GetHlsAudioSegmentLegacyMp3Data = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
        /**
         * The segment id.
         */
        segmentId: string;
    };
    query?: never;
    url: '/Audio/{itemId}/hls/{segmentId}/stream.mp3';
};

export type GetHlsAudioSegmentLegacyMp3Responses = {
    /**
     * Hls audio segment returned.
     */
    200: Blob | File;
};

export type GetHlsAudioSegmentLegacyMp3Response = GetHlsAudioSegmentLegacyMp3Responses[keyof GetHlsAudioSegmentLegacyMp3Responses];

export type GetHlsVideoSegmentLegacyData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
        /**
         * The playlist id.
         */
        playlistId: string;
        /**
         * The segment id.
         */
        segmentId: string;
        /**
         * The segment container.
         */
        segmentContainer: string;
    };
    query?: never;
    url: '/Videos/{itemId}/hls/{playlistId}/{segmentId}.{segmentContainer}';
};

export type GetHlsVideoSegmentLegacyErrors = {
    /**
     * Hls segment not found.
     */
    404: ProblemDetails;
};

export type GetHlsVideoSegmentLegacyError = GetHlsVideoSegmentLegacyErrors[keyof GetHlsVideoSegmentLegacyErrors];

export type GetHlsVideoSegmentLegacyResponses = {
    /**
     * Hls video segment returned.
     */
    200: Blob | File;
};

export type GetHlsVideoSegmentLegacyResponse = GetHlsVideoSegmentLegacyResponses[keyof GetHlsVideoSegmentLegacyResponses];

export type GetHlsPlaylistLegacyData = {
    body?: never;
    path: {
        /**
         * The video id.
         */
        itemId: string;
        /**
         * The playlist id.
         */
        playlistId: string;
    };
    query?: never;
    url: '/Videos/{itemId}/hls/{playlistId}/stream.m3u8';
};

export type GetHlsPlaylistLegacyErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetHlsPlaylistLegacyResponses = {
    /**
     * Hls video playlist returned.
     */
    200: Blob | File;
};

export type GetHlsPlaylistLegacyResponse = GetHlsPlaylistLegacyResponses[keyof GetHlsPlaylistLegacyResponses];

export type StopEncodingProcessData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The device id of the client requesting. Used to stop encoding processes when needed.
         */
        deviceId: string;
        /**
         * The play session id.
         */
        playSessionId: string;
    };
    url: '/Videos/ActiveEncodings';
};

export type StopEncodingProcessErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type StopEncodingProcessResponses = {
    /**
     * Encoding stopped successfully.
     */
    204: void;
};

export type StopEncodingProcessResponse = StopEncodingProcessResponses[keyof StopEncodingProcessResponses];

export type GetArtistImageData = {
    body?: never;
    path: {
        /**
         * Artist name.
         */
        name: string;
        /**
         * Enum ImageType.
         */
        imageType: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Profile';
        /**
         * Image index.
         */
        imageIndex: number;
    };
    query?: {
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        tag?: string;
        /**
         * Determines the output format of the image - original,gif,jpg,png.
         */
        format?: 'Bmp' | 'Gif' | 'Jpg' | 'Png' | 'Webp' | 'Svg';
        /**
         * The maximum image width to return.
         */
        maxWidth?: number;
        /**
         * The maximum image height to return.
         */
        maxHeight?: number;
        /**
         * Optional. Percent to render for the percent played overlay.
         */
        percentPlayed?: number;
        /**
         * Optional. Unplayed count overlay to render.
         */
        unplayedCount?: number;
        /**
         * The fixed image width to return.
         */
        width?: number;
        /**
         * The fixed image height to return.
         */
        height?: number;
        /**
         * Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        quality?: number;
        /**
         * Width of box to fill.
         */
        fillWidth?: number;
        /**
         * Height of box to fill.
         */
        fillHeight?: number;
        /**
         * Optional. Blur image.
         */
        blur?: number;
        /**
         * Optional. Apply a background color for transparent images.
         */
        backgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        foregroundLayer?: string;
    };
    url: '/Artists/{name}/Images/{imageType}/{imageIndex}';
};

export type GetArtistImageErrors = {
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type GetArtistImageError = GetArtistImageErrors[keyof GetArtistImageErrors];

export type GetArtistImageResponses = {
    /**
     * Image stream returned.
     */
    200: Blob | File;
};

export type GetArtistImageResponse = GetArtistImageResponses[keyof GetArtistImageResponses];

export type HeadArtistImageData = {
    body?: never;
    path: {
        /**
         * Artist name.
         */
        name: string;
        /**
         * Enum ImageType.
         */
        imageType: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Profile';
        /**
         * Image index.
         */
        imageIndex: number;
    };
    query?: {
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        tag?: string;
        /**
         * Determines the output format of the image - original,gif,jpg,png.
         */
        format?: 'Bmp' | 'Gif' | 'Jpg' | 'Png' | 'Webp' | 'Svg';
        /**
         * The maximum image width to return.
         */
        maxWidth?: number;
        /**
         * The maximum image height to return.
         */
        maxHeight?: number;
        /**
         * Optional. Percent to render for the percent played overlay.
         */
        percentPlayed?: number;
        /**
         * Optional. Unplayed count overlay to render.
         */
        unplayedCount?: number;
        /**
         * The fixed image width to return.
         */
        width?: number;
        /**
         * The fixed image height to return.
         */
        height?: number;
        /**
         * Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        quality?: number;
        /**
         * Width of box to fill.
         */
        fillWidth?: number;
        /**
         * Height of box to fill.
         */
        fillHeight?: number;
        /**
         * Optional. Blur image.
         */
        blur?: number;
        /**
         * Optional. Apply a background color for transparent images.
         */
        backgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        foregroundLayer?: string;
    };
    url: '/Artists/{name}/Images/{imageType}/{imageIndex}';
};

export type HeadArtistImageErrors = {
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type HeadArtistImageError = HeadArtistImageErrors[keyof HeadArtistImageErrors];

export type HeadArtistImageResponses = {
    /**
     * Image stream returned.
     */
    200: Blob | File;
};

export type HeadArtistImageResponse = HeadArtistImageResponses[keyof HeadArtistImageResponses];

export type DeleteCustomSplashscreenData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Branding/Splashscreen';
};

export type DeleteCustomSplashscreenErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * User does not have permission to delete splashscreen..
     */
    403: unknown;
};

export type DeleteCustomSplashscreenResponses = {
    /**
     * Successfully deleted the custom splashscreen.
     */
    204: void;
};

export type DeleteCustomSplashscreenResponse = DeleteCustomSplashscreenResponses[keyof DeleteCustomSplashscreenResponses];

export type GetSplashscreenData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Supply the cache tag from the item object to receive strong caching headers.
         */
        tag?: string;
        /**
         * Determines the output format of the image - original,gif,jpg,png.
         */
        format?: 'Bmp' | 'Gif' | 'Jpg' | 'Png' | 'Webp' | 'Svg';
        /**
         * The maximum image width to return.
         */
        maxWidth?: number;
        /**
         * The maximum image height to return.
         */
        maxHeight?: number;
        /**
         * The fixed image width to return.
         */
        width?: number;
        /**
         * The fixed image height to return.
         */
        height?: number;
        /**
         * Width of box to fill.
         */
        fillWidth?: number;
        /**
         * Height of box to fill.
         */
        fillHeight?: number;
        /**
         * Blur image.
         */
        blur?: number;
        /**
         * Apply a background color for transparent images.
         */
        backgroundColor?: string;
        /**
         * Apply a foreground layer on top of the image.
         */
        foregroundLayer?: string;
        /**
         * Quality setting, from 0-100.
         */
        quality?: number;
    };
    url: '/Branding/Splashscreen';
};

export type GetSplashscreenResponses = {
    /**
     * Splashscreen returned successfully.
     */
    200: Blob | File;
};

export type GetSplashscreenResponse = GetSplashscreenResponses[keyof GetSplashscreenResponses];

export type UploadCustomSplashscreenData = {
    body?: Blob | File;
    path?: never;
    query?: never;
    url: '/Branding/Splashscreen';
};

export type UploadCustomSplashscreenErrors = {
    /**
     * Error reading MimeType from uploaded image.
     */
    400: ProblemDetails;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * User does not have permission to upload splashscreen..
     */
    403: ProblemDetails;
};

export type UploadCustomSplashscreenError = UploadCustomSplashscreenErrors[keyof UploadCustomSplashscreenErrors];

export type UploadCustomSplashscreenResponses = {
    /**
     * Successfully uploaded new splashscreen.
     */
    204: void;
};

export type UploadCustomSplashscreenResponse = UploadCustomSplashscreenResponses[keyof UploadCustomSplashscreenResponses];

export type GetGenreImageData = {
    body?: never;
    path: {
        /**
         * Genre name.
         */
        name: string;
        /**
         * Enum ImageType.
         */
        imageType: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Profile';
    };
    query?: {
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        tag?: string;
        /**
         * Determines the output format of the image - original,gif,jpg,png.
         */
        format?: 'Bmp' | 'Gif' | 'Jpg' | 'Png' | 'Webp' | 'Svg';
        /**
         * The maximum image width to return.
         */
        maxWidth?: number;
        /**
         * The maximum image height to return.
         */
        maxHeight?: number;
        /**
         * Optional. Percent to render for the percent played overlay.
         */
        percentPlayed?: number;
        /**
         * Optional. Unplayed count overlay to render.
         */
        unplayedCount?: number;
        /**
         * The fixed image width to return.
         */
        width?: number;
        /**
         * The fixed image height to return.
         */
        height?: number;
        /**
         * Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        quality?: number;
        /**
         * Width of box to fill.
         */
        fillWidth?: number;
        /**
         * Height of box to fill.
         */
        fillHeight?: number;
        /**
         * Optional. Blur image.
         */
        blur?: number;
        /**
         * Optional. Apply a background color for transparent images.
         */
        backgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        foregroundLayer?: string;
        /**
         * Image index.
         */
        imageIndex?: number;
    };
    url: '/Genres/{name}/Images/{imageType}';
};

export type GetGenreImageErrors = {
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type GetGenreImageError = GetGenreImageErrors[keyof GetGenreImageErrors];

export type GetGenreImageResponses = {
    /**
     * Image stream returned.
     */
    200: Blob | File;
};

export type GetGenreImageResponse = GetGenreImageResponses[keyof GetGenreImageResponses];

export type HeadGenreImageData = {
    body?: never;
    path: {
        /**
         * Genre name.
         */
        name: string;
        /**
         * Enum ImageType.
         */
        imageType: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Profile';
    };
    query?: {
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        tag?: string;
        /**
         * Determines the output format of the image - original,gif,jpg,png.
         */
        format?: 'Bmp' | 'Gif' | 'Jpg' | 'Png' | 'Webp' | 'Svg';
        /**
         * The maximum image width to return.
         */
        maxWidth?: number;
        /**
         * The maximum image height to return.
         */
        maxHeight?: number;
        /**
         * Optional. Percent to render for the percent played overlay.
         */
        percentPlayed?: number;
        /**
         * Optional. Unplayed count overlay to render.
         */
        unplayedCount?: number;
        /**
         * The fixed image width to return.
         */
        width?: number;
        /**
         * The fixed image height to return.
         */
        height?: number;
        /**
         * Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        quality?: number;
        /**
         * Width of box to fill.
         */
        fillWidth?: number;
        /**
         * Height of box to fill.
         */
        fillHeight?: number;
        /**
         * Optional. Blur image.
         */
        blur?: number;
        /**
         * Optional. Apply a background color for transparent images.
         */
        backgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        foregroundLayer?: string;
        /**
         * Image index.
         */
        imageIndex?: number;
    };
    url: '/Genres/{name}/Images/{imageType}';
};

export type HeadGenreImageErrors = {
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type HeadGenreImageError = HeadGenreImageErrors[keyof HeadGenreImageErrors];

export type HeadGenreImageResponses = {
    /**
     * Image stream returned.
     */
    200: Blob | File;
};

export type HeadGenreImageResponse = HeadGenreImageResponses[keyof HeadGenreImageResponses];

export type GetGenreImageByIndexData = {
    body?: never;
    path: {
        /**
         * Genre name.
         */
        name: string;
        /**
         * Enum ImageType.
         */
        imageType: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Profile';
        /**
         * Image index.
         */
        imageIndex: number;
    };
    query?: {
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        tag?: string;
        /**
         * Determines the output format of the image - original,gif,jpg,png.
         */
        format?: 'Bmp' | 'Gif' | 'Jpg' | 'Png' | 'Webp' | 'Svg';
        /**
         * The maximum image width to return.
         */
        maxWidth?: number;
        /**
         * The maximum image height to return.
         */
        maxHeight?: number;
        /**
         * Optional. Percent to render for the percent played overlay.
         */
        percentPlayed?: number;
        /**
         * Optional. Unplayed count overlay to render.
         */
        unplayedCount?: number;
        /**
         * The fixed image width to return.
         */
        width?: number;
        /**
         * The fixed image height to return.
         */
        height?: number;
        /**
         * Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        quality?: number;
        /**
         * Width of box to fill.
         */
        fillWidth?: number;
        /**
         * Height of box to fill.
         */
        fillHeight?: number;
        /**
         * Optional. Blur image.
         */
        blur?: number;
        /**
         * Optional. Apply a background color for transparent images.
         */
        backgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        foregroundLayer?: string;
    };
    url: '/Genres/{name}/Images/{imageType}/{imageIndex}';
};

export type GetGenreImageByIndexErrors = {
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type GetGenreImageByIndexError = GetGenreImageByIndexErrors[keyof GetGenreImageByIndexErrors];

export type GetGenreImageByIndexResponses = {
    /**
     * Image stream returned.
     */
    200: Blob | File;
};

export type GetGenreImageByIndexResponse = GetGenreImageByIndexResponses[keyof GetGenreImageByIndexResponses];

export type HeadGenreImageByIndexData = {
    body?: never;
    path: {
        /**
         * Genre name.
         */
        name: string;
        /**
         * Enum ImageType.
         */
        imageType: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Profile';
        /**
         * Image index.
         */
        imageIndex: number;
    };
    query?: {
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        tag?: string;
        /**
         * Determines the output format of the image - original,gif,jpg,png.
         */
        format?: 'Bmp' | 'Gif' | 'Jpg' | 'Png' | 'Webp' | 'Svg';
        /**
         * The maximum image width to return.
         */
        maxWidth?: number;
        /**
         * The maximum image height to return.
         */
        maxHeight?: number;
        /**
         * Optional. Percent to render for the percent played overlay.
         */
        percentPlayed?: number;
        /**
         * Optional. Unplayed count overlay to render.
         */
        unplayedCount?: number;
        /**
         * The fixed image width to return.
         */
        width?: number;
        /**
         * The fixed image height to return.
         */
        height?: number;
        /**
         * Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        quality?: number;
        /**
         * Width of box to fill.
         */
        fillWidth?: number;
        /**
         * Height of box to fill.
         */
        fillHeight?: number;
        /**
         * Optional. Blur image.
         */
        blur?: number;
        /**
         * Optional. Apply a background color for transparent images.
         */
        backgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        foregroundLayer?: string;
    };
    url: '/Genres/{name}/Images/{imageType}/{imageIndex}';
};

export type HeadGenreImageByIndexErrors = {
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type HeadGenreImageByIndexError = HeadGenreImageByIndexErrors[keyof HeadGenreImageByIndexErrors];

export type HeadGenreImageByIndexResponses = {
    /**
     * Image stream returned.
     */
    200: Blob | File;
};

export type HeadGenreImageByIndexResponse = HeadGenreImageByIndexResponses[keyof HeadGenreImageByIndexResponses];

export type GetItemImageInfosData = {
    body?: never;
    path: {
        /**
         * Item id.
         */
        itemId: string;
    };
    query?: never;
    url: '/Items/{itemId}/Images';
};

export type GetItemImageInfosErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type GetItemImageInfosError = GetItemImageInfosErrors[keyof GetItemImageInfosErrors];

export type GetItemImageInfosResponses = {
    /**
     * Item images returned.
     */
    200: Array<ImageInfo>;
};

export type GetItemImageInfosResponse = GetItemImageInfosResponses[keyof GetItemImageInfosResponses];

export type DeleteItemImageData = {
    body?: never;
    path: {
        /**
         * Item id.
         */
        itemId: string;
        /**
         * Enum ImageType.
         */
        imageType: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Profile';
    };
    query?: {
        /**
         * The image index.
         */
        imageIndex?: number;
    };
    url: '/Items/{itemId}/Images/{imageType}';
};

export type DeleteItemImageErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type DeleteItemImageError = DeleteItemImageErrors[keyof DeleteItemImageErrors];

export type DeleteItemImageResponses = {
    /**
     * Image deleted.
     */
    204: void;
};

export type DeleteItemImageResponse = DeleteItemImageResponses[keyof DeleteItemImageResponses];

export type GetItemImageData = {
    body?: never;
    path: {
        /**
         * Item id.
         */
        itemId: string;
        /**
         * Enum ImageType.
         */
        imageType: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Profile';
    };
    query?: {
        /**
         * The maximum image width to return.
         */
        maxWidth?: number;
        /**
         * The maximum image height to return.
         */
        maxHeight?: number;
        /**
         * The fixed image width to return.
         */
        width?: number;
        /**
         * The fixed image height to return.
         */
        height?: number;
        /**
         * Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        quality?: number;
        /**
         * Width of box to fill.
         */
        fillWidth?: number;
        /**
         * Height of box to fill.
         */
        fillHeight?: number;
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        tag?: string;
        /**
         * Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.
         */
        format?: 'Bmp' | 'Gif' | 'Jpg' | 'Png' | 'Webp' | 'Svg';
        /**
         * Optional. Percent to render for the percent played overlay.
         */
        percentPlayed?: number;
        /**
         * Optional. Unplayed count overlay to render.
         */
        unplayedCount?: number;
        /**
         * Optional. Blur image.
         */
        blur?: number;
        /**
         * Optional. Apply a background color for transparent images.
         */
        backgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        foregroundLayer?: string;
        /**
         * Image index.
         */
        imageIndex?: number;
    };
    url: '/Items/{itemId}/Images/{imageType}';
};

export type GetItemImageErrors = {
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type GetItemImageError = GetItemImageErrors[keyof GetItemImageErrors];

export type GetItemImageResponses = {
    /**
     * Image stream returned.
     */
    200: Blob | File;
};

export type GetItemImageResponse = GetItemImageResponses[keyof GetItemImageResponses];

export type HeadItemImageData = {
    body?: never;
    path: {
        /**
         * Item id.
         */
        itemId: string;
        /**
         * Enum ImageType.
         */
        imageType: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Profile';
    };
    query?: {
        /**
         * The maximum image width to return.
         */
        maxWidth?: number;
        /**
         * The maximum image height to return.
         */
        maxHeight?: number;
        /**
         * The fixed image width to return.
         */
        width?: number;
        /**
         * The fixed image height to return.
         */
        height?: number;
        /**
         * Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        quality?: number;
        /**
         * Width of box to fill.
         */
        fillWidth?: number;
        /**
         * Height of box to fill.
         */
        fillHeight?: number;
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        tag?: string;
        /**
         * Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.
         */
        format?: 'Bmp' | 'Gif' | 'Jpg' | 'Png' | 'Webp' | 'Svg';
        /**
         * Optional. Percent to render for the percent played overlay.
         */
        percentPlayed?: number;
        /**
         * Optional. Unplayed count overlay to render.
         */
        unplayedCount?: number;
        /**
         * Optional. Blur image.
         */
        blur?: number;
        /**
         * Optional. Apply a background color for transparent images.
         */
        backgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        foregroundLayer?: string;
        /**
         * Image index.
         */
        imageIndex?: number;
    };
    url: '/Items/{itemId}/Images/{imageType}';
};

export type HeadItemImageErrors = {
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type HeadItemImageError = HeadItemImageErrors[keyof HeadItemImageErrors];

export type HeadItemImageResponses = {
    /**
     * Image stream returned.
     */
    200: Blob | File;
};

export type HeadItemImageResponse = HeadItemImageResponses[keyof HeadItemImageResponses];

export type SetItemImageData = {
    body?: Blob | File;
    path: {
        /**
         * Item id.
         */
        itemId: string;
        /**
         * Enum ImageType.
         */
        imageType: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Profile';
    };
    query?: never;
    url: '/Items/{itemId}/Images/{imageType}';
};

export type SetItemImageErrors = {
    /**
     * Bad Request
     */
    400: ProblemDetails;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type SetItemImageError = SetItemImageErrors[keyof SetItemImageErrors];

export type SetItemImageResponses = {
    /**
     * Image saved.
     */
    204: void;
};

export type SetItemImageResponse = SetItemImageResponses[keyof SetItemImageResponses];

export type DeleteItemImageByIndexData = {
    body?: never;
    path: {
        /**
         * Item id.
         */
        itemId: string;
        /**
         * Enum ImageType.
         */
        imageType: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Profile';
        /**
         * The image index.
         */
        imageIndex: number;
    };
    query?: never;
    url: '/Items/{itemId}/Images/{imageType}/{imageIndex}';
};

export type DeleteItemImageByIndexErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type DeleteItemImageByIndexError = DeleteItemImageByIndexErrors[keyof DeleteItemImageByIndexErrors];

export type DeleteItemImageByIndexResponses = {
    /**
     * Image deleted.
     */
    204: void;
};

export type DeleteItemImageByIndexResponse = DeleteItemImageByIndexResponses[keyof DeleteItemImageByIndexResponses];

export type GetItemImageByIndexData = {
    body?: never;
    path: {
        /**
         * Item id.
         */
        itemId: string;
        /**
         * Enum ImageType.
         */
        imageType: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Profile';
        /**
         * Image index.
         */
        imageIndex: number;
    };
    query?: {
        /**
         * The maximum image width to return.
         */
        maxWidth?: number;
        /**
         * The maximum image height to return.
         */
        maxHeight?: number;
        /**
         * The fixed image width to return.
         */
        width?: number;
        /**
         * The fixed image height to return.
         */
        height?: number;
        /**
         * Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        quality?: number;
        /**
         * Width of box to fill.
         */
        fillWidth?: number;
        /**
         * Height of box to fill.
         */
        fillHeight?: number;
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        tag?: string;
        /**
         * Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.
         */
        format?: 'Bmp' | 'Gif' | 'Jpg' | 'Png' | 'Webp' | 'Svg';
        /**
         * Optional. Percent to render for the percent played overlay.
         */
        percentPlayed?: number;
        /**
         * Optional. Unplayed count overlay to render.
         */
        unplayedCount?: number;
        /**
         * Optional. Blur image.
         */
        blur?: number;
        /**
         * Optional. Apply a background color for transparent images.
         */
        backgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        foregroundLayer?: string;
    };
    url: '/Items/{itemId}/Images/{imageType}/{imageIndex}';
};

export type GetItemImageByIndexErrors = {
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type GetItemImageByIndexError = GetItemImageByIndexErrors[keyof GetItemImageByIndexErrors];

export type GetItemImageByIndexResponses = {
    /**
     * Image stream returned.
     */
    200: Blob | File;
};

export type GetItemImageByIndexResponse = GetItemImageByIndexResponses[keyof GetItemImageByIndexResponses];

export type HeadItemImageByIndexData = {
    body?: never;
    path: {
        /**
         * Item id.
         */
        itemId: string;
        /**
         * Enum ImageType.
         */
        imageType: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Profile';
        /**
         * Image index.
         */
        imageIndex: number;
    };
    query?: {
        /**
         * The maximum image width to return.
         */
        maxWidth?: number;
        /**
         * The maximum image height to return.
         */
        maxHeight?: number;
        /**
         * The fixed image width to return.
         */
        width?: number;
        /**
         * The fixed image height to return.
         */
        height?: number;
        /**
         * Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        quality?: number;
        /**
         * Width of box to fill.
         */
        fillWidth?: number;
        /**
         * Height of box to fill.
         */
        fillHeight?: number;
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        tag?: string;
        /**
         * Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.
         */
        format?: 'Bmp' | 'Gif' | 'Jpg' | 'Png' | 'Webp' | 'Svg';
        /**
         * Optional. Percent to render for the percent played overlay.
         */
        percentPlayed?: number;
        /**
         * Optional. Unplayed count overlay to render.
         */
        unplayedCount?: number;
        /**
         * Optional. Blur image.
         */
        blur?: number;
        /**
         * Optional. Apply a background color for transparent images.
         */
        backgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        foregroundLayer?: string;
    };
    url: '/Items/{itemId}/Images/{imageType}/{imageIndex}';
};

export type HeadItemImageByIndexErrors = {
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type HeadItemImageByIndexError = HeadItemImageByIndexErrors[keyof HeadItemImageByIndexErrors];

export type HeadItemImageByIndexResponses = {
    /**
     * Image stream returned.
     */
    200: Blob | File;
};

export type HeadItemImageByIndexResponse = HeadItemImageByIndexResponses[keyof HeadItemImageByIndexResponses];

export type SetItemImageByIndexData = {
    body?: Blob | File;
    path: {
        /**
         * Item id.
         */
        itemId: string;
        /**
         * Enum ImageType.
         */
        imageType: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Profile';
        /**
         * (Unused) Image index.
         */
        imageIndex: number;
    };
    query?: never;
    url: '/Items/{itemId}/Images/{imageType}/{imageIndex}';
};

export type SetItemImageByIndexErrors = {
    /**
     * Bad Request
     */
    400: ProblemDetails;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type SetItemImageByIndexError = SetItemImageByIndexErrors[keyof SetItemImageByIndexErrors];

export type SetItemImageByIndexResponses = {
    /**
     * Image saved.
     */
    204: void;
};

export type SetItemImageByIndexResponse = SetItemImageByIndexResponses[keyof SetItemImageByIndexResponses];

export type GetItemImage2Data = {
    body?: never;
    path: {
        /**
         * Item id.
         */
        itemId: string;
        /**
         * Enum ImageType.
         */
        imageType: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Profile';
        /**
         * The maximum image width to return.
         */
        maxWidth: number;
        /**
         * The maximum image height to return.
         */
        maxHeight: number;
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        tag: string;
        /**
         * Enum ImageOutputFormat.
         */
        format: 'Bmp' | 'Gif' | 'Jpg' | 'Png' | 'Webp' | 'Svg';
        /**
         * Optional. Percent to render for the percent played overlay.
         */
        percentPlayed: number;
        /**
         * Optional. Unplayed count overlay to render.
         */
        unplayedCount: number;
        /**
         * Image index.
         */
        imageIndex: number;
    };
    query?: {
        /**
         * The fixed image width to return.
         */
        width?: number;
        /**
         * The fixed image height to return.
         */
        height?: number;
        /**
         * Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        quality?: number;
        /**
         * Width of box to fill.
         */
        fillWidth?: number;
        /**
         * Height of box to fill.
         */
        fillHeight?: number;
        /**
         * Optional. Blur image.
         */
        blur?: number;
        /**
         * Optional. Apply a background color for transparent images.
         */
        backgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        foregroundLayer?: string;
    };
    url: '/Items/{itemId}/Images/{imageType}/{imageIndex}/{tag}/{format}/{maxWidth}/{maxHeight}/{percentPlayed}/{unplayedCount}';
};

export type GetItemImage2Errors = {
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type GetItemImage2Error = GetItemImage2Errors[keyof GetItemImage2Errors];

export type GetItemImage2Responses = {
    /**
     * Image stream returned.
     */
    200: Blob | File;
};

export type GetItemImage2Response = GetItemImage2Responses[keyof GetItemImage2Responses];

export type HeadItemImage2Data = {
    body?: never;
    path: {
        /**
         * Item id.
         */
        itemId: string;
        /**
         * Enum ImageType.
         */
        imageType: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Profile';
        /**
         * The maximum image width to return.
         */
        maxWidth: number;
        /**
         * The maximum image height to return.
         */
        maxHeight: number;
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        tag: string;
        /**
         * Enum ImageOutputFormat.
         */
        format: 'Bmp' | 'Gif' | 'Jpg' | 'Png' | 'Webp' | 'Svg';
        /**
         * Optional. Percent to render for the percent played overlay.
         */
        percentPlayed: number;
        /**
         * Optional. Unplayed count overlay to render.
         */
        unplayedCount: number;
        /**
         * Image index.
         */
        imageIndex: number;
    };
    query?: {
        /**
         * The fixed image width to return.
         */
        width?: number;
        /**
         * The fixed image height to return.
         */
        height?: number;
        /**
         * Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        quality?: number;
        /**
         * Width of box to fill.
         */
        fillWidth?: number;
        /**
         * Height of box to fill.
         */
        fillHeight?: number;
        /**
         * Optional. Blur image.
         */
        blur?: number;
        /**
         * Optional. Apply a background color for transparent images.
         */
        backgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        foregroundLayer?: string;
    };
    url: '/Items/{itemId}/Images/{imageType}/{imageIndex}/{tag}/{format}/{maxWidth}/{maxHeight}/{percentPlayed}/{unplayedCount}';
};

export type HeadItemImage2Errors = {
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type HeadItemImage2Error = HeadItemImage2Errors[keyof HeadItemImage2Errors];

export type HeadItemImage2Responses = {
    /**
     * Image stream returned.
     */
    200: Blob | File;
};

export type HeadItemImage2Response = HeadItemImage2Responses[keyof HeadItemImage2Responses];

export type UpdateItemImageIndexData = {
    body?: never;
    path: {
        /**
         * Item id.
         */
        itemId: string;
        /**
         * Enum ImageType.
         */
        imageType: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Profile';
        /**
         * Old image index.
         */
        imageIndex: number;
    };
    query: {
        /**
         * New image index.
         */
        newIndex: number;
    };
    url: '/Items/{itemId}/Images/{imageType}/{imageIndex}/Index';
};

export type UpdateItemImageIndexErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type UpdateItemImageIndexError = UpdateItemImageIndexErrors[keyof UpdateItemImageIndexErrors];

export type UpdateItemImageIndexResponses = {
    /**
     * Image index updated.
     */
    204: void;
};

export type UpdateItemImageIndexResponse = UpdateItemImageIndexResponses[keyof UpdateItemImageIndexResponses];

export type GetMusicGenreImageData = {
    body?: never;
    path: {
        /**
         * Music genre name.
         */
        name: string;
        /**
         * Enum ImageType.
         */
        imageType: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Profile';
    };
    query?: {
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        tag?: string;
        /**
         * Determines the output format of the image - original,gif,jpg,png.
         */
        format?: 'Bmp' | 'Gif' | 'Jpg' | 'Png' | 'Webp' | 'Svg';
        /**
         * The maximum image width to return.
         */
        maxWidth?: number;
        /**
         * The maximum image height to return.
         */
        maxHeight?: number;
        /**
         * Optional. Percent to render for the percent played overlay.
         */
        percentPlayed?: number;
        /**
         * Optional. Unplayed count overlay to render.
         */
        unplayedCount?: number;
        /**
         * The fixed image width to return.
         */
        width?: number;
        /**
         * The fixed image height to return.
         */
        height?: number;
        /**
         * Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        quality?: number;
        /**
         * Width of box to fill.
         */
        fillWidth?: number;
        /**
         * Height of box to fill.
         */
        fillHeight?: number;
        /**
         * Optional. Blur image.
         */
        blur?: number;
        /**
         * Optional. Apply a background color for transparent images.
         */
        backgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        foregroundLayer?: string;
        /**
         * Image index.
         */
        imageIndex?: number;
    };
    url: '/MusicGenres/{name}/Images/{imageType}';
};

export type GetMusicGenreImageErrors = {
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type GetMusicGenreImageError = GetMusicGenreImageErrors[keyof GetMusicGenreImageErrors];

export type GetMusicGenreImageResponses = {
    /**
     * Image stream returned.
     */
    200: Blob | File;
};

export type GetMusicGenreImageResponse = GetMusicGenreImageResponses[keyof GetMusicGenreImageResponses];

export type HeadMusicGenreImageData = {
    body?: never;
    path: {
        /**
         * Music genre name.
         */
        name: string;
        /**
         * Enum ImageType.
         */
        imageType: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Profile';
    };
    query?: {
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        tag?: string;
        /**
         * Determines the output format of the image - original,gif,jpg,png.
         */
        format?: 'Bmp' | 'Gif' | 'Jpg' | 'Png' | 'Webp' | 'Svg';
        /**
         * The maximum image width to return.
         */
        maxWidth?: number;
        /**
         * The maximum image height to return.
         */
        maxHeight?: number;
        /**
         * Optional. Percent to render for the percent played overlay.
         */
        percentPlayed?: number;
        /**
         * Optional. Unplayed count overlay to render.
         */
        unplayedCount?: number;
        /**
         * The fixed image width to return.
         */
        width?: number;
        /**
         * The fixed image height to return.
         */
        height?: number;
        /**
         * Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        quality?: number;
        /**
         * Width of box to fill.
         */
        fillWidth?: number;
        /**
         * Height of box to fill.
         */
        fillHeight?: number;
        /**
         * Optional. Blur image.
         */
        blur?: number;
        /**
         * Optional. Apply a background color for transparent images.
         */
        backgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        foregroundLayer?: string;
        /**
         * Image index.
         */
        imageIndex?: number;
    };
    url: '/MusicGenres/{name}/Images/{imageType}';
};

export type HeadMusicGenreImageErrors = {
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type HeadMusicGenreImageError = HeadMusicGenreImageErrors[keyof HeadMusicGenreImageErrors];

export type HeadMusicGenreImageResponses = {
    /**
     * Image stream returned.
     */
    200: Blob | File;
};

export type HeadMusicGenreImageResponse = HeadMusicGenreImageResponses[keyof HeadMusicGenreImageResponses];

export type GetMusicGenreImageByIndexData = {
    body?: never;
    path: {
        /**
         * Music genre name.
         */
        name: string;
        /**
         * Enum ImageType.
         */
        imageType: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Profile';
        /**
         * Image index.
         */
        imageIndex: number;
    };
    query?: {
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        tag?: string;
        /**
         * Determines the output format of the image - original,gif,jpg,png.
         */
        format?: 'Bmp' | 'Gif' | 'Jpg' | 'Png' | 'Webp' | 'Svg';
        /**
         * The maximum image width to return.
         */
        maxWidth?: number;
        /**
         * The maximum image height to return.
         */
        maxHeight?: number;
        /**
         * Optional. Percent to render for the percent played overlay.
         */
        percentPlayed?: number;
        /**
         * Optional. Unplayed count overlay to render.
         */
        unplayedCount?: number;
        /**
         * The fixed image width to return.
         */
        width?: number;
        /**
         * The fixed image height to return.
         */
        height?: number;
        /**
         * Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        quality?: number;
        /**
         * Width of box to fill.
         */
        fillWidth?: number;
        /**
         * Height of box to fill.
         */
        fillHeight?: number;
        /**
         * Optional. Blur image.
         */
        blur?: number;
        /**
         * Optional. Apply a background color for transparent images.
         */
        backgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        foregroundLayer?: string;
    };
    url: '/MusicGenres/{name}/Images/{imageType}/{imageIndex}';
};

export type GetMusicGenreImageByIndexErrors = {
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type GetMusicGenreImageByIndexError = GetMusicGenreImageByIndexErrors[keyof GetMusicGenreImageByIndexErrors];

export type GetMusicGenreImageByIndexResponses = {
    /**
     * Image stream returned.
     */
    200: Blob | File;
};

export type GetMusicGenreImageByIndexResponse = GetMusicGenreImageByIndexResponses[keyof GetMusicGenreImageByIndexResponses];

export type HeadMusicGenreImageByIndexData = {
    body?: never;
    path: {
        /**
         * Music genre name.
         */
        name: string;
        /**
         * Enum ImageType.
         */
        imageType: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Profile';
        /**
         * Image index.
         */
        imageIndex: number;
    };
    query?: {
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        tag?: string;
        /**
         * Determines the output format of the image - original,gif,jpg,png.
         */
        format?: 'Bmp' | 'Gif' | 'Jpg' | 'Png' | 'Webp' | 'Svg';
        /**
         * The maximum image width to return.
         */
        maxWidth?: number;
        /**
         * The maximum image height to return.
         */
        maxHeight?: number;
        /**
         * Optional. Percent to render for the percent played overlay.
         */
        percentPlayed?: number;
        /**
         * Optional. Unplayed count overlay to render.
         */
        unplayedCount?: number;
        /**
         * The fixed image width to return.
         */
        width?: number;
        /**
         * The fixed image height to return.
         */
        height?: number;
        /**
         * Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        quality?: number;
        /**
         * Width of box to fill.
         */
        fillWidth?: number;
        /**
         * Height of box to fill.
         */
        fillHeight?: number;
        /**
         * Optional. Blur image.
         */
        blur?: number;
        /**
         * Optional. Apply a background color for transparent images.
         */
        backgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        foregroundLayer?: string;
    };
    url: '/MusicGenres/{name}/Images/{imageType}/{imageIndex}';
};

export type HeadMusicGenreImageByIndexErrors = {
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type HeadMusicGenreImageByIndexError = HeadMusicGenreImageByIndexErrors[keyof HeadMusicGenreImageByIndexErrors];

export type HeadMusicGenreImageByIndexResponses = {
    /**
     * Image stream returned.
     */
    200: Blob | File;
};

export type HeadMusicGenreImageByIndexResponse = HeadMusicGenreImageByIndexResponses[keyof HeadMusicGenreImageByIndexResponses];

export type GetPersonImageData = {
    body?: never;
    path: {
        /**
         * Person name.
         */
        name: string;
        /**
         * Enum ImageType.
         */
        imageType: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Profile';
    };
    query?: {
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        tag?: string;
        /**
         * Determines the output format of the image - original,gif,jpg,png.
         */
        format?: 'Bmp' | 'Gif' | 'Jpg' | 'Png' | 'Webp' | 'Svg';
        /**
         * The maximum image width to return.
         */
        maxWidth?: number;
        /**
         * The maximum image height to return.
         */
        maxHeight?: number;
        /**
         * Optional. Percent to render for the percent played overlay.
         */
        percentPlayed?: number;
        /**
         * Optional. Unplayed count overlay to render.
         */
        unplayedCount?: number;
        /**
         * The fixed image width to return.
         */
        width?: number;
        /**
         * The fixed image height to return.
         */
        height?: number;
        /**
         * Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        quality?: number;
        /**
         * Width of box to fill.
         */
        fillWidth?: number;
        /**
         * Height of box to fill.
         */
        fillHeight?: number;
        /**
         * Optional. Blur image.
         */
        blur?: number;
        /**
         * Optional. Apply a background color for transparent images.
         */
        backgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        foregroundLayer?: string;
        /**
         * Image index.
         */
        imageIndex?: number;
    };
    url: '/Persons/{name}/Images/{imageType}';
};

export type GetPersonImageErrors = {
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type GetPersonImageError = GetPersonImageErrors[keyof GetPersonImageErrors];

export type GetPersonImageResponses = {
    /**
     * Image stream returned.
     */
    200: Blob | File;
};

export type GetPersonImageResponse = GetPersonImageResponses[keyof GetPersonImageResponses];

export type HeadPersonImageData = {
    body?: never;
    path: {
        /**
         * Person name.
         */
        name: string;
        /**
         * Enum ImageType.
         */
        imageType: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Profile';
    };
    query?: {
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        tag?: string;
        /**
         * Determines the output format of the image - original,gif,jpg,png.
         */
        format?: 'Bmp' | 'Gif' | 'Jpg' | 'Png' | 'Webp' | 'Svg';
        /**
         * The maximum image width to return.
         */
        maxWidth?: number;
        /**
         * The maximum image height to return.
         */
        maxHeight?: number;
        /**
         * Optional. Percent to render for the percent played overlay.
         */
        percentPlayed?: number;
        /**
         * Optional. Unplayed count overlay to render.
         */
        unplayedCount?: number;
        /**
         * The fixed image width to return.
         */
        width?: number;
        /**
         * The fixed image height to return.
         */
        height?: number;
        /**
         * Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        quality?: number;
        /**
         * Width of box to fill.
         */
        fillWidth?: number;
        /**
         * Height of box to fill.
         */
        fillHeight?: number;
        /**
         * Optional. Blur image.
         */
        blur?: number;
        /**
         * Optional. Apply a background color for transparent images.
         */
        backgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        foregroundLayer?: string;
        /**
         * Image index.
         */
        imageIndex?: number;
    };
    url: '/Persons/{name}/Images/{imageType}';
};

export type HeadPersonImageErrors = {
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type HeadPersonImageError = HeadPersonImageErrors[keyof HeadPersonImageErrors];

export type HeadPersonImageResponses = {
    /**
     * Image stream returned.
     */
    200: Blob | File;
};

export type HeadPersonImageResponse = HeadPersonImageResponses[keyof HeadPersonImageResponses];

export type GetPersonImageByIndexData = {
    body?: never;
    path: {
        /**
         * Person name.
         */
        name: string;
        /**
         * Enum ImageType.
         */
        imageType: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Profile';
        /**
         * Image index.
         */
        imageIndex: number;
    };
    query?: {
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        tag?: string;
        /**
         * Determines the output format of the image - original,gif,jpg,png.
         */
        format?: 'Bmp' | 'Gif' | 'Jpg' | 'Png' | 'Webp' | 'Svg';
        /**
         * The maximum image width to return.
         */
        maxWidth?: number;
        /**
         * The maximum image height to return.
         */
        maxHeight?: number;
        /**
         * Optional. Percent to render for the percent played overlay.
         */
        percentPlayed?: number;
        /**
         * Optional. Unplayed count overlay to render.
         */
        unplayedCount?: number;
        /**
         * The fixed image width to return.
         */
        width?: number;
        /**
         * The fixed image height to return.
         */
        height?: number;
        /**
         * Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        quality?: number;
        /**
         * Width of box to fill.
         */
        fillWidth?: number;
        /**
         * Height of box to fill.
         */
        fillHeight?: number;
        /**
         * Optional. Blur image.
         */
        blur?: number;
        /**
         * Optional. Apply a background color for transparent images.
         */
        backgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        foregroundLayer?: string;
    };
    url: '/Persons/{name}/Images/{imageType}/{imageIndex}';
};

export type GetPersonImageByIndexErrors = {
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type GetPersonImageByIndexError = GetPersonImageByIndexErrors[keyof GetPersonImageByIndexErrors];

export type GetPersonImageByIndexResponses = {
    /**
     * Image stream returned.
     */
    200: Blob | File;
};

export type GetPersonImageByIndexResponse = GetPersonImageByIndexResponses[keyof GetPersonImageByIndexResponses];

export type HeadPersonImageByIndexData = {
    body?: never;
    path: {
        /**
         * Person name.
         */
        name: string;
        /**
         * Enum ImageType.
         */
        imageType: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Profile';
        /**
         * Image index.
         */
        imageIndex: number;
    };
    query?: {
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        tag?: string;
        /**
         * Determines the output format of the image - original,gif,jpg,png.
         */
        format?: 'Bmp' | 'Gif' | 'Jpg' | 'Png' | 'Webp' | 'Svg';
        /**
         * The maximum image width to return.
         */
        maxWidth?: number;
        /**
         * The maximum image height to return.
         */
        maxHeight?: number;
        /**
         * Optional. Percent to render for the percent played overlay.
         */
        percentPlayed?: number;
        /**
         * Optional. Unplayed count overlay to render.
         */
        unplayedCount?: number;
        /**
         * The fixed image width to return.
         */
        width?: number;
        /**
         * The fixed image height to return.
         */
        height?: number;
        /**
         * Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        quality?: number;
        /**
         * Width of box to fill.
         */
        fillWidth?: number;
        /**
         * Height of box to fill.
         */
        fillHeight?: number;
        /**
         * Optional. Blur image.
         */
        blur?: number;
        /**
         * Optional. Apply a background color for transparent images.
         */
        backgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        foregroundLayer?: string;
    };
    url: '/Persons/{name}/Images/{imageType}/{imageIndex}';
};

export type HeadPersonImageByIndexErrors = {
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type HeadPersonImageByIndexError = HeadPersonImageByIndexErrors[keyof HeadPersonImageByIndexErrors];

export type HeadPersonImageByIndexResponses = {
    /**
     * Image stream returned.
     */
    200: Blob | File;
};

export type HeadPersonImageByIndexResponse = HeadPersonImageByIndexResponses[keyof HeadPersonImageByIndexResponses];

export type GetStudioImageData = {
    body?: never;
    path: {
        /**
         * Studio name.
         */
        name: string;
        /**
         * Enum ImageType.
         */
        imageType: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Profile';
    };
    query?: {
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        tag?: string;
        /**
         * Determines the output format of the image - original,gif,jpg,png.
         */
        format?: 'Bmp' | 'Gif' | 'Jpg' | 'Png' | 'Webp' | 'Svg';
        /**
         * The maximum image width to return.
         */
        maxWidth?: number;
        /**
         * The maximum image height to return.
         */
        maxHeight?: number;
        /**
         * Optional. Percent to render for the percent played overlay.
         */
        percentPlayed?: number;
        /**
         * Optional. Unplayed count overlay to render.
         */
        unplayedCount?: number;
        /**
         * The fixed image width to return.
         */
        width?: number;
        /**
         * The fixed image height to return.
         */
        height?: number;
        /**
         * Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        quality?: number;
        /**
         * Width of box to fill.
         */
        fillWidth?: number;
        /**
         * Height of box to fill.
         */
        fillHeight?: number;
        /**
         * Optional. Blur image.
         */
        blur?: number;
        /**
         * Optional. Apply a background color for transparent images.
         */
        backgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        foregroundLayer?: string;
        /**
         * Image index.
         */
        imageIndex?: number;
    };
    url: '/Studios/{name}/Images/{imageType}';
};

export type GetStudioImageErrors = {
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type GetStudioImageError = GetStudioImageErrors[keyof GetStudioImageErrors];

export type GetStudioImageResponses = {
    /**
     * Image stream returned.
     */
    200: Blob | File;
};

export type GetStudioImageResponse = GetStudioImageResponses[keyof GetStudioImageResponses];

export type HeadStudioImageData = {
    body?: never;
    path: {
        /**
         * Studio name.
         */
        name: string;
        /**
         * Enum ImageType.
         */
        imageType: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Profile';
    };
    query?: {
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        tag?: string;
        /**
         * Determines the output format of the image - original,gif,jpg,png.
         */
        format?: 'Bmp' | 'Gif' | 'Jpg' | 'Png' | 'Webp' | 'Svg';
        /**
         * The maximum image width to return.
         */
        maxWidth?: number;
        /**
         * The maximum image height to return.
         */
        maxHeight?: number;
        /**
         * Optional. Percent to render for the percent played overlay.
         */
        percentPlayed?: number;
        /**
         * Optional. Unplayed count overlay to render.
         */
        unplayedCount?: number;
        /**
         * The fixed image width to return.
         */
        width?: number;
        /**
         * The fixed image height to return.
         */
        height?: number;
        /**
         * Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        quality?: number;
        /**
         * Width of box to fill.
         */
        fillWidth?: number;
        /**
         * Height of box to fill.
         */
        fillHeight?: number;
        /**
         * Optional. Blur image.
         */
        blur?: number;
        /**
         * Optional. Apply a background color for transparent images.
         */
        backgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        foregroundLayer?: string;
        /**
         * Image index.
         */
        imageIndex?: number;
    };
    url: '/Studios/{name}/Images/{imageType}';
};

export type HeadStudioImageErrors = {
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type HeadStudioImageError = HeadStudioImageErrors[keyof HeadStudioImageErrors];

export type HeadStudioImageResponses = {
    /**
     * Image stream returned.
     */
    200: Blob | File;
};

export type HeadStudioImageResponse = HeadStudioImageResponses[keyof HeadStudioImageResponses];

export type GetStudioImageByIndexData = {
    body?: never;
    path: {
        /**
         * Studio name.
         */
        name: string;
        /**
         * Enum ImageType.
         */
        imageType: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Profile';
        /**
         * Image index.
         */
        imageIndex: number;
    };
    query?: {
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        tag?: string;
        /**
         * Determines the output format of the image - original,gif,jpg,png.
         */
        format?: 'Bmp' | 'Gif' | 'Jpg' | 'Png' | 'Webp' | 'Svg';
        /**
         * The maximum image width to return.
         */
        maxWidth?: number;
        /**
         * The maximum image height to return.
         */
        maxHeight?: number;
        /**
         * Optional. Percent to render for the percent played overlay.
         */
        percentPlayed?: number;
        /**
         * Optional. Unplayed count overlay to render.
         */
        unplayedCount?: number;
        /**
         * The fixed image width to return.
         */
        width?: number;
        /**
         * The fixed image height to return.
         */
        height?: number;
        /**
         * Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        quality?: number;
        /**
         * Width of box to fill.
         */
        fillWidth?: number;
        /**
         * Height of box to fill.
         */
        fillHeight?: number;
        /**
         * Optional. Blur image.
         */
        blur?: number;
        /**
         * Optional. Apply a background color for transparent images.
         */
        backgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        foregroundLayer?: string;
    };
    url: '/Studios/{name}/Images/{imageType}/{imageIndex}';
};

export type GetStudioImageByIndexErrors = {
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type GetStudioImageByIndexError = GetStudioImageByIndexErrors[keyof GetStudioImageByIndexErrors];

export type GetStudioImageByIndexResponses = {
    /**
     * Image stream returned.
     */
    200: Blob | File;
};

export type GetStudioImageByIndexResponse = GetStudioImageByIndexResponses[keyof GetStudioImageByIndexResponses];

export type HeadStudioImageByIndexData = {
    body?: never;
    path: {
        /**
         * Studio name.
         */
        name: string;
        /**
         * Enum ImageType.
         */
        imageType: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Profile';
        /**
         * Image index.
         */
        imageIndex: number;
    };
    query?: {
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        tag?: string;
        /**
         * Determines the output format of the image - original,gif,jpg,png.
         */
        format?: 'Bmp' | 'Gif' | 'Jpg' | 'Png' | 'Webp' | 'Svg';
        /**
         * The maximum image width to return.
         */
        maxWidth?: number;
        /**
         * The maximum image height to return.
         */
        maxHeight?: number;
        /**
         * Optional. Percent to render for the percent played overlay.
         */
        percentPlayed?: number;
        /**
         * Optional. Unplayed count overlay to render.
         */
        unplayedCount?: number;
        /**
         * The fixed image width to return.
         */
        width?: number;
        /**
         * The fixed image height to return.
         */
        height?: number;
        /**
         * Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        quality?: number;
        /**
         * Width of box to fill.
         */
        fillWidth?: number;
        /**
         * Height of box to fill.
         */
        fillHeight?: number;
        /**
         * Optional. Blur image.
         */
        blur?: number;
        /**
         * Optional. Apply a background color for transparent images.
         */
        backgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        foregroundLayer?: string;
    };
    url: '/Studios/{name}/Images/{imageType}/{imageIndex}';
};

export type HeadStudioImageByIndexErrors = {
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type HeadStudioImageByIndexError = HeadStudioImageByIndexErrors[keyof HeadStudioImageByIndexErrors];

export type HeadStudioImageByIndexResponses = {
    /**
     * Image stream returned.
     */
    200: Blob | File;
};

export type HeadStudioImageByIndexResponse = HeadStudioImageByIndexResponses[keyof HeadStudioImageByIndexResponses];

export type DeleteUserImageData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * User Id.
         */
        userId?: string;
    };
    url: '/UserImage';
};

export type DeleteUserImageErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * User does not have permission to delete the image.
     */
    403: ProblemDetails;
};

export type DeleteUserImageError = DeleteUserImageErrors[keyof DeleteUserImageErrors];

export type DeleteUserImageResponses = {
    /**
     * Image deleted.
     */
    204: void;
};

export type DeleteUserImageResponse = DeleteUserImageResponses[keyof DeleteUserImageResponses];

export type GetUserImageData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * User id.
         */
        userId?: string;
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        tag?: string;
        /**
         * Determines the output format of the image - original,gif,jpg,png.
         */
        format?: 'Bmp' | 'Gif' | 'Jpg' | 'Png' | 'Webp' | 'Svg';
        /**
         * The maximum image width to return.
         */
        maxWidth?: number;
        /**
         * The maximum image height to return.
         */
        maxHeight?: number;
        /**
         * Optional. Percent to render for the percent played overlay.
         */
        percentPlayed?: number;
        /**
         * Optional. Unplayed count overlay to render.
         */
        unplayedCount?: number;
        /**
         * The fixed image width to return.
         */
        width?: number;
        /**
         * The fixed image height to return.
         */
        height?: number;
        /**
         * Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        quality?: number;
        /**
         * Width of box to fill.
         */
        fillWidth?: number;
        /**
         * Height of box to fill.
         */
        fillHeight?: number;
        /**
         * Optional. Blur image.
         */
        blur?: number;
        /**
         * Optional. Apply a background color for transparent images.
         */
        backgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        foregroundLayer?: string;
        /**
         * Image index.
         */
        imageIndex?: number;
    };
    url: '/UserImage';
};

export type GetUserImageErrors = {
    /**
     * User id not provided.
     */
    400: ProblemDetails;
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type GetUserImageError = GetUserImageErrors[keyof GetUserImageErrors];

export type GetUserImageResponses = {
    /**
     * Image stream returned.
     */
    200: Blob | File;
};

export type GetUserImageResponse = GetUserImageResponses[keyof GetUserImageResponses];

export type HeadUserImageData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * User id.
         */
        userId?: string;
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        tag?: string;
        /**
         * Determines the output format of the image - original,gif,jpg,png.
         */
        format?: 'Bmp' | 'Gif' | 'Jpg' | 'Png' | 'Webp' | 'Svg';
        /**
         * The maximum image width to return.
         */
        maxWidth?: number;
        /**
         * The maximum image height to return.
         */
        maxHeight?: number;
        /**
         * Optional. Percent to render for the percent played overlay.
         */
        percentPlayed?: number;
        /**
         * Optional. Unplayed count overlay to render.
         */
        unplayedCount?: number;
        /**
         * The fixed image width to return.
         */
        width?: number;
        /**
         * The fixed image height to return.
         */
        height?: number;
        /**
         * Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        quality?: number;
        /**
         * Width of box to fill.
         */
        fillWidth?: number;
        /**
         * Height of box to fill.
         */
        fillHeight?: number;
        /**
         * Optional. Blur image.
         */
        blur?: number;
        /**
         * Optional. Apply a background color for transparent images.
         */
        backgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        foregroundLayer?: string;
        /**
         * Image index.
         */
        imageIndex?: number;
    };
    url: '/UserImage';
};

export type HeadUserImageErrors = {
    /**
     * User id not provided.
     */
    400: ProblemDetails;
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type HeadUserImageError = HeadUserImageErrors[keyof HeadUserImageErrors];

export type HeadUserImageResponses = {
    /**
     * Image stream returned.
     */
    200: Blob | File;
};

export type HeadUserImageResponse = HeadUserImageResponses[keyof HeadUserImageResponses];

export type PostUserImageData = {
    body?: Blob | File;
    path?: never;
    query?: {
        /**
         * User Id.
         */
        userId?: string;
    };
    url: '/UserImage';
};

export type PostUserImageErrors = {
    /**
     * Bad Request
     */
    400: ProblemDetails;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * User does not have permission to delete the image.
     */
    403: ProblemDetails;
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type PostUserImageError = PostUserImageErrors[keyof PostUserImageErrors];

export type PostUserImageResponses = {
    /**
     * Image updated.
     */
    204: void;
};

export type PostUserImageResponse = PostUserImageResponses[keyof PostUserImageResponses];

export type GetInstantMixFromAlbumData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
    };
    query?: {
        /**
         * Optional. Filter by user id, and attach user data.
         */
        userId?: string;
        /**
         * Optional. The maximum number of records to return.
         */
        limit?: number;
        /**
         * Optional. Specify additional fields of information to return in the output.
         */
        fields?: Array<ItemFields>;
        /**
         * Optional. Include image information in output.
         */
        enableImages?: boolean;
        /**
         * Optional. Include user data.
         */
        enableUserData?: boolean;
        /**
         * Optional. The max number of images to return, per image type.
         */
        imageTypeLimit?: number;
        /**
         * Optional. The image types to include in the output.
         */
        enableImageTypes?: Array<ImageType>;
    };
    url: '/Albums/{itemId}/InstantMix';
};

export type GetInstantMixFromAlbumErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type GetInstantMixFromAlbumError = GetInstantMixFromAlbumErrors[keyof GetInstantMixFromAlbumErrors];

export type GetInstantMixFromAlbumResponses = {
    /**
     * Instant playlist returned.
     */
    200: BaseItemDtoQueryResult;
};

export type GetInstantMixFromAlbumResponse = GetInstantMixFromAlbumResponses[keyof GetInstantMixFromAlbumResponses];

export type GetInstantMixFromArtistsData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
    };
    query?: {
        /**
         * Optional. Filter by user id, and attach user data.
         */
        userId?: string;
        /**
         * Optional. The maximum number of records to return.
         */
        limit?: number;
        /**
         * Optional. Specify additional fields of information to return in the output.
         */
        fields?: Array<ItemFields>;
        /**
         * Optional. Include image information in output.
         */
        enableImages?: boolean;
        /**
         * Optional. Include user data.
         */
        enableUserData?: boolean;
        /**
         * Optional. The max number of images to return, per image type.
         */
        imageTypeLimit?: number;
        /**
         * Optional. The image types to include in the output.
         */
        enableImageTypes?: Array<ImageType>;
    };
    url: '/Artists/{itemId}/InstantMix';
};

export type GetInstantMixFromArtistsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type GetInstantMixFromArtistsError = GetInstantMixFromArtistsErrors[keyof GetInstantMixFromArtistsErrors];

export type GetInstantMixFromArtistsResponses = {
    /**
     * Instant playlist returned.
     */
    200: BaseItemDtoQueryResult;
};

export type GetInstantMixFromArtistsResponse = GetInstantMixFromArtistsResponses[keyof GetInstantMixFromArtistsResponses];

export type GetInstantMixFromArtists2Data = {
    body?: never;
    path?: never;
    query: {
        /**
         * The item id.
         */
        id: string;
        /**
         * Optional. Filter by user id, and attach user data.
         */
        userId?: string;
        /**
         * Optional. The maximum number of records to return.
         */
        limit?: number;
        /**
         * Optional. Specify additional fields of information to return in the output.
         */
        fields?: Array<ItemFields>;
        /**
         * Optional. Include image information in output.
         */
        enableImages?: boolean;
        /**
         * Optional. Include user data.
         */
        enableUserData?: boolean;
        /**
         * Optional. The max number of images to return, per image type.
         */
        imageTypeLimit?: number;
        /**
         * Optional. The image types to include in the output.
         */
        enableImageTypes?: Array<ImageType>;
    };
    url: '/Artists/InstantMix';
};

export type GetInstantMixFromArtists2Errors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type GetInstantMixFromArtists2Error = GetInstantMixFromArtists2Errors[keyof GetInstantMixFromArtists2Errors];

export type GetInstantMixFromArtists2Responses = {
    /**
     * Instant playlist returned.
     */
    200: BaseItemDtoQueryResult;
};

export type GetInstantMixFromArtists2Response = GetInstantMixFromArtists2Responses[keyof GetInstantMixFromArtists2Responses];

export type GetInstantMixFromItemData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
    };
    query?: {
        /**
         * Optional. Filter by user id, and attach user data.
         */
        userId?: string;
        /**
         * Optional. The maximum number of records to return.
         */
        limit?: number;
        /**
         * Optional. Specify additional fields of information to return in the output.
         */
        fields?: Array<ItemFields>;
        /**
         * Optional. Include image information in output.
         */
        enableImages?: boolean;
        /**
         * Optional. Include user data.
         */
        enableUserData?: boolean;
        /**
         * Optional. The max number of images to return, per image type.
         */
        imageTypeLimit?: number;
        /**
         * Optional. The image types to include in the output.
         */
        enableImageTypes?: Array<ImageType>;
    };
    url: '/Items/{itemId}/InstantMix';
};

export type GetInstantMixFromItemErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type GetInstantMixFromItemError = GetInstantMixFromItemErrors[keyof GetInstantMixFromItemErrors];

export type GetInstantMixFromItemResponses = {
    /**
     * Instant playlist returned.
     */
    200: BaseItemDtoQueryResult;
};

export type GetInstantMixFromItemResponse = GetInstantMixFromItemResponses[keyof GetInstantMixFromItemResponses];

export type GetInstantMixFromMusicGenreByNameData = {
    body?: never;
    path: {
        /**
         * The genre name.
         */
        name: string;
    };
    query?: {
        /**
         * Optional. Filter by user id, and attach user data.
         */
        userId?: string;
        /**
         * Optional. The maximum number of records to return.
         */
        limit?: number;
        /**
         * Optional. Specify additional fields of information to return in the output.
         */
        fields?: Array<ItemFields>;
        /**
         * Optional. Include image information in output.
         */
        enableImages?: boolean;
        /**
         * Optional. Include user data.
         */
        enableUserData?: boolean;
        /**
         * Optional. The max number of images to return, per image type.
         */
        imageTypeLimit?: number;
        /**
         * Optional. The image types to include in the output.
         */
        enableImageTypes?: Array<ImageType>;
    };
    url: '/MusicGenres/{name}/InstantMix';
};

export type GetInstantMixFromMusicGenreByNameErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetInstantMixFromMusicGenreByNameResponses = {
    /**
     * Instant playlist returned.
     */
    200: BaseItemDtoQueryResult;
};

export type GetInstantMixFromMusicGenreByNameResponse = GetInstantMixFromMusicGenreByNameResponses[keyof GetInstantMixFromMusicGenreByNameResponses];

export type GetInstantMixFromMusicGenreByIdData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The item id.
         */
        id: string;
        /**
         * Optional. Filter by user id, and attach user data.
         */
        userId?: string;
        /**
         * Optional. The maximum number of records to return.
         */
        limit?: number;
        /**
         * Optional. Specify additional fields of information to return in the output.
         */
        fields?: Array<ItemFields>;
        /**
         * Optional. Include image information in output.
         */
        enableImages?: boolean;
        /**
         * Optional. Include user data.
         */
        enableUserData?: boolean;
        /**
         * Optional. The max number of images to return, per image type.
         */
        imageTypeLimit?: number;
        /**
         * Optional. The image types to include in the output.
         */
        enableImageTypes?: Array<ImageType>;
    };
    url: '/MusicGenres/InstantMix';
};

export type GetInstantMixFromMusicGenreByIdErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type GetInstantMixFromMusicGenreByIdError = GetInstantMixFromMusicGenreByIdErrors[keyof GetInstantMixFromMusicGenreByIdErrors];

export type GetInstantMixFromMusicGenreByIdResponses = {
    /**
     * Instant playlist returned.
     */
    200: BaseItemDtoQueryResult;
};

export type GetInstantMixFromMusicGenreByIdResponse = GetInstantMixFromMusicGenreByIdResponses[keyof GetInstantMixFromMusicGenreByIdResponses];

export type GetInstantMixFromPlaylistData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
    };
    query?: {
        /**
         * Optional. Filter by user id, and attach user data.
         */
        userId?: string;
        /**
         * Optional. The maximum number of records to return.
         */
        limit?: number;
        /**
         * Optional. Specify additional fields of information to return in the output.
         */
        fields?: Array<ItemFields>;
        /**
         * Optional. Include image information in output.
         */
        enableImages?: boolean;
        /**
         * Optional. Include user data.
         */
        enableUserData?: boolean;
        /**
         * Optional. The max number of images to return, per image type.
         */
        imageTypeLimit?: number;
        /**
         * Optional. The image types to include in the output.
         */
        enableImageTypes?: Array<ImageType>;
    };
    url: '/Playlists/{itemId}/InstantMix';
};

export type GetInstantMixFromPlaylistErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type GetInstantMixFromPlaylistError = GetInstantMixFromPlaylistErrors[keyof GetInstantMixFromPlaylistErrors];

export type GetInstantMixFromPlaylistResponses = {
    /**
     * Instant playlist returned.
     */
    200: BaseItemDtoQueryResult;
};

export type GetInstantMixFromPlaylistResponse = GetInstantMixFromPlaylistResponses[keyof GetInstantMixFromPlaylistResponses];

export type GetInstantMixFromSongData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
    };
    query?: {
        /**
         * Optional. Filter by user id, and attach user data.
         */
        userId?: string;
        /**
         * Optional. The maximum number of records to return.
         */
        limit?: number;
        /**
         * Optional. Specify additional fields of information to return in the output.
         */
        fields?: Array<ItemFields>;
        /**
         * Optional. Include image information in output.
         */
        enableImages?: boolean;
        /**
         * Optional. Include user data.
         */
        enableUserData?: boolean;
        /**
         * Optional. The max number of images to return, per image type.
         */
        imageTypeLimit?: number;
        /**
         * Optional. The image types to include in the output.
         */
        enableImageTypes?: Array<ImageType>;
    };
    url: '/Songs/{itemId}/InstantMix';
};

export type GetInstantMixFromSongErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type GetInstantMixFromSongError = GetInstantMixFromSongErrors[keyof GetInstantMixFromSongErrors];

export type GetInstantMixFromSongResponses = {
    /**
     * Instant playlist returned.
     */
    200: BaseItemDtoQueryResult;
};

export type GetInstantMixFromSongResponse = GetInstantMixFromSongResponses[keyof GetInstantMixFromSongResponses];

export type GetExternalIdInfosData = {
    body?: never;
    path: {
        /**
         * Item id.
         */
        itemId: string;
    };
    query?: never;
    url: '/Items/{itemId}/ExternalIdInfos';
};

export type GetExternalIdInfosErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type GetExternalIdInfosError = GetExternalIdInfosErrors[keyof GetExternalIdInfosErrors];

export type GetExternalIdInfosResponses = {
    /**
     * External id info retrieved.
     */
    200: Array<ExternalIdInfo>;
};

export type GetExternalIdInfosResponse = GetExternalIdInfosResponses[keyof GetExternalIdInfosResponses];

export type ApplySearchCriteriaData = {
    /**
     * The remote search result.
     */
    body: RemoteSearchResult;
    path: {
        /**
         * Item id.
         */
        itemId: string;
    };
    query?: {
        /**
         * Optional. Whether or not to replace all images. Default: True.
         */
        replaceAllImages?: boolean;
    };
    url: '/Items/RemoteSearch/Apply/{itemId}';
};

export type ApplySearchCriteriaErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type ApplySearchCriteriaError = ApplySearchCriteriaErrors[keyof ApplySearchCriteriaErrors];

export type ApplySearchCriteriaResponses = {
    /**
     * Item metadata refreshed.
     */
    204: void;
};

export type ApplySearchCriteriaResponse = ApplySearchCriteriaResponses[keyof ApplySearchCriteriaResponses];

export type GetBookRemoteSearchResultsData = {
    /**
     * Remote search query.
     */
    body: BookInfoRemoteSearchQuery;
    path?: never;
    query?: never;
    url: '/Items/RemoteSearch/Book';
};

export type GetBookRemoteSearchResultsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetBookRemoteSearchResultsResponses = {
    /**
     * Book remote search executed.
     */
    200: Array<RemoteSearchResult>;
};

export type GetBookRemoteSearchResultsResponse = GetBookRemoteSearchResultsResponses[keyof GetBookRemoteSearchResultsResponses];

export type GetBoxSetRemoteSearchResultsData = {
    /**
     * Remote search query.
     */
    body: BoxSetInfoRemoteSearchQuery;
    path?: never;
    query?: never;
    url: '/Items/RemoteSearch/BoxSet';
};

export type GetBoxSetRemoteSearchResultsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetBoxSetRemoteSearchResultsResponses = {
    /**
     * Box set remote search executed.
     */
    200: Array<RemoteSearchResult>;
};

export type GetBoxSetRemoteSearchResultsResponse = GetBoxSetRemoteSearchResultsResponses[keyof GetBoxSetRemoteSearchResultsResponses];

export type GetMovieRemoteSearchResultsData = {
    /**
     * Remote search query.
     */
    body: MovieInfoRemoteSearchQuery;
    path?: never;
    query?: never;
    url: '/Items/RemoteSearch/Movie';
};

export type GetMovieRemoteSearchResultsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetMovieRemoteSearchResultsResponses = {
    /**
     * Movie remote search executed.
     */
    200: Array<RemoteSearchResult>;
};

export type GetMovieRemoteSearchResultsResponse = GetMovieRemoteSearchResultsResponses[keyof GetMovieRemoteSearchResultsResponses];

export type GetMusicAlbumRemoteSearchResultsData = {
    /**
     * Remote search query.
     */
    body: AlbumInfoRemoteSearchQuery;
    path?: never;
    query?: never;
    url: '/Items/RemoteSearch/MusicAlbum';
};

export type GetMusicAlbumRemoteSearchResultsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetMusicAlbumRemoteSearchResultsResponses = {
    /**
     * Music album remote search executed.
     */
    200: Array<RemoteSearchResult>;
};

export type GetMusicAlbumRemoteSearchResultsResponse = GetMusicAlbumRemoteSearchResultsResponses[keyof GetMusicAlbumRemoteSearchResultsResponses];

export type GetMusicArtistRemoteSearchResultsData = {
    /**
     * Remote search query.
     */
    body: ArtistInfoRemoteSearchQuery;
    path?: never;
    query?: never;
    url: '/Items/RemoteSearch/MusicArtist';
};

export type GetMusicArtistRemoteSearchResultsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetMusicArtistRemoteSearchResultsResponses = {
    /**
     * Music artist remote search executed.
     */
    200: Array<RemoteSearchResult>;
};

export type GetMusicArtistRemoteSearchResultsResponse = GetMusicArtistRemoteSearchResultsResponses[keyof GetMusicArtistRemoteSearchResultsResponses];

export type GetMusicVideoRemoteSearchResultsData = {
    /**
     * Remote search query.
     */
    body: MusicVideoInfoRemoteSearchQuery;
    path?: never;
    query?: never;
    url: '/Items/RemoteSearch/MusicVideo';
};

export type GetMusicVideoRemoteSearchResultsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetMusicVideoRemoteSearchResultsResponses = {
    /**
     * Music video remote search executed.
     */
    200: Array<RemoteSearchResult>;
};

export type GetMusicVideoRemoteSearchResultsResponse = GetMusicVideoRemoteSearchResultsResponses[keyof GetMusicVideoRemoteSearchResultsResponses];

export type GetPersonRemoteSearchResultsData = {
    /**
     * Remote search query.
     */
    body: PersonLookupInfoRemoteSearchQuery;
    path?: never;
    query?: never;
    url: '/Items/RemoteSearch/Person';
};

export type GetPersonRemoteSearchResultsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetPersonRemoteSearchResultsResponses = {
    /**
     * Person remote search executed.
     */
    200: Array<RemoteSearchResult>;
};

export type GetPersonRemoteSearchResultsResponse = GetPersonRemoteSearchResultsResponses[keyof GetPersonRemoteSearchResultsResponses];

export type GetSeriesRemoteSearchResultsData = {
    /**
     * Remote search query.
     */
    body: SeriesInfoRemoteSearchQuery;
    path?: never;
    query?: never;
    url: '/Items/RemoteSearch/Series';
};

export type GetSeriesRemoteSearchResultsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetSeriesRemoteSearchResultsResponses = {
    /**
     * Series remote search executed.
     */
    200: Array<RemoteSearchResult>;
};

export type GetSeriesRemoteSearchResultsResponse = GetSeriesRemoteSearchResultsResponses[keyof GetSeriesRemoteSearchResultsResponses];

export type GetTrailerRemoteSearchResultsData = {
    /**
     * Remote search query.
     */
    body: TrailerInfoRemoteSearchQuery;
    path?: never;
    query?: never;
    url: '/Items/RemoteSearch/Trailer';
};

export type GetTrailerRemoteSearchResultsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetTrailerRemoteSearchResultsResponses = {
    /**
     * Trailer remote search executed.
     */
    200: Array<RemoteSearchResult>;
};

export type GetTrailerRemoteSearchResultsResponse = GetTrailerRemoteSearchResultsResponses[keyof GetTrailerRemoteSearchResultsResponses];

export type RefreshItemData = {
    body?: never;
    path: {
        /**
         * Item id.
         */
        itemId: string;
    };
    query?: {
        /**
         * (Optional) Specifies the metadata refresh mode.
         */
        metadataRefreshMode?: 'None' | 'ValidationOnly' | 'Default' | 'FullRefresh';
        /**
         * (Optional) Specifies the image refresh mode.
         */
        imageRefreshMode?: 'None' | 'ValidationOnly' | 'Default' | 'FullRefresh';
        /**
         * (Optional) Determines if metadata should be replaced. Only applicable if mode is FullRefresh.
         */
        replaceAllMetadata?: boolean;
        /**
         * (Optional) Determines if images should be replaced. Only applicable if mode is FullRefresh.
         */
        replaceAllImages?: boolean;
        /**
         * (Optional) Determines if trickplay images should be replaced. Only applicable if mode is FullRefresh.
         */
        regenerateTrickplay?: boolean;
    };
    url: '/Items/{itemId}/Refresh';
};

export type RefreshItemErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Item to refresh not found.
     */
    404: ProblemDetails;
};

export type RefreshItemError = RefreshItemErrors[keyof RefreshItemErrors];

export type RefreshItemResponses = {
    /**
     * Item metadata refresh queued.
     */
    204: void;
};

export type RefreshItemResponse = RefreshItemResponses[keyof RefreshItemResponses];

export type DeleteItemsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The item ids.
         */
        ids?: Array<string>;
    };
    url: '/Items';
};

export type DeleteItemsErrors = {
    /**
     * Unauthorized access.
     */
    401: ProblemDetails;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Not Found
     */
    404: ProblemDetails;
};

export type DeleteItemsError = DeleteItemsErrors[keyof DeleteItemsErrors];

export type DeleteItemsResponses = {
    /**
     * Items deleted.
     */
    204: void;
};

export type DeleteItemsResponse = DeleteItemsResponses[keyof DeleteItemsResponses];

export type GetItemsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The user id supplied as query parameter; this is required when not using an API key.
         */
        userId?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        maxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        hasThemeSong?: boolean;
        /**
         * Optional filter by items with theme videos.
         */
        hasThemeVideo?: boolean;
        /**
         * Optional filter by items with subtitles.
         */
        hasSubtitles?: boolean;
        /**
         * Optional filter by items with special features.
         */
        hasSpecialFeature?: boolean;
        /**
         * Optional filter by items with trailers.
         */
        hasTrailer?: boolean;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        adjacentTo?: string;
        /**
         * Optional filter by index number.
         */
        indexNumber?: number;
        /**
         * Optional filter by parent index number.
         */
        parentIndexNumber?: number;
        /**
         * Optional filter by items that have or do not have a parental rating.
         */
        hasParentalRating?: boolean;
        /**
         * Optional filter by items that are HD or not.
         */
        isHd?: boolean;
        /**
         * Optional filter by items that are 4K or not.
         */
        is4K?: boolean;
        /**
         * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimited.
         */
        locationTypes?: Array<LocationType>;
        /**
         * Optional. If specified, results will be filtered based on the LocationType. This allows multiple, comma delimited.
         */
        excludeLocationTypes?: Array<LocationType>;
        /**
         * Optional filter by items that are missing episodes or not.
         */
        isMissing?: boolean;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        isUnaired?: boolean;
        /**
         * Optional filter by minimum community rating.
         */
        minCommunityRating?: number;
        /**
         * Optional filter by minimum critic rating.
         */
        minCriticRating?: number;
        /**
         * Optional. The minimum premiere date. Format = ISO.
         */
        minPremiereDate?: string;
        /**
         * Optional. The minimum last saved date. Format = ISO.
         */
        minDateLastSaved?: string;
        /**
         * Optional. The minimum last saved date for the current user. Format = ISO.
         */
        minDateLastSavedForUser?: string;
        /**
         * Optional. The maximum premiere date. Format = ISO.
         */
        maxPremiereDate?: string;
        /**
         * Optional filter by items that have an overview or not.
         */
        hasOverview?: boolean;
        /**
         * Optional filter by items that have an IMDb id or not.
         */
        hasImdbId?: boolean;
        /**
         * Optional filter by items that have a TMDb id or not.
         */
        hasTmdbId?: boolean;
        /**
         * Optional filter by items that have a TVDb id or not.
         */
        hasTvdbId?: boolean;
        /**
         * Optional filter for live tv movies.
         */
        isMovie?: boolean;
        /**
         * Optional filter for live tv series.
         */
        isSeries?: boolean;
        /**
         * Optional filter for live tv news.
         */
        isNews?: boolean;
        /**
         * Optional filter for live tv kids.
         */
        isKids?: boolean;
        /**
         * Optional filter for live tv sports.
         */
        isSports?: boolean;
        /**
         * Optional. If specified, results will be filtered by excluding item ids. This allows multiple, comma delimited.
         */
        excludeItemIds?: Array<string>;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        startIndex?: number;
        /**
         * Optional. The maximum number of records to return.
         */
        limit?: number;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false.
         */
        recursive?: boolean;
        /**
         * Optional. Filter based on a search term.
         */
        searchTerm?: string;
        /**
         * Sort Order - Ascending, Descending.
         */
        sortOrder?: Array<SortOrder>;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root.
         */
        parentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         */
        fields?: Array<ItemFields>;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
         */
        excludeItemTypes?: Array<BaseItemKind>;
        /**
         * Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimited.
         */
        includeItemTypes?: Array<BaseItemKind>;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
         */
        filters?: Array<ItemFilter>;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        isFavorite?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        mediaTypes?: Array<MediaType>;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        imageTypes?: Array<ImageType>;
        /**
         * Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         */
        sortBy?: Array<ItemSortBy>;
        /**
         * Optional filter by items that are played, or not.
         */
        isPlayed?: boolean;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
         */
        genres?: Array<string>;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
         */
        officialRatings?: Array<string>;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
         */
        tags?: Array<string>;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
         */
        years?: Array<number>;
        /**
         * Optional, include user data.
         */
        enableUserData?: boolean;
        /**
         * Optional, the max number of images to return, per image type.
         */
        imageTypeLimit?: number;
        /**
         * Optional. The image types to include in the output.
         */
        enableImageTypes?: Array<ImageType>;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person id.
         */
        personIds?: Array<string>;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
         */
        personTypes?: Array<string>;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
         */
        studios?: Array<string>;
        /**
         * Optional. If specified, results will be filtered based on artists. This allows multiple, pipe delimited.
         */
        artists?: Array<string>;
        /**
         * Optional. If specified, results will be filtered based on artist id. This allows multiple, pipe delimited.
         */
        excludeArtistIds?: Array<string>;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified artist id.
         */
        artistIds?: Array<string>;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified album artist id.
         */
        albumArtistIds?: Array<string>;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified contributing artist id.
         */
        contributingArtistIds?: Array<string>;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimited.
         */
        albums?: Array<string>;
        /**
         * Optional. If specified, results will be filtered based on album id. This allows multiple, pipe delimited.
         */
        albumIds?: Array<string>;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        ids?: Array<string>;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimited.
         */
        videoTypes?: Array<VideoType>;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        minOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        isLocked?: boolean;
        /**
         * Optional filter by items that are placeholders.
         */
        isPlaceHolder?: boolean;
        /**
         * Optional filter by items that have official ratings.
         */
        hasOfficialRating?: boolean;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        collapseBoxSetItems?: boolean;
        /**
         * Optional. Filter by the minimum width of the item.
         */
        minWidth?: number;
        /**
         * Optional. Filter by the minimum height of the item.
         */
        minHeight?: number;
        /**
         * Optional. Filter by the maximum width of the item.
         */
        maxWidth?: number;
        /**
         * Optional. Filter by the maximum height of the item.
         */
        maxHeight?: number;
        /**
         * Optional filter by items that are 3D, or not.
         */
        is3D?: boolean;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimited.
         */
        seriesStatus?: Array<SeriesStatus>;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        nameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        nameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        nameLessThan?: string;
        /**
         * Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
         */
        studioIds?: Array<string>;
        /**
         * Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
         */
        genreIds?: Array<string>;
        /**
         * Optional. Enable the total record count.
         */
        enableTotalRecordCount?: boolean;
        /**
         * Optional, include image information in output.
         */
        enableImages?: boolean;
    };
    url: '/Items';
};

export type GetItemsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetItemsResponses = {
    /**
     * Success
     */
    200: BaseItemDtoQueryResult;
};

export type GetItemsResponse = GetItemsResponses[keyof GetItemsResponses];

export type GetItemUserDataData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
    };
    query?: {
        /**
         * The user id.
         */
        userId?: string;
    };
    url: '/UserItems/{itemId}/UserData';
};

export type GetItemUserDataErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Item is not found.
     */
    404: ProblemDetails;
};

export type GetItemUserDataError = GetItemUserDataErrors[keyof GetItemUserDataErrors];

export type GetItemUserDataResponses = {
    /**
     * return item user data.
     */
    200: UserItemDataDto;
};

export type GetItemUserDataResponse = GetItemUserDataResponses[keyof GetItemUserDataResponses];

export type UpdateItemUserDataData = {
    /**
     * This is used by the api to get information about a item user data.
     */
    body: UpdateUserItemDataDto;
    path: {
        /**
         * The item id.
         */
        itemId: string;
    };
    query?: {
        /**
         * The user id.
         */
        userId?: string;
    };
    url: '/UserItems/{itemId}/UserData';
};

export type UpdateItemUserDataErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Item is not found.
     */
    404: ProblemDetails;
};

export type UpdateItemUserDataError = UpdateItemUserDataErrors[keyof UpdateItemUserDataErrors];

export type UpdateItemUserDataResponses = {
    /**
     * return updated user item data.
     */
    200: UserItemDataDto;
};

export type UpdateItemUserDataResponse = UpdateItemUserDataResponses[keyof UpdateItemUserDataResponses];

export type GetResumeItemsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The user id.
         */
        userId?: string;
        /**
         * The start index.
         */
        startIndex?: number;
        /**
         * The item limit.
         */
        limit?: number;
        /**
         * The search term.
         */
        searchTerm?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root.
         */
        parentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         */
        fields?: Array<ItemFields>;
        /**
         * Optional. Filter by MediaType. Allows multiple, comma delimited.
         */
        mediaTypes?: Array<MediaType>;
        /**
         * Optional. Include user data.
         */
        enableUserData?: boolean;
        /**
         * Optional. The max number of images to return, per image type.
         */
        imageTypeLimit?: number;
        /**
         * Optional. The image types to include in the output.
         */
        enableImageTypes?: Array<ImageType>;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
         */
        excludeItemTypes?: Array<BaseItemKind>;
        /**
         * Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimited.
         */
        includeItemTypes?: Array<BaseItemKind>;
        /**
         * Optional. Enable the total record count.
         */
        enableTotalRecordCount?: boolean;
        /**
         * Optional. Include image information in output.
         */
        enableImages?: boolean;
        /**
         * Optional. Whether to exclude the currently active sessions.
         */
        excludeActiveSessions?: boolean;
    };
    url: '/UserItems/Resume';
};

export type GetResumeItemsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetResumeItemsResponses = {
    /**
     * Items returned.
     */
    200: BaseItemDtoQueryResult;
};

export type GetResumeItemsResponse = GetResumeItemsResponses[keyof GetResumeItemsResponses];

export type DeleteItemData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
    };
    query?: never;
    url: '/Items/{itemId}';
};

export type DeleteItemErrors = {
    /**
     * Unauthorized access.
     */
    401: ProblemDetails;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type DeleteItemError = DeleteItemErrors[keyof DeleteItemErrors];

export type DeleteItemResponses = {
    /**
     * Item deleted.
     */
    204: void;
};

export type DeleteItemResponse = DeleteItemResponses[keyof DeleteItemResponses];

export type GetItemData = {
    body?: never;
    path: {
        /**
         * Item id.
         */
        itemId: string;
    };
    query?: {
        /**
         * User id.
         */
        userId?: string;
    };
    url: '/Items/{itemId}';
};

export type GetItemErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetItemResponses = {
    /**
     * Item returned.
     */
    200: BaseItemDto;
};

export type GetItemResponse = GetItemResponses[keyof GetItemResponses];

export type UpdateItemData = {
    /**
     * This is strictly used as a data transfer object from the api layer.
     * This holds information about a BaseItem in a format that is convenient for the client.
     */
    body: BaseItemDto;
    path: {
        /**
         * The item id.
         */
        itemId: string;
    };
    query?: never;
    url: '/Items/{itemId}';
};

export type UpdateItemErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type UpdateItemError = UpdateItemErrors[keyof UpdateItemErrors];

export type UpdateItemResponses = {
    /**
     * Item updated.
     */
    204: void;
};

export type UpdateItemResponse = UpdateItemResponses[keyof UpdateItemResponses];

export type UpdateItemContentTypeData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
    };
    query?: {
        /**
         * The content type of the item.
         */
        contentType?: string;
    };
    url: '/Items/{itemId}/ContentType';
};

export type UpdateItemContentTypeErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type UpdateItemContentTypeError = UpdateItemContentTypeErrors[keyof UpdateItemContentTypeErrors];

export type UpdateItemContentTypeResponses = {
    /**
     * Item content type updated.
     */
    204: void;
};

export type UpdateItemContentTypeResponse = UpdateItemContentTypeResponses[keyof UpdateItemContentTypeResponses];

export type GetMetadataEditorInfoData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
    };
    query?: never;
    url: '/Items/{itemId}/MetadataEditor';
};

export type GetMetadataEditorInfoErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type GetMetadataEditorInfoError = GetMetadataEditorInfoErrors[keyof GetMetadataEditorInfoErrors];

export type GetMetadataEditorInfoResponses = {
    /**
     * Item metadata editor returned.
     */
    200: MetadataEditorInfo;
};

export type GetMetadataEditorInfoResponse = GetMetadataEditorInfoResponses[keyof GetMetadataEditorInfoResponses];

export type GetSimilarAlbumsData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
    };
    query?: {
        /**
         * Exclude artist ids.
         */
        excludeArtistIds?: Array<string>;
        /**
         * Optional. Filter by user id, and attach user data.
         */
        userId?: string;
        /**
         * Optional. The maximum number of records to return.
         */
        limit?: number;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         */
        fields?: Array<ItemFields>;
    };
    url: '/Albums/{itemId}/Similar';
};

export type GetSimilarAlbumsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetSimilarAlbumsResponses = {
    /**
     * Similar items returned.
     */
    200: BaseItemDtoQueryResult;
};

export type GetSimilarAlbumsResponse = GetSimilarAlbumsResponses[keyof GetSimilarAlbumsResponses];

export type GetSimilarArtistsData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
    };
    query?: {
        /**
         * Exclude artist ids.
         */
        excludeArtistIds?: Array<string>;
        /**
         * Optional. Filter by user id, and attach user data.
         */
        userId?: string;
        /**
         * Optional. The maximum number of records to return.
         */
        limit?: number;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         */
        fields?: Array<ItemFields>;
    };
    url: '/Artists/{itemId}/Similar';
};

export type GetSimilarArtistsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetSimilarArtistsResponses = {
    /**
     * Similar items returned.
     */
    200: BaseItemDtoQueryResult;
};

export type GetSimilarArtistsResponse = GetSimilarArtistsResponses[keyof GetSimilarArtistsResponses];

export type GetAncestorsData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
    };
    query?: {
        /**
         * Optional. Filter by user id, and attach user data.
         */
        userId?: string;
    };
    url: '/Items/{itemId}/Ancestors';
};

export type GetAncestorsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type GetAncestorsError = GetAncestorsErrors[keyof GetAncestorsErrors];

export type GetAncestorsResponses = {
    /**
     * Item parents returned.
     */
    200: Array<BaseItemDto>;
};

export type GetAncestorsResponse = GetAncestorsResponses[keyof GetAncestorsResponses];

export type GetCriticReviewsData = {
    body?: never;
    path: {
        itemId: string;
    };
    query?: never;
    url: '/Items/{itemId}/CriticReviews';
};

export type GetCriticReviewsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetCriticReviewsResponses = {
    /**
     * Critic reviews returned.
     */
    200: BaseItemDtoQueryResult;
};

export type GetCriticReviewsResponse = GetCriticReviewsResponses[keyof GetCriticReviewsResponses];

export type GetDownloadData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
    };
    query?: never;
    url: '/Items/{itemId}/Download';
};

export type GetDownloadErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type GetDownloadError = GetDownloadErrors[keyof GetDownloadErrors];

export type GetDownloadResponses = {
    /**
     * Media downloaded.
     */
    200: Blob | File;
};

export type GetDownloadResponse = GetDownloadResponses[keyof GetDownloadResponses];

export type GetFileData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
    };
    query?: never;
    url: '/Items/{itemId}/File';
};

export type GetFileErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type GetFileError = GetFileErrors[keyof GetFileErrors];

export type GetFileResponses = {
    /**
     * File stream returned.
     */
    200: Blob | File;
};

export type GetFileResponse = GetFileResponses[keyof GetFileResponses];

export type GetSimilarItemsData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
    };
    query?: {
        /**
         * Exclude artist ids.
         */
        excludeArtistIds?: Array<string>;
        /**
         * Optional. Filter by user id, and attach user data.
         */
        userId?: string;
        /**
         * Optional. The maximum number of records to return.
         */
        limit?: number;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         */
        fields?: Array<ItemFields>;
    };
    url: '/Items/{itemId}/Similar';
};

export type GetSimilarItemsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetSimilarItemsResponses = {
    /**
     * Similar items returned.
     */
    200: BaseItemDtoQueryResult;
};

export type GetSimilarItemsResponse = GetSimilarItemsResponses[keyof GetSimilarItemsResponses];

export type GetThemeMediaData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
    };
    query?: {
        /**
         * Optional. Filter by user id, and attach user data.
         */
        userId?: string;
        /**
         * Optional. Determines whether or not parent items should be searched for theme media.
         */
        inheritFromParent?: boolean;
        /**
         * Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         */
        sortBy?: Array<ItemSortBy>;
        /**
         * Optional. Sort Order - Ascending, Descending.
         */
        sortOrder?: Array<SortOrder>;
    };
    url: '/Items/{itemId}/ThemeMedia';
};

export type GetThemeMediaErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Item not found.
     */
    404: unknown;
};

export type GetThemeMediaResponses = {
    /**
     * Theme songs and videos returned.
     */
    200: AllThemeMediaResult;
};

export type GetThemeMediaResponse = GetThemeMediaResponses[keyof GetThemeMediaResponses];

export type GetThemeSongsData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
    };
    query?: {
        /**
         * Optional. Filter by user id, and attach user data.
         */
        userId?: string;
        /**
         * Optional. Determines whether or not parent items should be searched for theme media.
         */
        inheritFromParent?: boolean;
        /**
         * Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         */
        sortBy?: Array<ItemSortBy>;
        /**
         * Optional. Sort Order - Ascending, Descending.
         */
        sortOrder?: Array<SortOrder>;
    };
    url: '/Items/{itemId}/ThemeSongs';
};

export type GetThemeSongsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type GetThemeSongsError = GetThemeSongsErrors[keyof GetThemeSongsErrors];

export type GetThemeSongsResponses = {
    /**
     * Theme songs returned.
     */
    200: ThemeMediaResult;
};

export type GetThemeSongsResponse = GetThemeSongsResponses[keyof GetThemeSongsResponses];

export type GetThemeVideosData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
    };
    query?: {
        /**
         * Optional. Filter by user id, and attach user data.
         */
        userId?: string;
        /**
         * Optional. Determines whether or not parent items should be searched for theme media.
         */
        inheritFromParent?: boolean;
        /**
         * Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         */
        sortBy?: Array<ItemSortBy>;
        /**
         * Optional. Sort Order - Ascending, Descending.
         */
        sortOrder?: Array<SortOrder>;
    };
    url: '/Items/{itemId}/ThemeVideos';
};

export type GetThemeVideosErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type GetThemeVideosError = GetThemeVideosErrors[keyof GetThemeVideosErrors];

export type GetThemeVideosResponses = {
    /**
     * Theme videos returned.
     */
    200: ThemeMediaResult;
};

export type GetThemeVideosResponse = GetThemeVideosResponses[keyof GetThemeVideosResponses];

export type GetItemCountsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional. Get counts from a specific user's library.
         */
        userId?: string;
        /**
         * Optional. Get counts of favorite items.
         */
        isFavorite?: boolean;
    };
    url: '/Items/Counts';
};

export type GetItemCountsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetItemCountsResponses = {
    /**
     * Item counts returned.
     */
    200: ItemCounts;
};

export type GetItemCountsResponse = GetItemCountsResponses[keyof GetItemCountsResponses];

export type GetLibraryOptionsInfoData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Library content type.
         */
        libraryContentType?: 'unknown' | 'movies' | 'tvshows' | 'music' | 'musicvideos' | 'trailers' | 'homevideos' | 'boxsets' | 'books' | 'photos' | 'livetv' | 'playlists' | 'folders';
        /**
         * Whether this is a new library.
         */
        isNewLibrary?: boolean;
    };
    url: '/Libraries/AvailableOptions';
};

export type GetLibraryOptionsInfoErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetLibraryOptionsInfoResponses = {
    /**
     * Library options info returned.
     */
    200: LibraryOptionsResultDto;
};

export type GetLibraryOptionsInfoResponse = GetLibraryOptionsInfoResponses[keyof GetLibraryOptionsInfoResponses];

export type PostUpdatedMediaData = {
    /**
     * Media Update Info Dto.
     */
    body: MediaUpdateInfoDto;
    path?: never;
    query?: never;
    url: '/Library/Media/Updated';
};

export type PostUpdatedMediaErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type PostUpdatedMediaResponses = {
    /**
     * Report success.
     */
    204: void;
};

export type PostUpdatedMediaResponse = PostUpdatedMediaResponses[keyof PostUpdatedMediaResponses];

export type GetMediaFoldersData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional. Filter by folders that are marked hidden, or not.
         */
        isHidden?: boolean;
    };
    url: '/Library/MediaFolders';
};

export type GetMediaFoldersErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetMediaFoldersResponses = {
    /**
     * Media folders returned.
     */
    200: BaseItemDtoQueryResult;
};

export type GetMediaFoldersResponse = GetMediaFoldersResponses[keyof GetMediaFoldersResponses];

export type PostAddedMoviesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The tmdbId.
         */
        tmdbId?: string;
        /**
         * The imdbId.
         */
        imdbId?: string;
    };
    url: '/Library/Movies/Added';
};

export type PostAddedMoviesErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type PostAddedMoviesResponses = {
    /**
     * Report success.
     */
    204: void;
};

export type PostAddedMoviesResponse = PostAddedMoviesResponses[keyof PostAddedMoviesResponses];

export type PostUpdatedMoviesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The tmdbId.
         */
        tmdbId?: string;
        /**
         * The imdbId.
         */
        imdbId?: string;
    };
    url: '/Library/Movies/Updated';
};

export type PostUpdatedMoviesErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type PostUpdatedMoviesResponses = {
    /**
     * Report success.
     */
    204: void;
};

export type PostUpdatedMoviesResponse = PostUpdatedMoviesResponses[keyof PostUpdatedMoviesResponses];

export type GetPhysicalPathsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Library/PhysicalPaths';
};

export type GetPhysicalPathsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetPhysicalPathsResponses = {
    /**
     * Physical paths returned.
     */
    200: Array<string>;
};

export type GetPhysicalPathsResponse = GetPhysicalPathsResponses[keyof GetPhysicalPathsResponses];

export type RefreshLibraryData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Library/Refresh';
};

export type RefreshLibraryErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type RefreshLibraryResponses = {
    /**
     * Library scan started.
     */
    204: void;
};

export type RefreshLibraryResponse = RefreshLibraryResponses[keyof RefreshLibraryResponses];

export type PostAddedSeriesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The tvdbId.
         */
        tvdbId?: string;
    };
    url: '/Library/Series/Added';
};

export type PostAddedSeriesErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type PostAddedSeriesResponses = {
    /**
     * Report success.
     */
    204: void;
};

export type PostAddedSeriesResponse = PostAddedSeriesResponses[keyof PostAddedSeriesResponses];

export type PostUpdatedSeriesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The tvdbId.
         */
        tvdbId?: string;
    };
    url: '/Library/Series/Updated';
};

export type PostUpdatedSeriesErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type PostUpdatedSeriesResponses = {
    /**
     * Report success.
     */
    204: void;
};

export type PostUpdatedSeriesResponse = PostUpdatedSeriesResponses[keyof PostUpdatedSeriesResponses];

export type GetSimilarMoviesData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
    };
    query?: {
        /**
         * Exclude artist ids.
         */
        excludeArtistIds?: Array<string>;
        /**
         * Optional. Filter by user id, and attach user data.
         */
        userId?: string;
        /**
         * Optional. The maximum number of records to return.
         */
        limit?: number;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         */
        fields?: Array<ItemFields>;
    };
    url: '/Movies/{itemId}/Similar';
};

export type GetSimilarMoviesErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetSimilarMoviesResponses = {
    /**
     * Similar items returned.
     */
    200: BaseItemDtoQueryResult;
};

export type GetSimilarMoviesResponse = GetSimilarMoviesResponses[keyof GetSimilarMoviesResponses];

export type GetSimilarShowsData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
    };
    query?: {
        /**
         * Exclude artist ids.
         */
        excludeArtistIds?: Array<string>;
        /**
         * Optional. Filter by user id, and attach user data.
         */
        userId?: string;
        /**
         * Optional. The maximum number of records to return.
         */
        limit?: number;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         */
        fields?: Array<ItemFields>;
    };
    url: '/Shows/{itemId}/Similar';
};

export type GetSimilarShowsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetSimilarShowsResponses = {
    /**
     * Similar items returned.
     */
    200: BaseItemDtoQueryResult;
};

export type GetSimilarShowsResponse = GetSimilarShowsResponses[keyof GetSimilarShowsResponses];

export type GetSimilarTrailersData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
    };
    query?: {
        /**
         * Exclude artist ids.
         */
        excludeArtistIds?: Array<string>;
        /**
         * Optional. Filter by user id, and attach user data.
         */
        userId?: string;
        /**
         * Optional. The maximum number of records to return.
         */
        limit?: number;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         */
        fields?: Array<ItemFields>;
    };
    url: '/Trailers/{itemId}/Similar';
};

export type GetSimilarTrailersErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetSimilarTrailersResponses = {
    /**
     * Similar items returned.
     */
    200: BaseItemDtoQueryResult;
};

export type GetSimilarTrailersResponse = GetSimilarTrailersResponses[keyof GetSimilarTrailersResponses];

export type RemoveVirtualFolderData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The name of the folder.
         */
        name?: string;
        /**
         * Whether to refresh the library.
         */
        refreshLibrary?: boolean;
    };
    url: '/Library/VirtualFolders';
};

export type RemoveVirtualFolderErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type RemoveVirtualFolderResponses = {
    /**
     * Folder removed.
     */
    204: void;
};

export type RemoveVirtualFolderResponse = RemoveVirtualFolderResponses[keyof RemoveVirtualFolderResponses];

export type GetVirtualFoldersData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Library/VirtualFolders';
};

export type GetVirtualFoldersErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetVirtualFoldersResponses = {
    /**
     * Virtual folders retrieved.
     */
    200: Array<VirtualFolderInfo>;
};

export type GetVirtualFoldersResponse = GetVirtualFoldersResponses[keyof GetVirtualFoldersResponses];

export type AddVirtualFolderData = {
    /**
     * Add virtual folder dto.
     */
    body?: AddVirtualFolderDto;
    path?: never;
    query?: {
        /**
         * The name of the virtual folder.
         */
        name?: string;
        /**
         * The type of the collection.
         */
        collectionType?: 'movies' | 'tvshows' | 'music' | 'musicvideos' | 'homevideos' | 'boxsets' | 'books' | 'mixed';
        /**
         * The paths of the virtual folder.
         */
        paths?: Array<string>;
        /**
         * Whether to refresh the library.
         */
        refreshLibrary?: boolean;
    };
    url: '/Library/VirtualFolders';
};

export type AddVirtualFolderErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type AddVirtualFolderResponses = {
    /**
     * Folder added.
     */
    204: void;
};

export type AddVirtualFolderResponse = AddVirtualFolderResponses[keyof AddVirtualFolderResponses];

export type UpdateLibraryOptionsData = {
    /**
     * Update library options dto.
     */
    body?: UpdateLibraryOptionsDto;
    path?: never;
    query?: never;
    url: '/Library/VirtualFolders/LibraryOptions';
};

export type UpdateLibraryOptionsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type UpdateLibraryOptionsError = UpdateLibraryOptionsErrors[keyof UpdateLibraryOptionsErrors];

export type UpdateLibraryOptionsResponses = {
    /**
     * Library updated.
     */
    204: void;
};

export type UpdateLibraryOptionsResponse = UpdateLibraryOptionsResponses[keyof UpdateLibraryOptionsResponses];

export type RenameVirtualFolderData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The name of the virtual folder.
         */
        name?: string;
        /**
         * The new name.
         */
        newName?: string;
        /**
         * Whether to refresh the library.
         */
        refreshLibrary?: boolean;
    };
    url: '/Library/VirtualFolders/Name';
};

export type RenameVirtualFolderErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Library doesn't exist.
     */
    404: ProblemDetails;
    /**
     * Library already exists.
     */
    409: ProblemDetails;
};

export type RenameVirtualFolderError = RenameVirtualFolderErrors[keyof RenameVirtualFolderErrors];

export type RenameVirtualFolderResponses = {
    /**
     * Folder renamed.
     */
    204: void;
};

export type RenameVirtualFolderResponse = RenameVirtualFolderResponses[keyof RenameVirtualFolderResponses];

export type RemoveMediaPathData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The name of the library.
         */
        name?: string;
        /**
         * The path to remove.
         */
        path?: string;
        /**
         * Whether to refresh the library.
         */
        refreshLibrary?: boolean;
    };
    url: '/Library/VirtualFolders/Paths';
};

export type RemoveMediaPathErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type RemoveMediaPathResponses = {
    /**
     * Media path removed.
     */
    204: void;
};

export type RemoveMediaPathResponse = RemoveMediaPathResponses[keyof RemoveMediaPathResponses];

export type AddMediaPathData = {
    /**
     * Media Path dto.
     */
    body: MediaPathDto;
    path?: never;
    query?: {
        /**
         * Whether to refresh the library.
         */
        refreshLibrary?: boolean;
    };
    url: '/Library/VirtualFolders/Paths';
};

export type AddMediaPathErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type AddMediaPathResponses = {
    /**
     * Media path added.
     */
    204: void;
};

export type AddMediaPathResponse = AddMediaPathResponses[keyof AddMediaPathResponses];

export type UpdateMediaPathData = {
    /**
     * Update library options dto.
     */
    body: UpdateMediaPathRequestDto;
    path?: never;
    query?: never;
    url: '/Library/VirtualFolders/Paths/Update';
};

export type UpdateMediaPathErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type UpdateMediaPathResponses = {
    /**
     * Media path updated.
     */
    204: void;
};

export type UpdateMediaPathResponse = UpdateMediaPathResponses[keyof UpdateMediaPathResponses];

export type GetChannelMappingOptionsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Provider id.
         */
        providerId?: string;
    };
    url: '/LiveTv/ChannelMappingOptions';
};

export type GetChannelMappingOptionsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetChannelMappingOptionsResponses = {
    /**
     * Channel mapping options returned.
     */
    200: ChannelMappingOptionsDto;
};

export type GetChannelMappingOptionsResponse = GetChannelMappingOptionsResponses[keyof GetChannelMappingOptionsResponses];

export type SetChannelMappingData = {
    /**
     * Set channel mapping dto.
     */
    body: SetChannelMappingDto;
    path?: never;
    query?: never;
    url: '/LiveTv/ChannelMappings';
};

export type SetChannelMappingErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type SetChannelMappingResponses = {
    /**
     * Created channel mapping returned.
     */
    200: TunerChannelMapping;
};

export type SetChannelMappingResponse = SetChannelMappingResponses[keyof SetChannelMappingResponses];

export type GetLiveTvChannelsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional. Filter by channel type.
         */
        type?: 'TV' | 'Radio';
        /**
         * Optional. Filter by user and attach user data.
         */
        userId?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        startIndex?: number;
        /**
         * Optional. Filter for movies.
         */
        isMovie?: boolean;
        /**
         * Optional. Filter for series.
         */
        isSeries?: boolean;
        /**
         * Optional. Filter for news.
         */
        isNews?: boolean;
        /**
         * Optional. Filter for kids.
         */
        isKids?: boolean;
        /**
         * Optional. Filter for sports.
         */
        isSports?: boolean;
        /**
         * Optional. The maximum number of records to return.
         */
        limit?: number;
        /**
         * Optional. Filter by channels that are favorites, or not.
         */
        isFavorite?: boolean;
        /**
         * Optional. Filter by channels that are liked, or not.
         */
        isLiked?: boolean;
        /**
         * Optional. Filter by channels that are disliked, or not.
         */
        isDisliked?: boolean;
        /**
         * Optional. Include image information in output.
         */
        enableImages?: boolean;
        /**
         * Optional. The max number of images to return, per image type.
         */
        imageTypeLimit?: number;
        /**
         * "Optional. The image types to include in the output.
         */
        enableImageTypes?: Array<ImageType>;
        /**
         * Optional. Specify additional fields of information to return in the output.
         */
        fields?: Array<ItemFields>;
        /**
         * Optional. Include user data.
         */
        enableUserData?: boolean;
        /**
         * Optional. Key to sort by.
         */
        sortBy?: Array<ItemSortBy>;
        /**
         * Optional. Sort order.
         */
        sortOrder?: 'Ascending' | 'Descending';
        /**
         * Optional. Incorporate favorite and like status into channel sorting.
         */
        enableFavoriteSorting?: boolean;
        /**
         * Optional. Adds current program info to each channel.
         */
        addCurrentProgram?: boolean;
    };
    url: '/LiveTv/Channels';
};

export type GetLiveTvChannelsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetLiveTvChannelsResponses = {
    /**
     * Available live tv channels returned.
     */
    200: BaseItemDtoQueryResult;
};

export type GetLiveTvChannelsResponse = GetLiveTvChannelsResponses[keyof GetLiveTvChannelsResponses];

export type GetChannelData = {
    body?: never;
    path: {
        /**
         * Channel id.
         */
        channelId: string;
    };
    query?: {
        /**
         * Optional. Attach user data.
         */
        userId?: string;
    };
    url: '/LiveTv/Channels/{channelId}';
};

export type GetChannelErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type GetChannelError = GetChannelErrors[keyof GetChannelErrors];

export type GetChannelResponses = {
    /**
     * Live tv channel returned.
     */
    200: BaseItemDto;
};

export type GetChannelResponse = GetChannelResponses[keyof GetChannelResponses];

export type GetGuideInfoData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/LiveTv/GuideInfo';
};

export type GetGuideInfoErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetGuideInfoResponses = {
    /**
     * Guid info returned.
     */
    200: GuideInfo;
};

export type GetGuideInfoResponse = GetGuideInfoResponses[keyof GetGuideInfoResponses];

export type GetLiveTvInfoData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/LiveTv/Info';
};

export type GetLiveTvInfoErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetLiveTvInfoResponses = {
    /**
     * Available live tv services returned.
     */
    200: LiveTvInfo;
};

export type GetLiveTvInfoResponse = GetLiveTvInfoResponses[keyof GetLiveTvInfoResponses];

export type DeleteListingProviderData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Listing provider id.
         */
        id?: string;
    };
    url: '/LiveTv/ListingProviders';
};

export type DeleteListingProviderErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type DeleteListingProviderResponses = {
    /**
     * Listing provider deleted.
     */
    204: void;
};

export type DeleteListingProviderResponse = DeleteListingProviderResponses[keyof DeleteListingProviderResponses];

export type AddListingProviderData = {
    /**
     * New listings info.
     */
    body?: ListingsProviderInfo;
    path?: never;
    query?: {
        /**
         * Password.
         */
        pw?: string;
        /**
         * Validate listings.
         */
        validateListings?: boolean;
        /**
         * Validate login.
         */
        validateLogin?: boolean;
    };
    url: '/LiveTv/ListingProviders';
};

export type AddListingProviderErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type AddListingProviderResponses = {
    /**
     * Created listings provider returned.
     */
    200: ListingsProviderInfo;
};

export type AddListingProviderResponse = AddListingProviderResponses[keyof AddListingProviderResponses];

export type GetDefaultListingProviderData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/LiveTv/ListingProviders/Default';
};

export type GetDefaultListingProviderErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetDefaultListingProviderResponses = {
    /**
     * Default listings provider info returned.
     */
    200: ListingsProviderInfo;
};

export type GetDefaultListingProviderResponse = GetDefaultListingProviderResponses[keyof GetDefaultListingProviderResponses];

export type GetLineupsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Provider id.
         */
        id?: string;
        /**
         * Provider type.
         */
        type?: string;
        /**
         * Location.
         */
        location?: string;
        /**
         * Country.
         */
        country?: string;
    };
    url: '/LiveTv/ListingProviders/Lineups';
};

export type GetLineupsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetLineupsResponses = {
    /**
     * Available lineups returned.
     */
    200: Array<NameIdPair>;
};

export type GetLineupsResponse = GetLineupsResponses[keyof GetLineupsResponses];

export type GetSchedulesDirectCountriesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/LiveTv/ListingProviders/SchedulesDirect/Countries';
};

export type GetSchedulesDirectCountriesErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetSchedulesDirectCountriesResponses = {
    /**
     * Available countries returned.
     */
    200: Blob | File;
};

export type GetSchedulesDirectCountriesResponse = GetSchedulesDirectCountriesResponses[keyof GetSchedulesDirectCountriesResponses];

export type GetLiveRecordingFileData = {
    body?: never;
    path: {
        /**
         * Recording id.
         */
        recordingId: string;
    };
    query?: never;
    url: '/LiveTv/LiveRecordings/{recordingId}/stream';
};

export type GetLiveRecordingFileErrors = {
    /**
     * Recording not found.
     */
    404: ProblemDetails;
};

export type GetLiveRecordingFileError = GetLiveRecordingFileErrors[keyof GetLiveRecordingFileErrors];

export type GetLiveRecordingFileResponses = {
    /**
     * Recording stream returned.
     */
    200: Blob | File;
};

export type GetLiveRecordingFileResponse = GetLiveRecordingFileResponses[keyof GetLiveRecordingFileResponses];

export type GetLiveStreamFileData = {
    body?: never;
    path: {
        /**
         * Stream id.
         */
        streamId: string;
        /**
         * Container type.
         */
        container: string;
    };
    query?: never;
    url: '/LiveTv/LiveStreamFiles/{streamId}/stream.{container}';
};

export type GetLiveStreamFileErrors = {
    /**
     * Stream not found.
     */
    404: ProblemDetails;
};

export type GetLiveStreamFileError = GetLiveStreamFileErrors[keyof GetLiveStreamFileErrors];

export type GetLiveStreamFileResponses = {
    /**
     * Stream returned.
     */
    200: Blob | File;
};

export type GetLiveStreamFileResponse = GetLiveStreamFileResponses[keyof GetLiveStreamFileResponses];

export type GetLiveTvProgramsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The channels to return guide information for.
         */
        channelIds?: Array<string>;
        /**
         * Optional. Filter by user id.
         */
        userId?: string;
        /**
         * Optional. The minimum premiere start date.
         */
        minStartDate?: string;
        /**
         * Optional. Filter by programs that have completed airing, or not.
         */
        hasAired?: boolean;
        /**
         * Optional. Filter by programs that are currently airing, or not.
         */
        isAiring?: boolean;
        /**
         * Optional. The maximum premiere start date.
         */
        maxStartDate?: string;
        /**
         * Optional. The minimum premiere end date.
         */
        minEndDate?: string;
        /**
         * Optional. The maximum premiere end date.
         */
        maxEndDate?: string;
        /**
         * Optional. Filter for movies.
         */
        isMovie?: boolean;
        /**
         * Optional. Filter for series.
         */
        isSeries?: boolean;
        /**
         * Optional. Filter for news.
         */
        isNews?: boolean;
        /**
         * Optional. Filter for kids.
         */
        isKids?: boolean;
        /**
         * Optional. Filter for sports.
         */
        isSports?: boolean;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        startIndex?: number;
        /**
         * Optional. The maximum number of records to return.
         */
        limit?: number;
        /**
         * Optional. Specify one or more sort orders, comma delimited. Options: Name, StartDate.
         */
        sortBy?: Array<ItemSortBy>;
        /**
         * Sort Order - Ascending,Descending.
         */
        sortOrder?: Array<SortOrder>;
        /**
         * The genres to return guide information for.
         */
        genres?: Array<string>;
        /**
         * The genre ids to return guide information for.
         */
        genreIds?: Array<string>;
        /**
         * Optional. Include image information in output.
         */
        enableImages?: boolean;
        /**
         * Optional. The max number of images to return, per image type.
         */
        imageTypeLimit?: number;
        /**
         * Optional. The image types to include in the output.
         */
        enableImageTypes?: Array<ImageType>;
        /**
         * Optional. Include user data.
         */
        enableUserData?: boolean;
        /**
         * Optional. Filter by series timer id.
         */
        seriesTimerId?: string;
        /**
         * Optional. Filter by library series id.
         */
        librarySeriesId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output.
         */
        fields?: Array<ItemFields>;
        /**
         * Retrieve total record count.
         */
        enableTotalRecordCount?: boolean;
    };
    url: '/LiveTv/Programs';
};

export type GetLiveTvProgramsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetLiveTvProgramsResponses = {
    /**
     * Live tv epgs returned.
     */
    200: BaseItemDtoQueryResult;
};

export type GetLiveTvProgramsResponse = GetLiveTvProgramsResponses[keyof GetLiveTvProgramsResponses];

export type GetProgramsData = {
    /**
     * Get programs dto.
     */
    body?: GetProgramsDto;
    path?: never;
    query?: never;
    url: '/LiveTv/Programs';
};

export type GetProgramsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetProgramsResponses = {
    /**
     * Live tv epgs returned.
     */
    200: BaseItemDtoQueryResult;
};

export type GetProgramsResponse = GetProgramsResponses[keyof GetProgramsResponses];

export type GetProgramData = {
    body?: never;
    path: {
        /**
         * Program id.
         */
        programId: string;
    };
    query?: {
        /**
         * Optional. Attach user data.
         */
        userId?: string;
    };
    url: '/LiveTv/Programs/{programId}';
};

export type GetProgramErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetProgramResponses = {
    /**
     * Program returned.
     */
    200: BaseItemDto;
};

export type GetProgramResponse = GetProgramResponses[keyof GetProgramResponses];

export type GetRecommendedProgramsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional. filter by user id.
         */
        userId?: string;
        /**
         * Optional. The maximum number of records to return.
         */
        limit?: number;
        /**
         * Optional. Filter by programs that are currently airing, or not.
         */
        isAiring?: boolean;
        /**
         * Optional. Filter by programs that have completed airing, or not.
         */
        hasAired?: boolean;
        /**
         * Optional. Filter for series.
         */
        isSeries?: boolean;
        /**
         * Optional. Filter for movies.
         */
        isMovie?: boolean;
        /**
         * Optional. Filter for news.
         */
        isNews?: boolean;
        /**
         * Optional. Filter for kids.
         */
        isKids?: boolean;
        /**
         * Optional. Filter for sports.
         */
        isSports?: boolean;
        /**
         * Optional. Include image information in output.
         */
        enableImages?: boolean;
        /**
         * Optional. The max number of images to return, per image type.
         */
        imageTypeLimit?: number;
        /**
         * Optional. The image types to include in the output.
         */
        enableImageTypes?: Array<ImageType>;
        /**
         * The genres to return guide information for.
         */
        genreIds?: Array<string>;
        /**
         * Optional. Specify additional fields of information to return in the output.
         */
        fields?: Array<ItemFields>;
        /**
         * Optional. include user data.
         */
        enableUserData?: boolean;
        /**
         * Retrieve total record count.
         */
        enableTotalRecordCount?: boolean;
    };
    url: '/LiveTv/Programs/Recommended';
};

export type GetRecommendedProgramsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetRecommendedProgramsResponses = {
    /**
     * Recommended epgs returned.
     */
    200: BaseItemDtoQueryResult;
};

export type GetRecommendedProgramsResponse = GetRecommendedProgramsResponses[keyof GetRecommendedProgramsResponses];

export type GetRecordingsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional. Filter by channel id.
         */
        channelId?: string;
        /**
         * Optional. Filter by user and attach user data.
         */
        userId?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        startIndex?: number;
        /**
         * Optional. The maximum number of records to return.
         */
        limit?: number;
        /**
         * Optional. Filter by recording status.
         */
        status?: 'New' | 'InProgress' | 'Completed' | 'Cancelled' | 'ConflictedOk' | 'ConflictedNotOk' | 'Error';
        /**
         * Optional. Filter by recordings that are in progress, or not.
         */
        isInProgress?: boolean;
        /**
         * Optional. Filter by recordings belonging to a series timer.
         */
        seriesTimerId?: string;
        /**
         * Optional. Include image information in output.
         */
        enableImages?: boolean;
        /**
         * Optional. The max number of images to return, per image type.
         */
        imageTypeLimit?: number;
        /**
         * Optional. The image types to include in the output.
         */
        enableImageTypes?: Array<ImageType>;
        /**
         * Optional. Specify additional fields of information to return in the output.
         */
        fields?: Array<ItemFields>;
        /**
         * Optional. Include user data.
         */
        enableUserData?: boolean;
        /**
         * Optional. Filter for movies.
         */
        isMovie?: boolean;
        /**
         * Optional. Filter for series.
         */
        isSeries?: boolean;
        /**
         * Optional. Filter for kids.
         */
        isKids?: boolean;
        /**
         * Optional. Filter for sports.
         */
        isSports?: boolean;
        /**
         * Optional. Filter for news.
         */
        isNews?: boolean;
        /**
         * Optional. Filter for is library item.
         */
        isLibraryItem?: boolean;
        /**
         * Optional. Return total record count.
         */
        enableTotalRecordCount?: boolean;
    };
    url: '/LiveTv/Recordings';
};

export type GetRecordingsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetRecordingsResponses = {
    /**
     * Live tv recordings returned.
     */
    200: BaseItemDtoQueryResult;
};

export type GetRecordingsResponse = GetRecordingsResponses[keyof GetRecordingsResponses];

export type DeleteRecordingData = {
    body?: never;
    path: {
        /**
         * Recording id.
         */
        recordingId: string;
    };
    query?: never;
    url: '/LiveTv/Recordings/{recordingId}';
};

export type DeleteRecordingErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type DeleteRecordingError = DeleteRecordingErrors[keyof DeleteRecordingErrors];

export type DeleteRecordingResponses = {
    /**
     * Recording deleted.
     */
    204: void;
};

export type DeleteRecordingResponse = DeleteRecordingResponses[keyof DeleteRecordingResponses];

export type GetRecordingData = {
    body?: never;
    path: {
        /**
         * Recording id.
         */
        recordingId: string;
    };
    query?: {
        /**
         * Optional. Attach user data.
         */
        userId?: string;
    };
    url: '/LiveTv/Recordings/{recordingId}';
};

export type GetRecordingErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type GetRecordingError = GetRecordingErrors[keyof GetRecordingErrors];

export type GetRecordingResponses = {
    /**
     * Recording returned.
     */
    200: BaseItemDto;
};

export type GetRecordingResponse = GetRecordingResponses[keyof GetRecordingResponses];

export type GetRecordingFoldersData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional. Filter by user and attach user data.
         */
        userId?: string;
    };
    url: '/LiveTv/Recordings/Folders';
};

export type GetRecordingFoldersErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetRecordingFoldersResponses = {
    /**
     * Recording folders returned.
     */
    200: BaseItemDtoQueryResult;
};

export type GetRecordingFoldersResponse = GetRecordingFoldersResponses[keyof GetRecordingFoldersResponses];

export type GetRecordingGroupsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional. Filter by user and attach user data.
         */
        userId?: string;
    };
    url: '/LiveTv/Recordings/Groups';
};

export type GetRecordingGroupsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetRecordingGroupsResponses = {
    /**
     * Recording groups returned.
     */
    200: BaseItemDtoQueryResult;
};

export type GetRecordingGroupsResponse = GetRecordingGroupsResponses[keyof GetRecordingGroupsResponses];

export type GetRecordingGroupData = {
    body?: never;
    path: {
        /**
         * Group id.
         */
        groupId: string;
    };
    query?: never;
    url: '/LiveTv/Recordings/Groups/{groupId}';
};

export type GetRecordingGroupErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Not Found
     */
    404: ProblemDetails;
};

export type GetRecordingGroupError = GetRecordingGroupErrors[keyof GetRecordingGroupErrors];

export type GetRecordingsSeriesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional. Filter by channel id.
         */
        channelId?: string;
        /**
         * Optional. Filter by user and attach user data.
         */
        userId?: string;
        /**
         * Optional. Filter by recording group.
         */
        groupId?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        startIndex?: number;
        /**
         * Optional. The maximum number of records to return.
         */
        limit?: number;
        /**
         * Optional. Filter by recording status.
         */
        status?: 'New' | 'InProgress' | 'Completed' | 'Cancelled' | 'ConflictedOk' | 'ConflictedNotOk' | 'Error';
        /**
         * Optional. Filter by recordings that are in progress, or not.
         */
        isInProgress?: boolean;
        /**
         * Optional. Filter by recordings belonging to a series timer.
         */
        seriesTimerId?: string;
        /**
         * Optional. Include image information in output.
         */
        enableImages?: boolean;
        /**
         * Optional. The max number of images to return, per image type.
         */
        imageTypeLimit?: number;
        /**
         * Optional. The image types to include in the output.
         */
        enableImageTypes?: Array<ImageType>;
        /**
         * Optional. Specify additional fields of information to return in the output.
         */
        fields?: Array<ItemFields>;
        /**
         * Optional. Include user data.
         */
        enableUserData?: boolean;
        /**
         * Optional. Return total record count.
         */
        enableTotalRecordCount?: boolean;
    };
    url: '/LiveTv/Recordings/Series';
};

export type GetRecordingsSeriesErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetRecordingsSeriesResponses = {
    /**
     * Live tv recordings returned.
     */
    200: BaseItemDtoQueryResult;
};

export type GetRecordingsSeriesResponse = GetRecordingsSeriesResponses[keyof GetRecordingsSeriesResponses];

export type GetSeriesTimersData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional. Sort by SortName or Priority.
         */
        sortBy?: string;
        /**
         * Optional. Sort in Ascending or Descending order.
         */
        sortOrder?: 'Ascending' | 'Descending';
    };
    url: '/LiveTv/SeriesTimers';
};

export type GetSeriesTimersErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetSeriesTimersResponses = {
    /**
     * Timers returned.
     */
    200: SeriesTimerInfoDtoQueryResult;
};

export type GetSeriesTimersResponse = GetSeriesTimersResponses[keyof GetSeriesTimersResponses];

export type CreateSeriesTimerData = {
    /**
     * Class SeriesTimerInfoDto.
     */
    body?: SeriesTimerInfoDto;
    path?: never;
    query?: never;
    url: '/LiveTv/SeriesTimers';
};

export type CreateSeriesTimerErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type CreateSeriesTimerResponses = {
    /**
     * Series timer info created.
     */
    204: void;
};

export type CreateSeriesTimerResponse = CreateSeriesTimerResponses[keyof CreateSeriesTimerResponses];

export type CancelSeriesTimerData = {
    body?: never;
    path: {
        /**
         * Timer id.
         */
        timerId: string;
    };
    query?: never;
    url: '/LiveTv/SeriesTimers/{timerId}';
};

export type CancelSeriesTimerErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type CancelSeriesTimerResponses = {
    /**
     * Timer cancelled.
     */
    204: void;
};

export type CancelSeriesTimerResponse = CancelSeriesTimerResponses[keyof CancelSeriesTimerResponses];

export type GetSeriesTimerData = {
    body?: never;
    path: {
        /**
         * Timer id.
         */
        timerId: string;
    };
    query?: never;
    url: '/LiveTv/SeriesTimers/{timerId}';
};

export type GetSeriesTimerErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Series timer not found.
     */
    404: ProblemDetails;
};

export type GetSeriesTimerError = GetSeriesTimerErrors[keyof GetSeriesTimerErrors];

export type GetSeriesTimerResponses = {
    /**
     * Series timer returned.
     */
    200: SeriesTimerInfoDto;
};

export type GetSeriesTimerResponse = GetSeriesTimerResponses[keyof GetSeriesTimerResponses];

export type UpdateSeriesTimerData = {
    /**
     * Class SeriesTimerInfoDto.
     */
    body?: SeriesTimerInfoDto;
    path: {
        /**
         * Timer id.
         */
        timerId: string;
    };
    query?: never;
    url: '/LiveTv/SeriesTimers/{timerId}';
};

export type UpdateSeriesTimerErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type UpdateSeriesTimerResponses = {
    /**
     * Series timer updated.
     */
    204: void;
};

export type UpdateSeriesTimerResponse = UpdateSeriesTimerResponses[keyof UpdateSeriesTimerResponses];

export type GetTimersData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional. Filter by channel id.
         */
        channelId?: string;
        /**
         * Optional. Filter by timers belonging to a series timer.
         */
        seriesTimerId?: string;
        /**
         * Optional. Filter by timers that are active.
         */
        isActive?: boolean;
        /**
         * Optional. Filter by timers that are scheduled.
         */
        isScheduled?: boolean;
    };
    url: '/LiveTv/Timers';
};

export type GetTimersErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetTimersResponses = {
    /**
     * Success
     */
    200: TimerInfoDtoQueryResult;
};

export type GetTimersResponse = GetTimersResponses[keyof GetTimersResponses];

export type CreateTimerData = {
    /**
     * New timer info.
     */
    body?: TimerInfoDto;
    path?: never;
    query?: never;
    url: '/LiveTv/Timers';
};

export type CreateTimerErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type CreateTimerResponses = {
    /**
     * Timer created.
     */
    204: void;
};

export type CreateTimerResponse = CreateTimerResponses[keyof CreateTimerResponses];

export type CancelTimerData = {
    body?: never;
    path: {
        /**
         * Timer id.
         */
        timerId: string;
    };
    query?: never;
    url: '/LiveTv/Timers/{timerId}';
};

export type CancelTimerErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type CancelTimerResponses = {
    /**
     * Timer deleted.
     */
    204: void;
};

export type CancelTimerResponse = CancelTimerResponses[keyof CancelTimerResponses];

export type GetTimerData = {
    body?: never;
    path: {
        /**
         * Timer id.
         */
        timerId: string;
    };
    query?: never;
    url: '/LiveTv/Timers/{timerId}';
};

export type GetTimerErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetTimerResponses = {
    /**
     * Timer returned.
     */
    200: TimerInfoDto;
};

export type GetTimerResponse = GetTimerResponses[keyof GetTimerResponses];

export type UpdateTimerData = {
    /**
     * New timer info.
     */
    body?: TimerInfoDto;
    path: {
        /**
         * Timer id.
         */
        timerId: string;
    };
    query?: never;
    url: '/LiveTv/Timers/{timerId}';
};

export type UpdateTimerErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type UpdateTimerResponses = {
    /**
     * Timer updated.
     */
    204: void;
};

export type UpdateTimerResponse = UpdateTimerResponses[keyof UpdateTimerResponses];

export type GetDefaultTimerData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional. To attach default values based on a program.
         */
        programId?: string;
    };
    url: '/LiveTv/Timers/Defaults';
};

export type GetDefaultTimerErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetDefaultTimerResponses = {
    /**
     * Default values returned.
     */
    200: SeriesTimerInfoDto;
};

export type GetDefaultTimerResponse = GetDefaultTimerResponses[keyof GetDefaultTimerResponses];

export type DeleteTunerHostData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Tuner host id.
         */
        id?: string;
    };
    url: '/LiveTv/TunerHosts';
};

export type DeleteTunerHostErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type DeleteTunerHostResponses = {
    /**
     * Tuner host deleted.
     */
    204: void;
};

export type DeleteTunerHostResponse = DeleteTunerHostResponses[keyof DeleteTunerHostResponses];

export type AddTunerHostData = {
    /**
     * New tuner host.
     */
    body?: TunerHostInfo;
    path?: never;
    query?: never;
    url: '/LiveTv/TunerHosts';
};

export type AddTunerHostErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type AddTunerHostResponses = {
    /**
     * Created tuner host returned.
     */
    200: TunerHostInfo;
};

export type AddTunerHostResponse = AddTunerHostResponses[keyof AddTunerHostResponses];

export type GetTunerHostTypesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/LiveTv/TunerHosts/Types';
};

export type GetTunerHostTypesErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetTunerHostTypesResponses = {
    /**
     * Tuner host types returned.
     */
    200: Array<NameIdPair>;
};

export type GetTunerHostTypesResponse = GetTunerHostTypesResponses[keyof GetTunerHostTypesResponses];

export type ResetTunerData = {
    body?: never;
    path: {
        /**
         * Tuner id.
         */
        tunerId: string;
    };
    query?: never;
    url: '/LiveTv/Tuners/{tunerId}/Reset';
};

export type ResetTunerErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type ResetTunerResponses = {
    /**
     * Tuner reset.
     */
    204: void;
};

export type ResetTunerResponse = ResetTunerResponses[keyof ResetTunerResponses];

export type DiscoverTunersData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Only discover new tuners.
         */
        newDevicesOnly?: boolean;
    };
    url: '/LiveTv/Tuners/Discover';
};

export type DiscoverTunersErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type DiscoverTunersResponses = {
    /**
     * Tuners returned.
     */
    200: Array<TunerHostInfo>;
};

export type DiscoverTunersResponse = DiscoverTunersResponses[keyof DiscoverTunersResponses];

export type DiscvoverTunersData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Only discover new tuners.
         */
        newDevicesOnly?: boolean;
    };
    url: '/LiveTv/Tuners/Discvover';
};

export type DiscvoverTunersErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type DiscvoverTunersResponses = {
    /**
     * Tuners returned.
     */
    200: Array<TunerHostInfo>;
};

export type DiscvoverTunersResponse = DiscvoverTunersResponses[keyof DiscvoverTunersResponses];

export type GetCountriesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Localization/Countries';
};

export type GetCountriesErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetCountriesResponses = {
    /**
     * Known countries returned.
     */
    200: Array<CountryInfo>;
};

export type GetCountriesResponse = GetCountriesResponses[keyof GetCountriesResponses];

export type GetCulturesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Localization/Cultures';
};

export type GetCulturesErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetCulturesResponses = {
    /**
     * Known cultures returned.
     */
    200: Array<CultureDto>;
};

export type GetCulturesResponse = GetCulturesResponses[keyof GetCulturesResponses];

export type GetLocalizationOptionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Localization/Options';
};

export type GetLocalizationOptionsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetLocalizationOptionsResponses = {
    /**
     * Localization options returned.
     */
    200: Array<LocalizationOption>;
};

export type GetLocalizationOptionsResponse = GetLocalizationOptionsResponses[keyof GetLocalizationOptionsResponses];

export type GetParentalRatingsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Localization/ParentalRatings';
};

export type GetParentalRatingsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetParentalRatingsResponses = {
    /**
     * Known parental ratings returned.
     */
    200: Array<ParentalRating>;
};

export type GetParentalRatingsResponse = GetParentalRatingsResponses[keyof GetParentalRatingsResponses];

export type DeleteLyricsData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
    };
    query?: never;
    url: '/Audio/{itemId}/Lyrics';
};

export type DeleteLyricsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type DeleteLyricsError = DeleteLyricsErrors[keyof DeleteLyricsErrors];

export type DeleteLyricsResponses = {
    /**
     * Lyric deleted.
     */
    204: void;
};

export type DeleteLyricsResponse = DeleteLyricsResponses[keyof DeleteLyricsResponses];

export type GetLyricsData = {
    body?: never;
    path: {
        /**
         * Item id.
         */
        itemId: string;
    };
    query?: never;
    url: '/Audio/{itemId}/Lyrics';
};

export type GetLyricsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Something went wrong. No Lyrics will be returned.
     */
    404: ProblemDetails;
};

export type GetLyricsError = GetLyricsErrors[keyof GetLyricsErrors];

export type GetLyricsResponses = {
    /**
     * Lyrics returned.
     */
    200: LyricDto;
};

export type GetLyricsResponse = GetLyricsResponses[keyof GetLyricsResponses];

export type UploadLyricsData = {
    body?: Blob | File;
    path: {
        /**
         * The item the lyric belongs to.
         */
        itemId: string;
    };
    query: {
        /**
         * Name of the file being uploaded.
         */
        fileName: string;
    };
    url: '/Audio/{itemId}/Lyrics';
};

export type UploadLyricsErrors = {
    /**
     * Error processing upload.
     */
    400: ProblemDetails;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type UploadLyricsError = UploadLyricsErrors[keyof UploadLyricsErrors];

export type UploadLyricsResponses = {
    /**
     * Lyrics uploaded.
     */
    200: LyricDto;
};

export type UploadLyricsResponse = UploadLyricsResponses[keyof UploadLyricsResponses];

export type SearchRemoteLyricsData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
    };
    query?: never;
    url: '/Audio/{itemId}/RemoteSearch/Lyrics';
};

export type SearchRemoteLyricsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type SearchRemoteLyricsError = SearchRemoteLyricsErrors[keyof SearchRemoteLyricsErrors];

export type SearchRemoteLyricsResponses = {
    /**
     * Lyrics retrieved.
     */
    200: Array<RemoteLyricInfoDto>;
};

export type SearchRemoteLyricsResponse = SearchRemoteLyricsResponses[keyof SearchRemoteLyricsResponses];

export type DownloadRemoteLyricsData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
        /**
         * The lyric id.
         */
        lyricId: string;
    };
    query?: never;
    url: '/Audio/{itemId}/RemoteSearch/Lyrics/{lyricId}';
};

export type DownloadRemoteLyricsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type DownloadRemoteLyricsError = DownloadRemoteLyricsErrors[keyof DownloadRemoteLyricsErrors];

export type DownloadRemoteLyricsResponses = {
    /**
     * Lyric downloaded.
     */
    200: LyricDto;
};

export type DownloadRemoteLyricsResponse = DownloadRemoteLyricsResponses[keyof DownloadRemoteLyricsResponses];

export type GetRemoteLyricsData = {
    body?: never;
    path: {
        /**
         * The remote provider item id.
         */
        lyricId: string;
    };
    query?: never;
    url: '/Providers/Lyrics/{lyricId}';
};

export type GetRemoteLyricsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Lyric not found.
     */
    404: ProblemDetails;
};

export type GetRemoteLyricsError = GetRemoteLyricsErrors[keyof GetRemoteLyricsErrors];

export type GetRemoteLyricsResponses = {
    /**
     * File returned.
     */
    200: LyricDto;
};

export type GetRemoteLyricsResponse = GetRemoteLyricsResponses[keyof GetRemoteLyricsResponses];

export type GetPlaybackInfoData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
    };
    query?: {
        /**
         * The user id.
         */
        userId?: string;
    };
    url: '/Items/{itemId}/PlaybackInfo';
};

export type GetPlaybackInfoErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type GetPlaybackInfoError = GetPlaybackInfoErrors[keyof GetPlaybackInfoErrors];

export type GetPlaybackInfoResponses = {
    /**
     * Playback info returned.
     */
    200: PlaybackInfoResponse;
};

export type GetPlaybackInfoResponse = GetPlaybackInfoResponses[keyof GetPlaybackInfoResponses];

export type GetPostedPlaybackInfoData = {
    /**
     * Plabyback info dto.
     */
    body?: PlaybackInfoDto;
    path: {
        /**
         * The item id.
         */
        itemId: string;
    };
    query?: {
        /**
         * The user id.
         * @deprecated
         */
        userId?: string;
        /**
         * The maximum streaming bitrate.
         * @deprecated
         */
        maxStreamingBitrate?: number;
        /**
         * The start time in ticks.
         * @deprecated
         */
        startTimeTicks?: number;
        /**
         * The audio stream index.
         * @deprecated
         */
        audioStreamIndex?: number;
        /**
         * The subtitle stream index.
         * @deprecated
         */
        subtitleStreamIndex?: number;
        /**
         * The maximum number of audio channels.
         * @deprecated
         */
        maxAudioChannels?: number;
        /**
         * The media source id.
         * @deprecated
         */
        mediaSourceId?: string;
        /**
         * The livestream id.
         * @deprecated
         */
        liveStreamId?: string;
        /**
         * Whether to auto open the livestream.
         * @deprecated
         */
        autoOpenLiveStream?: boolean;
        /**
         * Whether to enable direct play. Default: true.
         * @deprecated
         */
        enableDirectPlay?: boolean;
        /**
         * Whether to enable direct stream. Default: true.
         * @deprecated
         */
        enableDirectStream?: boolean;
        /**
         * Whether to enable transcoding. Default: true.
         * @deprecated
         */
        enableTranscoding?: boolean;
        /**
         * Whether to allow to copy the video stream. Default: true.
         * @deprecated
         */
        allowVideoStreamCopy?: boolean;
        /**
         * Whether to allow to copy the audio stream. Default: true.
         * @deprecated
         */
        allowAudioStreamCopy?: boolean;
    };
    url: '/Items/{itemId}/PlaybackInfo';
};

export type GetPostedPlaybackInfoErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type GetPostedPlaybackInfoError = GetPostedPlaybackInfoErrors[keyof GetPostedPlaybackInfoErrors];

export type GetPostedPlaybackInfoResponses = {
    /**
     * Playback info returned.
     */
    200: PlaybackInfoResponse;
};

export type GetPostedPlaybackInfoResponse = GetPostedPlaybackInfoResponses[keyof GetPostedPlaybackInfoResponses];

export type CloseLiveStreamData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The livestream id.
         */
        liveStreamId: string;
    };
    url: '/LiveStreams/Close';
};

export type CloseLiveStreamErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type CloseLiveStreamResponses = {
    /**
     * Livestream closed.
     */
    204: void;
};

export type CloseLiveStreamResponse = CloseLiveStreamResponses[keyof CloseLiveStreamResponses];

export type OpenLiveStreamData = {
    /**
     * Open live stream dto.
     */
    body?: OpenLiveStreamDto;
    path?: never;
    query?: {
        /**
         * The open token.
         */
        openToken?: string;
        /**
         * The user id.
         */
        userId?: string;
        /**
         * The play session id.
         */
        playSessionId?: string;
        /**
         * The maximum streaming bitrate.
         */
        maxStreamingBitrate?: number;
        /**
         * The start time in ticks.
         */
        startTimeTicks?: number;
        /**
         * The audio stream index.
         */
        audioStreamIndex?: number;
        /**
         * The subtitle stream index.
         */
        subtitleStreamIndex?: number;
        /**
         * The maximum number of audio channels.
         */
        maxAudioChannels?: number;
        /**
         * The item id.
         */
        itemId?: string;
        /**
         * Whether to enable direct play. Default: true.
         */
        enableDirectPlay?: boolean;
        /**
         * Whether to enable direct stream. Default: true.
         */
        enableDirectStream?: boolean;
        /**
         * Always burn-in subtitle when transcoding.
         */
        alwaysBurnInSubtitleWhenTranscoding?: boolean;
    };
    url: '/LiveStreams/Open';
};

export type OpenLiveStreamErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type OpenLiveStreamResponses = {
    /**
     * Media source opened.
     */
    200: LiveStreamResponse;
};

export type OpenLiveStreamResponse = OpenLiveStreamResponses[keyof OpenLiveStreamResponses];

export type GetBitrateTestBytesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The bitrate. Defaults to 102400.
         */
        size?: number;
    };
    url: '/Playback/BitrateTest';
};

export type GetBitrateTestBytesErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetBitrateTestBytesResponses = {
    /**
     * Test buffer returned.
     */
    200: Blob | File;
};

export type GetBitrateTestBytesResponse = GetBitrateTestBytesResponses[keyof GetBitrateTestBytesResponses];

export type GetItemSegmentsData = {
    body?: never;
    path: {
        /**
         * The ItemId.
         */
        itemId: string;
    };
    query?: {
        /**
         * Optional filter of requested segment types.
         */
        includeSegmentTypes?: Array<MediaSegmentType>;
    };
    url: '/MediaSegments/{itemId}';
};

export type GetItemSegmentsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Not Found
     */
    404: ProblemDetails;
};

export type GetItemSegmentsError = GetItemSegmentsErrors[keyof GetItemSegmentsErrors];

export type GetItemSegmentsResponses = {
    /**
     * Success
     */
    200: MediaSegmentDtoQueryResult;
};

export type GetItemSegmentsResponse = GetItemSegmentsResponses[keyof GetItemSegmentsResponses];

export type GetMovieRecommendationsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional. Filter by user id, and attach user data.
         */
        userId?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root.
         */
        parentId?: string;
        /**
         * Optional. The fields to return.
         */
        fields?: Array<ItemFields>;
        /**
         * The max number of categories to return.
         */
        categoryLimit?: number;
        /**
         * The max number of items to return per category.
         */
        itemLimit?: number;
    };
    url: '/Movies/Recommendations';
};

export type GetMovieRecommendationsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetMovieRecommendationsResponses = {
    /**
     * Movie recommendations returned.
     */
    200: Array<RecommendationDto>;
};

export type GetMovieRecommendationsResponse = GetMovieRecommendationsResponses[keyof GetMovieRecommendationsResponses];

export type GetMusicGenresData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        startIndex?: number;
        /**
         * Optional. The maximum number of records to return.
         */
        limit?: number;
        /**
         * The search term.
         */
        searchTerm?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root.
         */
        parentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output.
         */
        fields?: Array<ItemFields>;
        /**
         * Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
         */
        excludeItemTypes?: Array<BaseItemKind>;
        /**
         * Optional. If specified, results will be filtered in based on item type. This allows multiple, comma delimited.
         */
        includeItemTypes?: Array<BaseItemKind>;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        isFavorite?: boolean;
        /**
         * Optional, the max number of images to return, per image type.
         */
        imageTypeLimit?: number;
        /**
         * Optional. The image types to include in the output.
         */
        enableImageTypes?: Array<ImageType>;
        /**
         * User id.
         */
        userId?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        nameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        nameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        nameLessThan?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimited.
         */
        sortBy?: Array<ItemSortBy>;
        /**
         * Sort Order - Ascending,Descending.
         */
        sortOrder?: Array<SortOrder>;
        /**
         * Optional, include image information in output.
         */
        enableImages?: boolean;
        /**
         * Optional. Include total record count.
         */
        enableTotalRecordCount?: boolean;
    };
    url: '/MusicGenres';
};

export type GetMusicGenresErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetMusicGenresResponses = {
    /**
     * Music genres returned.
     */
    200: BaseItemDtoQueryResult;
};

export type GetMusicGenresResponse = GetMusicGenresResponses[keyof GetMusicGenresResponses];

export type GetMusicGenreData = {
    body?: never;
    path: {
        /**
         * The genre name.
         */
        genreName: string;
    };
    query?: {
        /**
         * Optional. Filter by user id, and attach user data.
         */
        userId?: string;
    };
    url: '/MusicGenres/{genreName}';
};

export type GetMusicGenreErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetMusicGenreResponses = {
    /**
     * Success
     */
    200: BaseItemDto;
};

export type GetMusicGenreResponse = GetMusicGenreResponses[keyof GetMusicGenreResponses];

export type GetPackagesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Packages';
};

export type GetPackagesErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetPackagesResponses = {
    /**
     * Available packages returned.
     */
    200: Array<PackageInfo>;
};

export type GetPackagesResponse = GetPackagesResponses[keyof GetPackagesResponses];

export type GetPackageInfoData = {
    body?: never;
    path: {
        /**
         * The name of the package.
         */
        name: string;
    };
    query?: {
        /**
         * The GUID of the associated assembly.
         */
        assemblyGuid?: string;
    };
    url: '/Packages/{name}';
};

export type GetPackageInfoErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetPackageInfoResponses = {
    /**
     * Package retrieved.
     */
    200: PackageInfo;
};

export type GetPackageInfoResponse = GetPackageInfoResponses[keyof GetPackageInfoResponses];

export type InstallPackageData = {
    body?: never;
    path: {
        /**
         * Package name.
         */
        name: string;
    };
    query?: {
        /**
         * GUID of the associated assembly.
         */
        assemblyGuid?: string;
        /**
         * Optional version. Defaults to latest version.
         */
        version?: string;
        /**
         * Optional. Specify the repository to install from.
         */
        repositoryUrl?: string;
    };
    url: '/Packages/Installed/{name}';
};

export type InstallPackageErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Package not found.
     */
    404: ProblemDetails;
};

export type InstallPackageError = InstallPackageErrors[keyof InstallPackageErrors];

export type InstallPackageResponses = {
    /**
     * Package found.
     */
    204: void;
};

export type InstallPackageResponse = InstallPackageResponses[keyof InstallPackageResponses];

export type CancelPackageInstallationData = {
    body?: never;
    path: {
        /**
         * Installation Id.
         */
        packageId: string;
    };
    query?: never;
    url: '/Packages/Installing/{packageId}';
};

export type CancelPackageInstallationErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type CancelPackageInstallationResponses = {
    /**
     * Installation cancelled.
     */
    204: void;
};

export type CancelPackageInstallationResponse = CancelPackageInstallationResponses[keyof CancelPackageInstallationResponses];

export type GetRepositoriesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Repositories';
};

export type GetRepositoriesErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetRepositoriesResponses = {
    /**
     * Package repositories returned.
     */
    200: Array<RepositoryInfo>;
};

export type GetRepositoriesResponse = GetRepositoriesResponses[keyof GetRepositoriesResponses];

export type SetRepositoriesData = {
    /**
     * The list of package repositories.
     */
    body: Array<RepositoryInfo>;
    path?: never;
    query?: never;
    url: '/Repositories';
};

export type SetRepositoriesErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type SetRepositoriesResponses = {
    /**
     * Package repositories saved.
     */
    204: void;
};

export type SetRepositoriesResponse = SetRepositoriesResponses[keyof SetRepositoriesResponses];

export type GetPersonsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional. The maximum number of records to return.
         */
        limit?: number;
        /**
         * The search term.
         */
        searchTerm?: string;
        /**
         * Optional. Specify additional fields of information to return in the output.
         */
        fields?: Array<ItemFields>;
        /**
         * Optional. Specify additional filters to apply.
         */
        filters?: Array<ItemFilter>;
        /**
         * Optional filter by items that are marked as favorite, or not. userId is required.
         */
        isFavorite?: boolean;
        /**
         * Optional, include user data.
         */
        enableUserData?: boolean;
        /**
         * Optional, the max number of images to return, per image type.
         */
        imageTypeLimit?: number;
        /**
         * Optional. The image types to include in the output.
         */
        enableImageTypes?: Array<ImageType>;
        /**
         * Optional. If specified results will be filtered to exclude those containing the specified PersonType. Allows multiple, comma-delimited.
         */
        excludePersonTypes?: Array<string>;
        /**
         * Optional. If specified results will be filtered to include only those containing the specified PersonType. Allows multiple, comma-delimited.
         */
        personTypes?: Array<string>;
        /**
         * Optional. If specified, person results will be filtered on items related to said persons.
         */
        appearsInItemId?: string;
        /**
         * User id.
         */
        userId?: string;
        /**
         * Optional, include image information in output.
         */
        enableImages?: boolean;
    };
    url: '/Persons';
};

export type GetPersonsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetPersonsResponses = {
    /**
     * Persons returned.
     */
    200: BaseItemDtoQueryResult;
};

export type GetPersonsResponse = GetPersonsResponses[keyof GetPersonsResponses];

export type GetPersonData = {
    body?: never;
    path: {
        /**
         * Person name.
         */
        name: string;
    };
    query?: {
        /**
         * Optional. Filter by user id, and attach user data.
         */
        userId?: string;
    };
    url: '/Persons/{name}';
};

export type GetPersonErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Person not found.
     */
    404: ProblemDetails;
};

export type GetPersonError = GetPersonErrors[keyof GetPersonErrors];

export type GetPersonResponses = {
    /**
     * Person returned.
     */
    200: BaseItemDto;
};

export type GetPersonResponse = GetPersonResponses[keyof GetPersonResponses];

export type GetBreakdownReportData = {
    body?: never;
    path: {
        breakdownType: string;
    };
    query?: {
        days?: number;
        endDate?: string;
        timezoneOffset?: number;
    };
    url: '/user_usage_stats/{breakdownType}/BreakdownReport';
};

export type GetBreakdownReportErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetBreakdownReportResponses = {
    /**
     * Success
     */
    200: unknown;
};

export type GetUserReportDataData = {
    body?: never;
    path: {
        userId: string;
        date: string;
    };
    query?: {
        filter?: string;
        timezoneOffset?: number;
    };
    url: '/user_usage_stats/{userId}/{date}/GetItems';
};

export type GetUserReportDataErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetUserReportDataResponses = {
    /**
     * Success
     */
    200: unknown;
};

export type GetDurationHistogramReportData = {
    body?: never;
    path?: never;
    query?: {
        days?: number;
        endDate?: string;
        filter?: string;
    };
    url: '/user_usage_stats/DurationHistogramReport';
};

export type GetDurationHistogramReportErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetDurationHistogramReportResponses = {
    /**
     * Success
     */
    200: unknown;
};

export type GetTvShowsReportData = {
    body?: never;
    path?: never;
    query?: {
        days?: number;
        endDate?: string;
        timezoneOffset?: number;
    };
    url: '/user_usage_stats/GetTvShowsReport';
};

export type GetTvShowsReportErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetTvShowsReportResponses = {
    /**
     * Success
     */
    200: unknown;
};

export type GetHourlyReportData = {
    body?: never;
    path?: never;
    query?: {
        days?: number;
        endDate?: string;
        filter?: string;
        timezoneOffset?: number;
    };
    url: '/user_usage_stats/HourlyReport';
};

export type GetHourlyReportErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetHourlyReportResponses = {
    /**
     * Success
     */
    200: unknown;
};

export type LoadBackupData = {
    body?: never;
    path?: never;
    query?: {
        backupFilePath?: string;
    };
    url: '/user_usage_stats/load_backup';
};

export type LoadBackupErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type LoadBackupResponses = {
    /**
     * Success
     */
    200: Array<string>;
};

export type LoadBackupResponse = LoadBackupResponses[keyof LoadBackupResponses];

export type GetMovieReportData = {
    body?: never;
    path?: never;
    query?: {
        days?: number;
        endDate?: string;
        timezoneOffset?: number;
    };
    url: '/user_usage_stats/MoviesReport';
};

export type GetMovieReportErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetMovieReportResponses = {
    /**
     * Success
     */
    200: unknown;
};

export type GetUsageStatsData = {
    body?: never;
    path?: never;
    query?: {
        days?: number;
        endDate?: string;
        filter?: string;
        dataType?: string;
        timezoneOffset?: number;
    };
    url: '/user_usage_stats/PlayActivity';
};

export type GetUsageStatsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetUsageStatsResponses = {
    /**
     * Success
     */
    200: unknown;
};

export type SaveBackupData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/user_usage_stats/save_backup';
};

export type SaveBackupErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type SaveBackupResponses = {
    /**
     * Success
     */
    200: Array<string>;
};

export type SaveBackupResponse = SaveBackupResponses[keyof SaveBackupResponses];

export type CustomQueryData2 = {
    body?: CustomQueryData;
    path?: never;
    query?: never;
    url: '/user_usage_stats/submit_custom_query';
};

export type CustomQueryErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type CustomQueryResponses = {
    /**
     * Success
     */
    200: {
        [key: string]: unknown;
    };
};

export type CustomQueryResponse = CustomQueryResponses[keyof CustomQueryResponses];

export type GetTypeFilterListData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/user_usage_stats/type_filter_list';
};

export type GetTypeFilterListErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetTypeFilterListResponses = {
    /**
     * Success
     */
    200: unknown;
};

export type GetUserReportData = {
    body?: never;
    path?: never;
    query?: {
        days?: number;
        endDate?: string;
        timezoneOffset?: number;
    };
    url: '/user_usage_stats/user_activity';
};

export type GetUserReportErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetUserReportResponses = {
    /**
     * Success
     */
    200: unknown;
};

export type GetJellyfinUsersData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/user_usage_stats/user_list';
};

export type GetJellyfinUsersErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetJellyfinUsersResponses = {
    /**
     * Success
     */
    200: unknown;
};

export type IgnoreListAddData = {
    body?: never;
    path?: never;
    query?: {
        id?: string;
    };
    url: '/user_usage_stats/user_manage/add';
};

export type IgnoreListAddErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type IgnoreListAddResponses = {
    /**
     * Success
     */
    200: boolean;
};

export type IgnoreListAddResponse = IgnoreListAddResponses[keyof IgnoreListAddResponses];

export type PruneUnknownUsersData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/user_usage_stats/user_manage/prune';
};

export type PruneUnknownUsersErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type PruneUnknownUsersResponses = {
    /**
     * Success
     */
    200: boolean;
};

export type PruneUnknownUsersResponse = PruneUnknownUsersResponses[keyof PruneUnknownUsersResponses];

export type IgnoreListRemoveData = {
    body?: never;
    path?: never;
    query?: {
        id?: string;
    };
    url: '/user_usage_stats/user_manage/remove';
};

export type IgnoreListRemoveErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type IgnoreListRemoveResponses = {
    /**
     * Success
     */
    200: boolean;
};

export type IgnoreListRemoveResponse = IgnoreListRemoveResponses[keyof IgnoreListRemoveResponses];

export type CreatePlaylistData = {
    /**
     * Create new playlist dto.
     */
    body?: CreatePlaylistDto;
    path?: never;
    query?: {
        /**
         * The playlist name.
         * @deprecated
         */
        name?: string;
        /**
         * The item ids.
         * @deprecated
         */
        ids?: Array<string>;
        /**
         * The user id.
         * @deprecated
         */
        userId?: string;
        /**
         * The media type.
         * @deprecated
         */
        mediaType?: 'Unknown' | 'Video' | 'Audio' | 'Photo' | 'Book';
    };
    url: '/Playlists';
};

export type CreatePlaylistErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type CreatePlaylistResponses = {
    /**
     * Playlist created.
     */
    200: PlaylistCreationResult;
};

export type CreatePlaylistResponse = CreatePlaylistResponses[keyof CreatePlaylistResponses];

export type GetPlaylistData = {
    body?: never;
    path: {
        /**
         * The playlist id.
         */
        playlistId: string;
    };
    query?: never;
    url: '/Playlists/{playlistId}';
};

export type GetPlaylistErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Playlist not found.
     */
    404: ProblemDetails;
};

export type GetPlaylistError = GetPlaylistErrors[keyof GetPlaylistErrors];

export type GetPlaylistResponses = {
    /**
     * The playlist.
     */
    200: PlaylistDto;
};

export type GetPlaylistResponse = GetPlaylistResponses[keyof GetPlaylistResponses];

export type UpdatePlaylistData = {
    /**
     * Update existing playlist dto. Fields set to `null` will not be updated and keep their current values.
     */
    body: UpdatePlaylistDto;
    path: {
        /**
         * The playlist id.
         */
        playlistId: string;
    };
    query?: never;
    url: '/Playlists/{playlistId}';
};

export type UpdatePlaylistErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Access forbidden.
     */
    403: ProblemDetails;
    /**
     * Playlist not found.
     */
    404: ProblemDetails;
};

export type UpdatePlaylistError = UpdatePlaylistErrors[keyof UpdatePlaylistErrors];

export type UpdatePlaylistResponses = {
    /**
     * Playlist updated.
     */
    204: void;
};

export type UpdatePlaylistResponse = UpdatePlaylistResponses[keyof UpdatePlaylistResponses];

export type RemoveItemFromPlaylistData = {
    body?: never;
    path: {
        /**
         * The playlist id.
         */
        playlistId: string;
    };
    query?: {
        /**
         * The item ids, comma delimited.
         */
        entryIds?: Array<string>;
    };
    url: '/Playlists/{playlistId}/Items';
};

export type RemoveItemFromPlaylistErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Access forbidden.
     */
    403: ProblemDetails;
    /**
     * Playlist not found.
     */
    404: ProblemDetails;
};

export type RemoveItemFromPlaylistError = RemoveItemFromPlaylistErrors[keyof RemoveItemFromPlaylistErrors];

export type RemoveItemFromPlaylistResponses = {
    /**
     * Items removed.
     */
    204: void;
};

export type RemoveItemFromPlaylistResponse = RemoveItemFromPlaylistResponses[keyof RemoveItemFromPlaylistResponses];

export type GetPlaylistItemsData = {
    body?: never;
    path: {
        /**
         * The playlist id.
         */
        playlistId: string;
    };
    query?: {
        /**
         * User id.
         */
        userId?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        startIndex?: number;
        /**
         * Optional. The maximum number of records to return.
         */
        limit?: number;
        /**
         * Optional. Specify additional fields of information to return in the output.
         */
        fields?: Array<ItemFields>;
        /**
         * Optional. Include image information in output.
         */
        enableImages?: boolean;
        /**
         * Optional. Include user data.
         */
        enableUserData?: boolean;
        /**
         * Optional. The max number of images to return, per image type.
         */
        imageTypeLimit?: number;
        /**
         * Optional. The image types to include in the output.
         */
        enableImageTypes?: Array<ImageType>;
    };
    url: '/Playlists/{playlistId}/Items';
};

export type GetPlaylistItemsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: ProblemDetails;
    /**
     * Playlist not found.
     */
    404: ProblemDetails;
};

export type GetPlaylistItemsError = GetPlaylistItemsErrors[keyof GetPlaylistItemsErrors];

export type GetPlaylistItemsResponses = {
    /**
     * Original playlist returned.
     */
    200: BaseItemDtoQueryResult;
};

export type GetPlaylistItemsResponse = GetPlaylistItemsResponses[keyof GetPlaylistItemsResponses];

export type AddItemToPlaylistData = {
    body?: never;
    path: {
        /**
         * The playlist id.
         */
        playlistId: string;
    };
    query?: {
        /**
         * Item id, comma delimited.
         */
        ids?: Array<string>;
        /**
         * The userId.
         */
        userId?: string;
    };
    url: '/Playlists/{playlistId}/Items';
};

export type AddItemToPlaylistErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Access forbidden.
     */
    403: ProblemDetails;
    /**
     * Playlist not found.
     */
    404: ProblemDetails;
};

export type AddItemToPlaylistError = AddItemToPlaylistErrors[keyof AddItemToPlaylistErrors];

export type AddItemToPlaylistResponses = {
    /**
     * Items added to playlist.
     */
    204: void;
};

export type AddItemToPlaylistResponse = AddItemToPlaylistResponses[keyof AddItemToPlaylistResponses];

export type MoveItemData = {
    body?: never;
    path: {
        /**
         * The playlist id.
         */
        playlistId: string;
        /**
         * The item id.
         */
        itemId: string;
        /**
         * The new index.
         */
        newIndex: number;
    };
    query?: never;
    url: '/Playlists/{playlistId}/Items/{itemId}/Move/{newIndex}';
};

export type MoveItemErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Access forbidden.
     */
    403: ProblemDetails;
    /**
     * Playlist not found.
     */
    404: ProblemDetails;
};

export type MoveItemError = MoveItemErrors[keyof MoveItemErrors];

export type MoveItemResponses = {
    /**
     * Item moved to new index.
     */
    204: void;
};

export type MoveItemResponse = MoveItemResponses[keyof MoveItemResponses];

export type GetPlaylistUsersData = {
    body?: never;
    path: {
        /**
         * The playlist id.
         */
        playlistId: string;
    };
    query?: never;
    url: '/Playlists/{playlistId}/Users';
};

export type GetPlaylistUsersErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Access forbidden.
     */
    403: ProblemDetails;
    /**
     * Playlist not found.
     */
    404: ProblemDetails;
};

export type GetPlaylistUsersError = GetPlaylistUsersErrors[keyof GetPlaylistUsersErrors];

export type GetPlaylistUsersResponses = {
    /**
     * Found shares.
     */
    200: Array<PlaylistUserPermissions>;
};

export type GetPlaylistUsersResponse = GetPlaylistUsersResponses[keyof GetPlaylistUsersResponses];

export type RemoveUserFromPlaylistData = {
    body?: never;
    path: {
        /**
         * The playlist id.
         */
        playlistId: string;
        /**
         * The user id.
         */
        userId: string;
    };
    query?: never;
    url: '/Playlists/{playlistId}/Users/{userId}';
};

export type RemoveUserFromPlaylistErrors = {
    /**
     * Unauthorized access.
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: ProblemDetails;
    /**
     * No playlist or user permissions found.
     */
    404: ProblemDetails;
};

export type RemoveUserFromPlaylistError = RemoveUserFromPlaylistErrors[keyof RemoveUserFromPlaylistErrors];

export type RemoveUserFromPlaylistResponses = {
    /**
     * User permissions removed from playlist.
     */
    204: void;
};

export type RemoveUserFromPlaylistResponse = RemoveUserFromPlaylistResponses[keyof RemoveUserFromPlaylistResponses];

export type GetPlaylistUserData = {
    body?: never;
    path: {
        /**
         * The playlist id.
         */
        playlistId: string;
        /**
         * The user id.
         */
        userId: string;
    };
    query?: never;
    url: '/Playlists/{playlistId}/Users/{userId}';
};

export type GetPlaylistUserErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Access forbidden.
     */
    403: ProblemDetails;
    /**
     * Playlist not found.
     */
    404: ProblemDetails;
};

export type GetPlaylistUserError = GetPlaylistUserErrors[keyof GetPlaylistUserErrors];

export type GetPlaylistUserResponses = {
    /**
     * User permission found.
     */
    200: PlaylistUserPermissions;
};

export type GetPlaylistUserResponse = GetPlaylistUserResponses[keyof GetPlaylistUserResponses];

export type UpdatePlaylistUserData = {
    /**
     * Update existing playlist user dto. Fields set to `null` will not be updated and keep their current values.
     */
    body: UpdatePlaylistUserDto;
    path: {
        /**
         * The playlist id.
         */
        playlistId: string;
        /**
         * The user id.
         */
        userId: string;
    };
    query?: never;
    url: '/Playlists/{playlistId}/Users/{userId}';
};

export type UpdatePlaylistUserErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Access forbidden.
     */
    403: ProblemDetails;
    /**
     * Playlist not found.
     */
    404: ProblemDetails;
};

export type UpdatePlaylistUserError = UpdatePlaylistUserErrors[keyof UpdatePlaylistUserErrors];

export type UpdatePlaylistUserResponses = {
    /**
     * User's permissions modified.
     */
    204: void;
};

export type UpdatePlaylistUserResponse = UpdatePlaylistUserResponses[keyof UpdatePlaylistUserResponses];

export type OnPlaybackStoppedData = {
    body?: never;
    path: {
        /**
         * Item id.
         */
        itemId: string;
    };
    query?: {
        /**
         * The id of the MediaSource.
         */
        mediaSourceId?: string;
        /**
         * The next media type that will play.
         */
        nextMediaType?: string;
        /**
         * Optional. The position, in ticks, where playback stopped. 1 tick = 10000 ms.
         */
        positionTicks?: number;
        /**
         * The live stream id.
         */
        liveStreamId?: string;
        /**
         * The play session id.
         */
        playSessionId?: string;
    };
    url: '/PlayingItems/{itemId}';
};

export type OnPlaybackStoppedErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type OnPlaybackStoppedResponses = {
    /**
     * Playback stop recorded.
     */
    204: void;
};

export type OnPlaybackStoppedResponse = OnPlaybackStoppedResponses[keyof OnPlaybackStoppedResponses];

export type OnPlaybackStartData = {
    body?: never;
    path: {
        /**
         * Item id.
         */
        itemId: string;
    };
    query?: {
        /**
         * The id of the MediaSource.
         */
        mediaSourceId?: string;
        /**
         * The audio stream index.
         */
        audioStreamIndex?: number;
        /**
         * The subtitle stream index.
         */
        subtitleStreamIndex?: number;
        /**
         * The play method.
         */
        playMethod?: 'Transcode' | 'DirectStream' | 'DirectPlay';
        /**
         * The live stream id.
         */
        liveStreamId?: string;
        /**
         * The play session id.
         */
        playSessionId?: string;
        /**
         * Indicates if the client can seek.
         */
        canSeek?: boolean;
    };
    url: '/PlayingItems/{itemId}';
};

export type OnPlaybackStartErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type OnPlaybackStartResponses = {
    /**
     * Play start recorded.
     */
    204: void;
};

export type OnPlaybackStartResponse = OnPlaybackStartResponses[keyof OnPlaybackStartResponses];

export type OnPlaybackProgressData = {
    body?: never;
    path: {
        /**
         * Item id.
         */
        itemId: string;
    };
    query?: {
        /**
         * The id of the MediaSource.
         */
        mediaSourceId?: string;
        /**
         * Optional. The current position, in ticks. 1 tick = 10000 ms.
         */
        positionTicks?: number;
        /**
         * The audio stream index.
         */
        audioStreamIndex?: number;
        /**
         * The subtitle stream index.
         */
        subtitleStreamIndex?: number;
        /**
         * Scale of 0-100.
         */
        volumeLevel?: number;
        /**
         * The play method.
         */
        playMethod?: 'Transcode' | 'DirectStream' | 'DirectPlay';
        /**
         * The live stream id.
         */
        liveStreamId?: string;
        /**
         * The play session id.
         */
        playSessionId?: string;
        /**
         * The repeat mode.
         */
        repeatMode?: 'RepeatNone' | 'RepeatAll' | 'RepeatOne';
        /**
         * Indicates if the player is paused.
         */
        isPaused?: boolean;
        /**
         * Indicates if the player is muted.
         */
        isMuted?: boolean;
    };
    url: '/PlayingItems/{itemId}/Progress';
};

export type OnPlaybackProgressErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type OnPlaybackProgressResponses = {
    /**
     * Play progress recorded.
     */
    204: void;
};

export type OnPlaybackProgressResponse = OnPlaybackProgressResponses[keyof OnPlaybackProgressResponses];

export type ReportPlaybackStartData = {
    /**
     * Class PlaybackStartInfo.
     */
    body?: PlaybackStartInfo;
    path?: never;
    query?: never;
    url: '/Sessions/Playing';
};

export type ReportPlaybackStartErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type ReportPlaybackStartResponses = {
    /**
     * Playback start recorded.
     */
    204: void;
};

export type ReportPlaybackStartResponse = ReportPlaybackStartResponses[keyof ReportPlaybackStartResponses];

export type PingPlaybackSessionData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Playback session id.
         */
        playSessionId: string;
    };
    url: '/Sessions/Playing/Ping';
};

export type PingPlaybackSessionErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type PingPlaybackSessionResponses = {
    /**
     * Playback session pinged.
     */
    204: void;
};

export type PingPlaybackSessionResponse = PingPlaybackSessionResponses[keyof PingPlaybackSessionResponses];

export type ReportPlaybackProgressData = {
    /**
     * Class PlaybackProgressInfo.
     */
    body?: PlaybackProgressInfo;
    path?: never;
    query?: never;
    url: '/Sessions/Playing/Progress';
};

export type ReportPlaybackProgressErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type ReportPlaybackProgressResponses = {
    /**
     * Playback progress recorded.
     */
    204: void;
};

export type ReportPlaybackProgressResponse = ReportPlaybackProgressResponses[keyof ReportPlaybackProgressResponses];

export type ReportPlaybackStoppedData = {
    /**
     * Class PlaybackStopInfo.
     */
    body?: PlaybackStopInfo;
    path?: never;
    query?: never;
    url: '/Sessions/Playing/Stopped';
};

export type ReportPlaybackStoppedErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type ReportPlaybackStoppedResponses = {
    /**
     * Playback stop recorded.
     */
    204: void;
};

export type ReportPlaybackStoppedResponse = ReportPlaybackStoppedResponses[keyof ReportPlaybackStoppedResponses];

export type MarkUnplayedItemData = {
    body?: never;
    path: {
        /**
         * Item id.
         */
        itemId: string;
    };
    query?: {
        /**
         * User id.
         */
        userId?: string;
    };
    url: '/UserPlayedItems/{itemId}';
};

export type MarkUnplayedItemErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type MarkUnplayedItemError = MarkUnplayedItemErrors[keyof MarkUnplayedItemErrors];

export type MarkUnplayedItemResponses = {
    /**
     * Item marked as unplayed.
     */
    200: UserItemDataDto;
};

export type MarkUnplayedItemResponse = MarkUnplayedItemResponses[keyof MarkUnplayedItemResponses];

export type MarkPlayedItemData = {
    body?: never;
    path: {
        /**
         * Item id.
         */
        itemId: string;
    };
    query?: {
        /**
         * User id.
         */
        userId?: string;
        /**
         * Optional. The date the item was played.
         */
        datePlayed?: string;
    };
    url: '/UserPlayedItems/{itemId}';
};

export type MarkPlayedItemErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type MarkPlayedItemError = MarkPlayedItemErrors[keyof MarkPlayedItemErrors];

export type MarkPlayedItemResponses = {
    /**
     * Item marked as played.
     */
    200: UserItemDataDto;
};

export type MarkPlayedItemResponse = MarkPlayedItemResponses[keyof MarkPlayedItemResponses];

export type GetPluginsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Plugins';
};

export type GetPluginsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetPluginsResponses = {
    /**
     * Installed plugins returned.
     */
    200: Array<PluginInfo>;
};

export type GetPluginsResponse = GetPluginsResponses[keyof GetPluginsResponses];

export type UninstallPluginData = {
    body?: never;
    path: {
        /**
         * Plugin id.
         */
        pluginId: string;
    };
    query?: never;
    url: '/Plugins/{pluginId}';
};

export type UninstallPluginErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Plugin not found.
     */
    404: ProblemDetails;
};

export type UninstallPluginError = UninstallPluginErrors[keyof UninstallPluginErrors];

export type UninstallPluginResponses = {
    /**
     * Plugin uninstalled.
     */
    204: void;
};

export type UninstallPluginResponse = UninstallPluginResponses[keyof UninstallPluginResponses];

export type UninstallPluginByVersionData = {
    body?: never;
    path: {
        /**
         * Plugin id.
         */
        pluginId: string;
        /**
         * Plugin version.
         */
        version: string;
    };
    query?: never;
    url: '/Plugins/{pluginId}/{version}';
};

export type UninstallPluginByVersionErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Plugin not found.
     */
    404: ProblemDetails;
};

export type UninstallPluginByVersionError = UninstallPluginByVersionErrors[keyof UninstallPluginByVersionErrors];

export type UninstallPluginByVersionResponses = {
    /**
     * Plugin uninstalled.
     */
    204: void;
};

export type UninstallPluginByVersionResponse = UninstallPluginByVersionResponses[keyof UninstallPluginByVersionResponses];

export type DisablePluginData = {
    body?: never;
    path: {
        /**
         * Plugin id.
         */
        pluginId: string;
        /**
         * Plugin version.
         */
        version: string;
    };
    query?: never;
    url: '/Plugins/{pluginId}/{version}/Disable';
};

export type DisablePluginErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Plugin not found.
     */
    404: ProblemDetails;
};

export type DisablePluginError = DisablePluginErrors[keyof DisablePluginErrors];

export type DisablePluginResponses = {
    /**
     * Plugin disabled.
     */
    204: void;
};

export type DisablePluginResponse = DisablePluginResponses[keyof DisablePluginResponses];

export type EnablePluginData = {
    body?: never;
    path: {
        /**
         * Plugin id.
         */
        pluginId: string;
        /**
         * Plugin version.
         */
        version: string;
    };
    query?: never;
    url: '/Plugins/{pluginId}/{version}/Enable';
};

export type EnablePluginErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Plugin not found.
     */
    404: ProblemDetails;
};

export type EnablePluginError = EnablePluginErrors[keyof EnablePluginErrors];

export type EnablePluginResponses = {
    /**
     * Plugin enabled.
     */
    204: void;
};

export type EnablePluginResponse = EnablePluginResponses[keyof EnablePluginResponses];

export type GetPluginImageData = {
    body?: never;
    path: {
        /**
         * Plugin id.
         */
        pluginId: string;
        /**
         * Plugin version.
         */
        version: string;
    };
    query?: never;
    url: '/Plugins/{pluginId}/{version}/Image';
};

export type GetPluginImageErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Not Found
     */
    404: ProblemDetails;
};

export type GetPluginImageError = GetPluginImageErrors[keyof GetPluginImageErrors];

export type GetPluginImageResponses = {
    /**
     * Plugin image returned.
     */
    200: Blob | File;
};

export type GetPluginImageResponse = GetPluginImageResponses[keyof GetPluginImageResponses];

export type GetPluginConfigurationData = {
    body?: never;
    path: {
        /**
         * Plugin id.
         */
        pluginId: string;
    };
    query?: never;
    url: '/Plugins/{pluginId}/Configuration';
};

export type GetPluginConfigurationErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Plugin not found or plugin configuration not found.
     */
    404: ProblemDetails;
};

export type GetPluginConfigurationError = GetPluginConfigurationErrors[keyof GetPluginConfigurationErrors];

export type GetPluginConfigurationResponses = {
    /**
     * Plugin configuration returned.
     */
    200: BasePluginConfiguration;
};

export type GetPluginConfigurationResponse = GetPluginConfigurationResponses[keyof GetPluginConfigurationResponses];

export type UpdatePluginConfigurationData = {
    body?: never;
    path: {
        /**
         * Plugin id.
         */
        pluginId: string;
    };
    query?: never;
    url: '/Plugins/{pluginId}/Configuration';
};

export type UpdatePluginConfigurationErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Plugin not found or plugin does not have configuration.
     */
    404: ProblemDetails;
};

export type UpdatePluginConfigurationError = UpdatePluginConfigurationErrors[keyof UpdatePluginConfigurationErrors];

export type UpdatePluginConfigurationResponses = {
    /**
     * Plugin configuration updated.
     */
    204: void;
};

export type UpdatePluginConfigurationResponse = UpdatePluginConfigurationResponses[keyof UpdatePluginConfigurationResponses];

export type GetPluginManifestData = {
    body?: never;
    path: {
        /**
         * Plugin id.
         */
        pluginId: string;
    };
    query?: never;
    url: '/Plugins/{pluginId}/Manifest';
};

export type GetPluginManifestErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Plugin not found.
     */
    404: ProblemDetails;
};

export type GetPluginManifestError = GetPluginManifestErrors[keyof GetPluginManifestErrors];

export type GetPluginManifestResponses = {
    /**
     * Plugin manifest returned.
     */
    204: void;
};

export type GetPluginManifestResponse = GetPluginManifestResponses[keyof GetPluginManifestResponses];

export type AuthorizeQuickConnectData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Quick connect code to authorize.
         */
        code: string;
        /**
         * The user the authorize. Access to the requested user is required.
         */
        userId?: string;
    };
    url: '/QuickConnect/Authorize';
};

export type AuthorizeQuickConnectErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Unknown user id.
     */
    403: ProblemDetails;
};

export type AuthorizeQuickConnectError = AuthorizeQuickConnectErrors[keyof AuthorizeQuickConnectErrors];

export type AuthorizeQuickConnectResponses = {
    /**
     * Quick connect result authorized successfully.
     */
    200: boolean;
};

export type AuthorizeQuickConnectResponse = AuthorizeQuickConnectResponses[keyof AuthorizeQuickConnectResponses];

export type GetQuickConnectStateData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Secret previously returned from the Initiate endpoint.
         */
        secret: string;
    };
    url: '/QuickConnect/Connect';
};

export type GetQuickConnectStateErrors = {
    /**
     * Unknown quick connect secret.
     */
    404: ProblemDetails;
};

export type GetQuickConnectStateError = GetQuickConnectStateErrors[keyof GetQuickConnectStateErrors];

export type GetQuickConnectStateResponses = {
    /**
     * Quick connect result returned.
     */
    200: QuickConnectResult;
};

export type GetQuickConnectStateResponse = GetQuickConnectStateResponses[keyof GetQuickConnectStateResponses];

export type GetQuickConnectEnabledData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/QuickConnect/Enabled';
};

export type GetQuickConnectEnabledResponses = {
    /**
     * Quick connect state returned.
     */
    200: boolean;
};

export type GetQuickConnectEnabledResponse = GetQuickConnectEnabledResponses[keyof GetQuickConnectEnabledResponses];

export type InitiateQuickConnectData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/QuickConnect/Initiate';
};

export type InitiateQuickConnectErrors = {
    /**
     * Quick connect is not active on this server.
     */
    401: unknown;
};

export type InitiateQuickConnectResponses = {
    /**
     * Quick connect request successfully created.
     */
    200: QuickConnectResult;
};

export type InitiateQuickConnectResponse = InitiateQuickConnectResponses[keyof InitiateQuickConnectResponses];

export type GetRemoteImagesData = {
    body?: never;
    path: {
        /**
         * Item Id.
         */
        itemId: string;
    };
    query?: {
        /**
         * The image type.
         */
        type?: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Profile';
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        startIndex?: number;
        /**
         * Optional. The maximum number of records to return.
         */
        limit?: number;
        /**
         * Optional. The image provider to use.
         */
        providerName?: string;
        /**
         * Optional. Include all languages.
         */
        includeAllLanguages?: boolean;
    };
    url: '/Items/{itemId}/RemoteImages';
};

export type GetRemoteImagesErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type GetRemoteImagesError = GetRemoteImagesErrors[keyof GetRemoteImagesErrors];

export type GetRemoteImagesResponses = {
    /**
     * Remote Images returned.
     */
    200: RemoteImageResult;
};

export type GetRemoteImagesResponse = GetRemoteImagesResponses[keyof GetRemoteImagesResponses];

export type DownloadRemoteImageData = {
    body?: never;
    path: {
        /**
         * Item Id.
         */
        itemId: string;
    };
    query: {
        /**
         * Enum ImageType.
         */
        type: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Profile';
        /**
         * The image url.
         */
        imageUrl?: string;
    };
    url: '/Items/{itemId}/RemoteImages/Download';
};

export type DownloadRemoteImageErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Remote image not found.
     */
    404: ProblemDetails;
};

export type DownloadRemoteImageError = DownloadRemoteImageErrors[keyof DownloadRemoteImageErrors];

export type DownloadRemoteImageResponses = {
    /**
     * Remote image downloaded.
     */
    204: void;
};

export type DownloadRemoteImageResponse = DownloadRemoteImageResponses[keyof DownloadRemoteImageResponses];

export type GetRemoteImageProvidersData = {
    body?: never;
    path: {
        /**
         * Item Id.
         */
        itemId: string;
    };
    query?: never;
    url: '/Items/{itemId}/RemoteImages/Providers';
};

export type GetRemoteImageProvidersErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type GetRemoteImageProvidersError = GetRemoteImageProvidersErrors[keyof GetRemoteImageProvidersErrors];

export type GetRemoteImageProvidersResponses = {
    /**
     * Returned remote image providers.
     */
    200: Array<ImageProviderInfo>;
};

export type GetRemoteImageProvidersResponse = GetRemoteImageProvidersResponses[keyof GetRemoteImageProvidersResponses];

export type GetTasksData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional filter tasks that are hidden, or not.
         */
        isHidden?: boolean;
        /**
         * Optional filter tasks that are enabled, or not.
         */
        isEnabled?: boolean;
    };
    url: '/ScheduledTasks';
};

export type GetTasksErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetTasksResponses = {
    /**
     * Scheduled tasks retrieved.
     */
    200: Array<TaskInfo>;
};

export type GetTasksResponse = GetTasksResponses[keyof GetTasksResponses];

export type GetTaskData = {
    body?: never;
    path: {
        /**
         * Task Id.
         */
        taskId: string;
    };
    query?: never;
    url: '/ScheduledTasks/{taskId}';
};

export type GetTaskErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Task not found.
     */
    404: ProblemDetails;
};

export type GetTaskError = GetTaskErrors[keyof GetTaskErrors];

export type GetTaskResponses = {
    /**
     * Task retrieved.
     */
    200: TaskInfo;
};

export type GetTaskResponse = GetTaskResponses[keyof GetTaskResponses];

export type UpdateTaskData = {
    /**
     * Triggers.
     */
    body: Array<TaskTriggerInfo>;
    path: {
        /**
         * Task Id.
         */
        taskId: string;
    };
    query?: never;
    url: '/ScheduledTasks/{taskId}/Triggers';
};

export type UpdateTaskErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Task not found.
     */
    404: ProblemDetails;
};

export type UpdateTaskError = UpdateTaskErrors[keyof UpdateTaskErrors];

export type UpdateTaskResponses = {
    /**
     * Task triggers updated.
     */
    204: void;
};

export type UpdateTaskResponse = UpdateTaskResponses[keyof UpdateTaskResponses];

export type StopTaskData = {
    body?: never;
    path: {
        /**
         * Task Id.
         */
        taskId: string;
    };
    query?: never;
    url: '/ScheduledTasks/Running/{taskId}';
};

export type StopTaskErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Task not found.
     */
    404: ProblemDetails;
};

export type StopTaskError = StopTaskErrors[keyof StopTaskErrors];

export type StopTaskResponses = {
    /**
     * Task stopped.
     */
    204: void;
};

export type StopTaskResponse = StopTaskResponses[keyof StopTaskResponses];

export type StartTaskData = {
    body?: never;
    path: {
        /**
         * Task Id.
         */
        taskId: string;
    };
    query?: never;
    url: '/ScheduledTasks/Running/{taskId}';
};

export type StartTaskErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Task not found.
     */
    404: ProblemDetails;
};

export type StartTaskError = StartTaskErrors[keyof StartTaskErrors];

export type StartTaskResponses = {
    /**
     * Task started.
     */
    204: void;
};

export type StartTaskResponse = StartTaskResponses[keyof StartTaskResponses];

export type GetSearchHintsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        startIndex?: number;
        /**
         * Optional. The maximum number of records to return.
         */
        limit?: number;
        /**
         * Optional. Supply a user id to search within a user's library or omit to search all.
         */
        userId?: string;
        /**
         * The search term to filter on.
         */
        searchTerm: string;
        /**
         * If specified, only results with the specified item types are returned. This allows multiple, comma delimited.
         */
        includeItemTypes?: Array<BaseItemKind>;
        /**
         * If specified, results with these item types are filtered out. This allows multiple, comma delimited.
         */
        excludeItemTypes?: Array<BaseItemKind>;
        /**
         * If specified, only results with the specified media types are returned. This allows multiple, comma delimited.
         */
        mediaTypes?: Array<MediaType>;
        /**
         * If specified, only children of the parent are returned.
         */
        parentId?: string;
        /**
         * Optional filter for movies.
         */
        isMovie?: boolean;
        /**
         * Optional filter for series.
         */
        isSeries?: boolean;
        /**
         * Optional filter for news.
         */
        isNews?: boolean;
        /**
         * Optional filter for kids.
         */
        isKids?: boolean;
        /**
         * Optional filter for sports.
         */
        isSports?: boolean;
        /**
         * Optional filter whether to include people.
         */
        includePeople?: boolean;
        /**
         * Optional filter whether to include media.
         */
        includeMedia?: boolean;
        /**
         * Optional filter whether to include genres.
         */
        includeGenres?: boolean;
        /**
         * Optional filter whether to include studios.
         */
        includeStudios?: boolean;
        /**
         * Optional filter whether to include artists.
         */
        includeArtists?: boolean;
    };
    url: '/Search/Hints';
};

export type GetSearchHintsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetSearchHintsResponses = {
    /**
     * Search hint returned.
     */
    200: SearchHintResult;
};

export type GetSearchHintsResponse = GetSearchHintsResponses[keyof GetSearchHintsResponses];

export type GetPasswordResetProvidersData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Auth/PasswordResetProviders';
};

export type GetPasswordResetProvidersErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetPasswordResetProvidersResponses = {
    /**
     * Password reset providers retrieved.
     */
    200: Array<NameIdPair>;
};

export type GetPasswordResetProvidersResponse = GetPasswordResetProvidersResponses[keyof GetPasswordResetProvidersResponses];

export type GetAuthProvidersData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Auth/Providers';
};

export type GetAuthProvidersErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetAuthProvidersResponses = {
    /**
     * Auth providers retrieved.
     */
    200: Array<NameIdPair>;
};

export type GetAuthProvidersResponse = GetAuthProvidersResponses[keyof GetAuthProvidersResponses];

export type GetSessionsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Filter by sessions that a given user is allowed to remote control.
         */
        controllableByUserId?: string;
        /**
         * Filter by device Id.
         */
        deviceId?: string;
        /**
         * Optional. Filter by sessions that were active in the last n seconds.
         */
        activeWithinSeconds?: number;
    };
    url: '/Sessions';
};

export type GetSessionsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetSessionsResponses = {
    /**
     * List of sessions returned.
     */
    200: Array<SessionInfoDto>;
};

export type GetSessionsResponse = GetSessionsResponses[keyof GetSessionsResponses];

export type SendFullGeneralCommandData = {
    /**
     * The MediaBrowser.Model.Session.GeneralCommand.
     */
    body: GeneralCommand;
    path: {
        /**
         * The session id.
         */
        sessionId: string;
    };
    query?: never;
    url: '/Sessions/{sessionId}/Command';
};

export type SendFullGeneralCommandErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type SendFullGeneralCommandResponses = {
    /**
     * Full general command sent to session.
     */
    204: void;
};

export type SendFullGeneralCommandResponse = SendFullGeneralCommandResponses[keyof SendFullGeneralCommandResponses];

export type SendGeneralCommandData = {
    body?: never;
    path: {
        /**
         * The session id.
         */
        sessionId: string;
        /**
         * This exists simply to identify a set of known commands.
         */
        command: 'MoveUp' | 'MoveDown' | 'MoveLeft' | 'MoveRight' | 'PageUp' | 'PageDown' | 'PreviousLetter' | 'NextLetter' | 'ToggleOsd' | 'ToggleContextMenu' | 'Select' | 'Back' | 'TakeScreenshot' | 'SendKey' | 'SendString' | 'GoHome' | 'GoToSettings' | 'VolumeUp' | 'VolumeDown' | 'Mute' | 'Unmute' | 'ToggleMute' | 'SetVolume' | 'SetAudioStreamIndex' | 'SetSubtitleStreamIndex' | 'ToggleFullscreen' | 'DisplayContent' | 'GoToSearch' | 'DisplayMessage' | 'SetRepeatMode' | 'ChannelUp' | 'ChannelDown' | 'Guide' | 'ToggleStats' | 'PlayMediaSource' | 'PlayTrailers' | 'SetShuffleQueue' | 'PlayState' | 'PlayNext' | 'ToggleOsdMenu' | 'Play' | 'SetMaxStreamingBitrate' | 'SetPlaybackOrder';
    };
    query?: never;
    url: '/Sessions/{sessionId}/Command/{command}';
};

export type SendGeneralCommandErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type SendGeneralCommandResponses = {
    /**
     * General command sent to session.
     */
    204: void;
};

export type SendGeneralCommandResponse = SendGeneralCommandResponses[keyof SendGeneralCommandResponses];

export type SendMessageCommandData = {
    /**
     * The MediaBrowser.Model.Session.MessageCommand object containing Header, Message Text, and TimeoutMs.
     */
    body: MessageCommand;
    path: {
        /**
         * The session id.
         */
        sessionId: string;
    };
    query?: never;
    url: '/Sessions/{sessionId}/Message';
};

export type SendMessageCommandErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type SendMessageCommandResponses = {
    /**
     * Message sent.
     */
    204: void;
};

export type SendMessageCommandResponse = SendMessageCommandResponses[keyof SendMessageCommandResponses];

export type PlayData = {
    body?: never;
    path: {
        /**
         * The session id.
         */
        sessionId: string;
    };
    query: {
        /**
         * Enum PlayCommand.
         */
        playCommand: 'PlayNow' | 'PlayNext' | 'PlayLast' | 'PlayInstantMix' | 'PlayShuffle';
        /**
         * The ids of the items to play, comma delimited.
         */
        itemIds: Array<string>;
        /**
         * The starting position of the first item.
         */
        startPositionTicks?: number;
        /**
         * Optional. The media source id.
         */
        mediaSourceId?: string;
        /**
         * Optional. The index of the audio stream to play.
         */
        audioStreamIndex?: number;
        /**
         * Optional. The index of the subtitle stream to play.
         */
        subtitleStreamIndex?: number;
        /**
         * Optional. The start index.
         */
        startIndex?: number;
    };
    url: '/Sessions/{sessionId}/Playing';
};

export type PlayErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type PlayResponses = {
    /**
     * Instruction sent to session.
     */
    204: void;
};

export type PlayResponse = PlayResponses[keyof PlayResponses];

export type SendPlaystateCommandData = {
    body?: never;
    path: {
        /**
         * The session id.
         */
        sessionId: string;
        /**
         * Enum PlaystateCommand.
         */
        command: 'Stop' | 'Pause' | 'Unpause' | 'NextTrack' | 'PreviousTrack' | 'Seek' | 'Rewind' | 'FastForward' | 'PlayPause';
    };
    query?: {
        /**
         * The optional position ticks.
         */
        seekPositionTicks?: number;
        /**
         * The optional controlling user id.
         */
        controllingUserId?: string;
    };
    url: '/Sessions/{sessionId}/Playing/{command}';
};

export type SendPlaystateCommandErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type SendPlaystateCommandResponses = {
    /**
     * Playstate command sent to session.
     */
    204: void;
};

export type SendPlaystateCommandResponse = SendPlaystateCommandResponses[keyof SendPlaystateCommandResponses];

export type SendSystemCommandData = {
    body?: never;
    path: {
        /**
         * The session id.
         */
        sessionId: string;
        /**
         * This exists simply to identify a set of known commands.
         */
        command: 'MoveUp' | 'MoveDown' | 'MoveLeft' | 'MoveRight' | 'PageUp' | 'PageDown' | 'PreviousLetter' | 'NextLetter' | 'ToggleOsd' | 'ToggleContextMenu' | 'Select' | 'Back' | 'TakeScreenshot' | 'SendKey' | 'SendString' | 'GoHome' | 'GoToSettings' | 'VolumeUp' | 'VolumeDown' | 'Mute' | 'Unmute' | 'ToggleMute' | 'SetVolume' | 'SetAudioStreamIndex' | 'SetSubtitleStreamIndex' | 'ToggleFullscreen' | 'DisplayContent' | 'GoToSearch' | 'DisplayMessage' | 'SetRepeatMode' | 'ChannelUp' | 'ChannelDown' | 'Guide' | 'ToggleStats' | 'PlayMediaSource' | 'PlayTrailers' | 'SetShuffleQueue' | 'PlayState' | 'PlayNext' | 'ToggleOsdMenu' | 'Play' | 'SetMaxStreamingBitrate' | 'SetPlaybackOrder';
    };
    query?: never;
    url: '/Sessions/{sessionId}/System/{command}';
};

export type SendSystemCommandErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type SendSystemCommandResponses = {
    /**
     * System command sent to session.
     */
    204: void;
};

export type SendSystemCommandResponse = SendSystemCommandResponses[keyof SendSystemCommandResponses];

export type RemoveUserFromSessionData = {
    body?: never;
    path: {
        /**
         * The session id.
         */
        sessionId: string;
        /**
         * The user id.
         */
        userId: string;
    };
    query?: never;
    url: '/Sessions/{sessionId}/User/{userId}';
};

export type RemoveUserFromSessionErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type RemoveUserFromSessionResponses = {
    /**
     * User removed from session.
     */
    204: void;
};

export type RemoveUserFromSessionResponse = RemoveUserFromSessionResponses[keyof RemoveUserFromSessionResponses];

export type AddUserToSessionData = {
    body?: never;
    path: {
        /**
         * The session id.
         */
        sessionId: string;
        /**
         * The user id.
         */
        userId: string;
    };
    query?: never;
    url: '/Sessions/{sessionId}/User/{userId}';
};

export type AddUserToSessionErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type AddUserToSessionResponses = {
    /**
     * User added to session.
     */
    204: void;
};

export type AddUserToSessionResponse = AddUserToSessionResponses[keyof AddUserToSessionResponses];

export type DisplayContentData = {
    body?: never;
    path: {
        /**
         * The session Id.
         */
        sessionId: string;
    };
    query: {
        /**
         * The base item kind.
         */
        itemType: 'AggregateFolder' | 'Audio' | 'AudioBook' | 'BasePluginFolder' | 'Book' | 'BoxSet' | 'Channel' | 'ChannelFolderItem' | 'CollectionFolder' | 'Episode' | 'Folder' | 'Genre' | 'ManualPlaylistsFolder' | 'Movie' | 'LiveTvChannel' | 'LiveTvProgram' | 'MusicAlbum' | 'MusicArtist' | 'MusicGenre' | 'MusicVideo' | 'Person' | 'Photo' | 'PhotoAlbum' | 'Playlist' | 'PlaylistsFolder' | 'Program' | 'Recording' | 'Season' | 'Series' | 'Studio' | 'Trailer' | 'TvChannel' | 'TvProgram' | 'UserRootFolder' | 'UserView' | 'Video' | 'Year';
        /**
         * The Id of the item.
         */
        itemId: string;
        /**
         * The name of the item.
         */
        itemName: string;
    };
    url: '/Sessions/{sessionId}/Viewing';
};

export type DisplayContentErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type DisplayContentResponses = {
    /**
     * Instruction sent to session.
     */
    204: void;
};

export type DisplayContentResponse = DisplayContentResponses[keyof DisplayContentResponses];

export type PostCapabilitiesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The session id.
         */
        id?: string;
        /**
         * A list of playable media types, comma delimited. Audio, Video, Book, Photo.
         */
        playableMediaTypes?: Array<MediaType>;
        /**
         * A list of supported remote control commands, comma delimited.
         */
        supportedCommands?: Array<GeneralCommandType>;
        /**
         * Determines whether media can be played remotely..
         */
        supportsMediaControl?: boolean;
        /**
         * Determines whether the device supports a unique identifier.
         */
        supportsPersistentIdentifier?: boolean;
    };
    url: '/Sessions/Capabilities';
};

export type PostCapabilitiesErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type PostCapabilitiesResponses = {
    /**
     * Capabilities posted.
     */
    204: void;
};

export type PostCapabilitiesResponse = PostCapabilitiesResponses[keyof PostCapabilitiesResponses];

export type PostFullCapabilitiesData = {
    /**
     * Client capabilities dto.
     */
    body: ClientCapabilitiesDto;
    path?: never;
    query?: {
        /**
         * The session id.
         */
        id?: string;
    };
    url: '/Sessions/Capabilities/Full';
};

export type PostFullCapabilitiesErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type PostFullCapabilitiesResponses = {
    /**
     * Capabilities updated.
     */
    204: void;
};

export type PostFullCapabilitiesResponse = PostFullCapabilitiesResponses[keyof PostFullCapabilitiesResponses];

export type ReportSessionEndedData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Sessions/Logout';
};

export type ReportSessionEndedErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type ReportSessionEndedResponses = {
    /**
     * Session end reported to server.
     */
    204: void;
};

export type ReportSessionEndedResponse = ReportSessionEndedResponses[keyof ReportSessionEndedResponses];

export type ReportViewingData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The session id.
         */
        sessionId?: string;
        /**
         * The item id.
         */
        itemId: string;
    };
    url: '/Sessions/Viewing';
};

export type ReportViewingErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type ReportViewingResponses = {
    /**
     * Session reported to server.
     */
    204: void;
};

export type ReportViewingResponse = ReportViewingResponses[keyof ReportViewingResponses];

export type CompleteWizardData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Startup/Complete';
};

export type CompleteWizardErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type CompleteWizardResponses = {
    /**
     * Startup wizard completed.
     */
    204: void;
};

export type CompleteWizardResponse = CompleteWizardResponses[keyof CompleteWizardResponses];

export type GetStartupConfigurationData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Startup/Configuration';
};

export type GetStartupConfigurationErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetStartupConfigurationResponses = {
    /**
     * Initial startup wizard configuration retrieved.
     */
    200: StartupConfigurationDto;
};

export type GetStartupConfigurationResponse = GetStartupConfigurationResponses[keyof GetStartupConfigurationResponses];

export type UpdateInitialConfigurationData = {
    /**
     * The startup configuration DTO.
     */
    body: StartupConfigurationDto;
    path?: never;
    query?: never;
    url: '/Startup/Configuration';
};

export type UpdateInitialConfigurationErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type UpdateInitialConfigurationResponses = {
    /**
     * Configuration saved.
     */
    204: void;
};

export type UpdateInitialConfigurationResponse = UpdateInitialConfigurationResponses[keyof UpdateInitialConfigurationResponses];

export type GetFirstUser2Data = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Startup/FirstUser';
};

export type GetFirstUser2Errors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetFirstUser2Responses = {
    /**
     * Initial user retrieved.
     */
    200: StartupUserDto;
};

export type GetFirstUser2Response = GetFirstUser2Responses[keyof GetFirstUser2Responses];

export type SetRemoteAccessData = {
    /**
     * Startup remote access dto.
     */
    body: StartupRemoteAccessDto;
    path?: never;
    query?: never;
    url: '/Startup/RemoteAccess';
};

export type SetRemoteAccessErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type SetRemoteAccessResponses = {
    /**
     * Configuration saved.
     */
    204: void;
};

export type SetRemoteAccessResponse = SetRemoteAccessResponses[keyof SetRemoteAccessResponses];

export type GetFirstUserData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Startup/User';
};

export type GetFirstUserErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetFirstUserResponses = {
    /**
     * Initial user retrieved.
     */
    200: StartupUserDto;
};

export type GetFirstUserResponse = GetFirstUserResponses[keyof GetFirstUserResponses];

export type UpdateStartupUserData = {
    /**
     * The startup user DTO.
     */
    body?: StartupUserDto;
    path?: never;
    query?: never;
    url: '/Startup/User';
};

export type UpdateStartupUserErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type UpdateStartupUserResponses = {
    /**
     * Updated user name and password.
     */
    204: void;
};

export type UpdateStartupUserResponse = UpdateStartupUserResponses[keyof UpdateStartupUserResponses];

export type GetStudiosData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        startIndex?: number;
        /**
         * Optional. The maximum number of records to return.
         */
        limit?: number;
        /**
         * Optional. Search term.
         */
        searchTerm?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root.
         */
        parentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output.
         */
        fields?: Array<ItemFields>;
        /**
         * Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
         */
        excludeItemTypes?: Array<BaseItemKind>;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
         */
        includeItemTypes?: Array<BaseItemKind>;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        isFavorite?: boolean;
        /**
         * Optional, include user data.
         */
        enableUserData?: boolean;
        /**
         * Optional, the max number of images to return, per image type.
         */
        imageTypeLimit?: number;
        /**
         * Optional. The image types to include in the output.
         */
        enableImageTypes?: Array<ImageType>;
        /**
         * User id.
         */
        userId?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        nameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        nameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        nameLessThan?: string;
        /**
         * Optional, include image information in output.
         */
        enableImages?: boolean;
        /**
         * Total record count.
         */
        enableTotalRecordCount?: boolean;
    };
    url: '/Studios';
};

export type GetStudiosErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetStudiosResponses = {
    /**
     * Studios returned.
     */
    200: BaseItemDtoQueryResult;
};

export type GetStudiosResponse = GetStudiosResponses[keyof GetStudiosResponses];

export type GetStudioData = {
    body?: never;
    path: {
        /**
         * Studio name.
         */
        name: string;
    };
    query?: {
        /**
         * Optional. Filter by user id, and attach user data.
         */
        userId?: string;
    };
    url: '/Studios/{name}';
};

export type GetStudioErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetStudioResponses = {
    /**
     * Studio returned.
     */
    200: BaseItemDto;
};

export type GetStudioResponse = GetStudioResponses[keyof GetStudioResponses];

export type GetFallbackFontListData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/FallbackFont/Fonts';
};

export type GetFallbackFontListErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetFallbackFontListResponses = {
    /**
     * Information retrieved.
     */
    200: Array<FontFile>;
};

export type GetFallbackFontListResponse = GetFallbackFontListResponses[keyof GetFallbackFontListResponses];

export type GetFallbackFontData = {
    body?: never;
    path: {
        /**
         * The name of the fallback font file to get.
         */
        name: string;
    };
    query?: never;
    url: '/FallbackFont/Fonts/{name}';
};

export type GetFallbackFontErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetFallbackFontResponses = {
    /**
     * Fallback font file retrieved.
     */
    200: Blob | File;
};

export type GetFallbackFontResponse = GetFallbackFontResponses[keyof GetFallbackFontResponses];

export type SearchRemoteSubtitlesData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
        /**
         * The language of the subtitles.
         */
        language: string;
    };
    query?: {
        /**
         * Optional. Only show subtitles which are a perfect match.
         */
        isPerfectMatch?: boolean;
    };
    url: '/Items/{itemId}/RemoteSearch/Subtitles/{language}';
};

export type SearchRemoteSubtitlesErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type SearchRemoteSubtitlesError = SearchRemoteSubtitlesErrors[keyof SearchRemoteSubtitlesErrors];

export type SearchRemoteSubtitlesResponses = {
    /**
     * Subtitles retrieved.
     */
    200: Array<RemoteSubtitleInfo>;
};

export type SearchRemoteSubtitlesResponse = SearchRemoteSubtitlesResponses[keyof SearchRemoteSubtitlesResponses];

export type DownloadRemoteSubtitlesData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
        /**
         * The subtitle id.
         */
        subtitleId: string;
    };
    query?: never;
    url: '/Items/{itemId}/RemoteSearch/Subtitles/{subtitleId}';
};

export type DownloadRemoteSubtitlesErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type DownloadRemoteSubtitlesError = DownloadRemoteSubtitlesErrors[keyof DownloadRemoteSubtitlesErrors];

export type DownloadRemoteSubtitlesResponses = {
    /**
     * Subtitle downloaded.
     */
    204: void;
};

export type DownloadRemoteSubtitlesResponse = DownloadRemoteSubtitlesResponses[keyof DownloadRemoteSubtitlesResponses];

export type GetRemoteSubtitlesData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        subtitleId: string;
    };
    query?: never;
    url: '/Providers/Subtitles/Subtitles/{subtitleId}';
};

export type GetRemoteSubtitlesErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetRemoteSubtitlesResponses = {
    /**
     * File returned.
     */
    200: Blob | File;
};

export type GetRemoteSubtitlesResponse = GetRemoteSubtitlesResponses[keyof GetRemoteSubtitlesResponses];

export type GetSubtitlePlaylistData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
        /**
         * The subtitle stream index.
         */
        index: number;
        /**
         * The media source id.
         */
        mediaSourceId: string;
    };
    query: {
        /**
         * The subtitle segment length.
         */
        segmentLength: number;
    };
    url: '/Videos/{itemId}/{mediaSourceId}/Subtitles/{index}/subtitles.m3u8';
};

export type GetSubtitlePlaylistErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type GetSubtitlePlaylistError = GetSubtitlePlaylistErrors[keyof GetSubtitlePlaylistErrors];

export type GetSubtitlePlaylistResponses = {
    /**
     * Subtitle playlist retrieved.
     */
    200: Blob | File;
};

export type GetSubtitlePlaylistResponse = GetSubtitlePlaylistResponses[keyof GetSubtitlePlaylistResponses];

export type UploadSubtitleData = {
    /**
     * Upload subtitles dto.
     */
    body: UploadSubtitleDto;
    path: {
        /**
         * The item the subtitle belongs to.
         */
        itemId: string;
    };
    query?: never;
    url: '/Videos/{itemId}/Subtitles';
};

export type UploadSubtitleErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type UploadSubtitleError = UploadSubtitleErrors[keyof UploadSubtitleErrors];

export type UploadSubtitleResponses = {
    /**
     * Subtitle uploaded.
     */
    204: void;
};

export type UploadSubtitleResponse = UploadSubtitleResponses[keyof UploadSubtitleResponses];

export type DeleteSubtitleData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
        /**
         * The index of the subtitle file.
         */
        index: number;
    };
    query?: never;
    url: '/Videos/{itemId}/Subtitles/{index}';
};

export type DeleteSubtitleErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type DeleteSubtitleError = DeleteSubtitleErrors[keyof DeleteSubtitleErrors];

export type DeleteSubtitleResponses = {
    /**
     * Subtitle deleted.
     */
    204: void;
};

export type DeleteSubtitleResponse = DeleteSubtitleResponses[keyof DeleteSubtitleResponses];

export type GetSubtitleWithTicksData = {
    body?: never;
    path: {
        /**
         * The (route) item id.
         */
        routeItemId: string;
        /**
         * The (route) media source id.
         */
        routeMediaSourceId: string;
        /**
         * The (route) subtitle stream index.
         */
        routeIndex: number;
        /**
         * The (route) start position of the subtitle in ticks.
         */
        routeStartPositionTicks: number;
        /**
         * The (route) format of the returned subtitle.
         */
        routeFormat: string;
    };
    query?: {
        /**
         * The item id.
         * @deprecated
         */
        itemId?: string;
        /**
         * The media source id.
         * @deprecated
         */
        mediaSourceId?: string;
        /**
         * The subtitle stream index.
         * @deprecated
         */
        index?: number;
        /**
         * The start position of the subtitle in ticks.
         * @deprecated
         */
        startPositionTicks?: number;
        /**
         * The format of the returned subtitle.
         * @deprecated
         */
        format?: string;
        /**
         * Optional. The end position of the subtitle in ticks.
         */
        endPositionTicks?: number;
        /**
         * Optional. Whether to copy the timestamps.
         */
        copyTimestamps?: boolean;
        /**
         * Optional. Whether to add a VTT time map.
         */
        addVttTimeMap?: boolean;
    };
    url: '/Videos/{routeItemId}/{routeMediaSourceId}/Subtitles/{routeIndex}/{routeStartPositionTicks}/Stream.{routeFormat}';
};

export type GetSubtitleWithTicksResponses = {
    /**
     * File returned.
     */
    200: Blob | File;
};

export type GetSubtitleWithTicksResponse = GetSubtitleWithTicksResponses[keyof GetSubtitleWithTicksResponses];

export type GetSubtitleData = {
    body?: never;
    path: {
        /**
         * The (route) item id.
         */
        routeItemId: string;
        /**
         * The (route) media source id.
         */
        routeMediaSourceId: string;
        /**
         * The (route) subtitle stream index.
         */
        routeIndex: number;
        /**
         * The (route) format of the returned subtitle.
         */
        routeFormat: string;
    };
    query?: {
        /**
         * The item id.
         * @deprecated
         */
        itemId?: string;
        /**
         * The media source id.
         * @deprecated
         */
        mediaSourceId?: string;
        /**
         * The subtitle stream index.
         * @deprecated
         */
        index?: number;
        /**
         * The format of the returned subtitle.
         * @deprecated
         */
        format?: string;
        /**
         * Optional. The end position of the subtitle in ticks.
         */
        endPositionTicks?: number;
        /**
         * Optional. Whether to copy the timestamps.
         */
        copyTimestamps?: boolean;
        /**
         * Optional. Whether to add a VTT time map.
         */
        addVttTimeMap?: boolean;
        /**
         * The start position of the subtitle in ticks.
         */
        startPositionTicks?: number;
    };
    url: '/Videos/{routeItemId}/{routeMediaSourceId}/Subtitles/{routeIndex}/Stream.{routeFormat}';
};

export type GetSubtitleResponses = {
    /**
     * File returned.
     */
    200: Blob | File;
};

export type GetSubtitleResponse = GetSubtitleResponses[keyof GetSubtitleResponses];

export type GetSuggestionsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The user id.
         */
        userId?: string;
        /**
         * The media types.
         */
        mediaType?: Array<MediaType>;
        /**
         * The type.
         */
        type?: Array<BaseItemKind>;
        /**
         * Optional. The start index.
         */
        startIndex?: number;
        /**
         * Optional. The limit.
         */
        limit?: number;
        /**
         * Whether to enable the total record count.
         */
        enableTotalRecordCount?: boolean;
    };
    url: '/Items/Suggestions';
};

export type GetSuggestionsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetSuggestionsResponses = {
    /**
     * Suggestions returned.
     */
    200: BaseItemDtoQueryResult;
};

export type GetSuggestionsResponse = GetSuggestionsResponses[keyof GetSuggestionsResponses];

export type SyncPlayBufferingData = {
    /**
     * Class BufferRequestDto.
     */
    body: BufferRequestDto;
    path?: never;
    query?: never;
    url: '/SyncPlay/Buffering';
};

export type SyncPlayBufferingErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type SyncPlayBufferingResponses = {
    /**
     * Group state update sent to all group members.
     */
    204: void;
};

export type SyncPlayBufferingResponse = SyncPlayBufferingResponses[keyof SyncPlayBufferingResponses];

export type SyncPlayJoinGroupData = {
    /**
     * Class JoinGroupRequestDto.
     */
    body: JoinGroupRequestDto;
    path?: never;
    query?: never;
    url: '/SyncPlay/Join';
};

export type SyncPlayJoinGroupErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type SyncPlayJoinGroupResponses = {
    /**
     * Group join successful.
     */
    204: void;
};

export type SyncPlayJoinGroupResponse = SyncPlayJoinGroupResponses[keyof SyncPlayJoinGroupResponses];

export type SyncPlayLeaveGroupData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/SyncPlay/Leave';
};

export type SyncPlayLeaveGroupErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type SyncPlayLeaveGroupResponses = {
    /**
     * Group leave successful.
     */
    204: void;
};

export type SyncPlayLeaveGroupResponse = SyncPlayLeaveGroupResponses[keyof SyncPlayLeaveGroupResponses];

export type SyncPlayGetGroupsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/SyncPlay/List';
};

export type SyncPlayGetGroupsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type SyncPlayGetGroupsResponses = {
    /**
     * Groups returned.
     */
    200: Array<GroupInfoDto>;
};

export type SyncPlayGetGroupsResponse = SyncPlayGetGroupsResponses[keyof SyncPlayGetGroupsResponses];

export type SyncPlayMovePlaylistItemData = {
    /**
     * Class MovePlaylistItemRequestDto.
     */
    body: MovePlaylistItemRequestDto;
    path?: never;
    query?: never;
    url: '/SyncPlay/MovePlaylistItem';
};

export type SyncPlayMovePlaylistItemErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type SyncPlayMovePlaylistItemResponses = {
    /**
     * Queue update sent to all group members.
     */
    204: void;
};

export type SyncPlayMovePlaylistItemResponse = SyncPlayMovePlaylistItemResponses[keyof SyncPlayMovePlaylistItemResponses];

export type SyncPlayCreateGroupData = {
    /**
     * Class NewGroupRequestDto.
     */
    body: NewGroupRequestDto;
    path?: never;
    query?: never;
    url: '/SyncPlay/New';
};

export type SyncPlayCreateGroupErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type SyncPlayCreateGroupResponses = {
    /**
     * New group created.
     */
    204: void;
};

export type SyncPlayCreateGroupResponse = SyncPlayCreateGroupResponses[keyof SyncPlayCreateGroupResponses];

export type SyncPlayNextItemData = {
    /**
     * Class NextItemRequestDto.
     */
    body: NextItemRequestDto;
    path?: never;
    query?: never;
    url: '/SyncPlay/NextItem';
};

export type SyncPlayNextItemErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type SyncPlayNextItemResponses = {
    /**
     * Next item update sent to all group members.
     */
    204: void;
};

export type SyncPlayNextItemResponse = SyncPlayNextItemResponses[keyof SyncPlayNextItemResponses];

export type SyncPlayPauseData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/SyncPlay/Pause';
};

export type SyncPlayPauseErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type SyncPlayPauseResponses = {
    /**
     * Pause update sent to all group members.
     */
    204: void;
};

export type SyncPlayPauseResponse = SyncPlayPauseResponses[keyof SyncPlayPauseResponses];

export type SyncPlayPingData = {
    /**
     * Class PingRequestDto.
     */
    body: PingRequestDto;
    path?: never;
    query?: never;
    url: '/SyncPlay/Ping';
};

export type SyncPlayPingErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type SyncPlayPingResponses = {
    /**
     * Ping updated.
     */
    204: void;
};

export type SyncPlayPingResponse = SyncPlayPingResponses[keyof SyncPlayPingResponses];

export type SyncPlayPreviousItemData = {
    /**
     * Class PreviousItemRequestDto.
     */
    body: PreviousItemRequestDto;
    path?: never;
    query?: never;
    url: '/SyncPlay/PreviousItem';
};

export type SyncPlayPreviousItemErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type SyncPlayPreviousItemResponses = {
    /**
     * Previous item update sent to all group members.
     */
    204: void;
};

export type SyncPlayPreviousItemResponse = SyncPlayPreviousItemResponses[keyof SyncPlayPreviousItemResponses];

export type SyncPlayQueueData = {
    /**
     * Class QueueRequestDto.
     */
    body: QueueRequestDto;
    path?: never;
    query?: never;
    url: '/SyncPlay/Queue';
};

export type SyncPlayQueueErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type SyncPlayQueueResponses = {
    /**
     * Queue update sent to all group members.
     */
    204: void;
};

export type SyncPlayQueueResponse = SyncPlayQueueResponses[keyof SyncPlayQueueResponses];

export type SyncPlayReadyData = {
    /**
     * Class ReadyRequest.
     */
    body: ReadyRequestDto;
    path?: never;
    query?: never;
    url: '/SyncPlay/Ready';
};

export type SyncPlayReadyErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type SyncPlayReadyResponses = {
    /**
     * Group state update sent to all group members.
     */
    204: void;
};

export type SyncPlayReadyResponse = SyncPlayReadyResponses[keyof SyncPlayReadyResponses];

export type SyncPlayRemoveFromPlaylistData = {
    /**
     * Class RemoveFromPlaylistRequestDto.
     */
    body: RemoveFromPlaylistRequestDto;
    path?: never;
    query?: never;
    url: '/SyncPlay/RemoveFromPlaylist';
};

export type SyncPlayRemoveFromPlaylistErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type SyncPlayRemoveFromPlaylistResponses = {
    /**
     * Queue update sent to all group members.
     */
    204: void;
};

export type SyncPlayRemoveFromPlaylistResponse = SyncPlayRemoveFromPlaylistResponses[keyof SyncPlayRemoveFromPlaylistResponses];

export type SyncPlaySeekData = {
    /**
     * Class SeekRequestDto.
     */
    body: SeekRequestDto;
    path?: never;
    query?: never;
    url: '/SyncPlay/Seek';
};

export type SyncPlaySeekErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type SyncPlaySeekResponses = {
    /**
     * Seek update sent to all group members.
     */
    204: void;
};

export type SyncPlaySeekResponse = SyncPlaySeekResponses[keyof SyncPlaySeekResponses];

export type SyncPlaySetIgnoreWaitData = {
    /**
     * Class IgnoreWaitRequestDto.
     */
    body: IgnoreWaitRequestDto;
    path?: never;
    query?: never;
    url: '/SyncPlay/SetIgnoreWait';
};

export type SyncPlaySetIgnoreWaitErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type SyncPlaySetIgnoreWaitResponses = {
    /**
     * Member state updated.
     */
    204: void;
};

export type SyncPlaySetIgnoreWaitResponse = SyncPlaySetIgnoreWaitResponses[keyof SyncPlaySetIgnoreWaitResponses];

export type SyncPlaySetNewQueueData = {
    /**
     * Class PlayRequestDto.
     */
    body: PlayRequestDto;
    path?: never;
    query?: never;
    url: '/SyncPlay/SetNewQueue';
};

export type SyncPlaySetNewQueueErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type SyncPlaySetNewQueueResponses = {
    /**
     * Queue update sent to all group members.
     */
    204: void;
};

export type SyncPlaySetNewQueueResponse = SyncPlaySetNewQueueResponses[keyof SyncPlaySetNewQueueResponses];

export type SyncPlaySetPlaylistItemData = {
    /**
     * Class SetPlaylistItemRequestDto.
     */
    body: SetPlaylistItemRequestDto;
    path?: never;
    query?: never;
    url: '/SyncPlay/SetPlaylistItem';
};

export type SyncPlaySetPlaylistItemErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type SyncPlaySetPlaylistItemResponses = {
    /**
     * Queue update sent to all group members.
     */
    204: void;
};

export type SyncPlaySetPlaylistItemResponse = SyncPlaySetPlaylistItemResponses[keyof SyncPlaySetPlaylistItemResponses];

export type SyncPlaySetRepeatModeData = {
    /**
     * Class SetRepeatModeRequestDto.
     */
    body: SetRepeatModeRequestDto;
    path?: never;
    query?: never;
    url: '/SyncPlay/SetRepeatMode';
};

export type SyncPlaySetRepeatModeErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type SyncPlaySetRepeatModeResponses = {
    /**
     * Play queue update sent to all group members.
     */
    204: void;
};

export type SyncPlaySetRepeatModeResponse = SyncPlaySetRepeatModeResponses[keyof SyncPlaySetRepeatModeResponses];

export type SyncPlaySetShuffleModeData = {
    /**
     * Class SetShuffleModeRequestDto.
     */
    body: SetShuffleModeRequestDto;
    path?: never;
    query?: never;
    url: '/SyncPlay/SetShuffleMode';
};

export type SyncPlaySetShuffleModeErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type SyncPlaySetShuffleModeResponses = {
    /**
     * Play queue update sent to all group members.
     */
    204: void;
};

export type SyncPlaySetShuffleModeResponse = SyncPlaySetShuffleModeResponses[keyof SyncPlaySetShuffleModeResponses];

export type SyncPlayStopData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/SyncPlay/Stop';
};

export type SyncPlayStopErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type SyncPlayStopResponses = {
    /**
     * Stop update sent to all group members.
     */
    204: void;
};

export type SyncPlayStopResponse = SyncPlayStopResponses[keyof SyncPlayStopResponses];

export type SyncPlayUnpauseData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/SyncPlay/Unpause';
};

export type SyncPlayUnpauseErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type SyncPlayUnpauseResponses = {
    /**
     * Unpause update sent to all group members.
     */
    204: void;
};

export type SyncPlayUnpauseResponse = SyncPlayUnpauseResponses[keyof SyncPlayUnpauseResponses];

export type GetEndpointInfoData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/System/Endpoint';
};

export type GetEndpointInfoErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * User does not have permission to get endpoint information.
     */
    403: ProblemDetails;
};

export type GetEndpointInfoError = GetEndpointInfoErrors[keyof GetEndpointInfoErrors];

export type GetEndpointInfoResponses = {
    /**
     * Information retrieved.
     */
    200: EndPointInfo;
};

export type GetEndpointInfoResponse = GetEndpointInfoResponses[keyof GetEndpointInfoResponses];

export type GetSystemInfoData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/System/Info';
};

export type GetSystemInfoErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * User does not have permission to retrieve information.
     */
    403: ProblemDetails;
};

export type GetSystemInfoError = GetSystemInfoErrors[keyof GetSystemInfoErrors];

export type GetSystemInfoResponses = {
    /**
     * Information retrieved.
     */
    200: SystemInfo;
};

export type GetSystemInfoResponse = GetSystemInfoResponses[keyof GetSystemInfoResponses];

export type GetPublicSystemInfoData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/System/Info/Public';
};

export type GetPublicSystemInfoResponses = {
    /**
     * Information retrieved.
     */
    200: PublicSystemInfo;
};

export type GetPublicSystemInfoResponse = GetPublicSystemInfoResponses[keyof GetPublicSystemInfoResponses];

export type GetServerLogsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/System/Logs';
};

export type GetServerLogsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * User does not have permission to get server logs.
     */
    403: ProblemDetails;
};

export type GetServerLogsError = GetServerLogsErrors[keyof GetServerLogsErrors];

export type GetServerLogsResponses = {
    /**
     * Information retrieved.
     */
    200: Array<LogFile>;
};

export type GetServerLogsResponse = GetServerLogsResponses[keyof GetServerLogsResponses];

export type GetLogFileData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The name of the log file to get.
         */
        name: string;
    };
    url: '/System/Logs/Log';
};

export type GetLogFileErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * User does not have permission to get log files.
     */
    403: ProblemDetails;
    /**
     * Could not find a log file with the name.
     */
    404: ProblemDetails;
};

export type GetLogFileError = GetLogFileErrors[keyof GetLogFileErrors];

export type GetLogFileResponses = {
    /**
     * Log file retrieved.
     */
    200: Blob | File;
};

export type GetLogFileResponse = GetLogFileResponses[keyof GetLogFileResponses];

export type GetPingSystemData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/System/Ping';
};

export type GetPingSystemResponses = {
    /**
     * Information retrieved.
     */
    200: string;
};

export type GetPingSystemResponse = GetPingSystemResponses[keyof GetPingSystemResponses];

export type PostPingSystemData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/System/Ping';
};

export type PostPingSystemResponses = {
    /**
     * Information retrieved.
     */
    200: string;
};

export type PostPingSystemResponse = PostPingSystemResponses[keyof PostPingSystemResponses];

export type RestartApplicationData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/System/Restart';
};

export type RestartApplicationErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * User does not have permission to restart server.
     */
    403: ProblemDetails;
};

export type RestartApplicationError = RestartApplicationErrors[keyof RestartApplicationErrors];

export type RestartApplicationResponses = {
    /**
     * Server restarted.
     */
    204: void;
};

export type RestartApplicationResponse = RestartApplicationResponses[keyof RestartApplicationResponses];

export type ShutdownApplicationData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/System/Shutdown';
};

export type ShutdownApplicationErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * User does not have permission to shutdown server.
     */
    403: ProblemDetails;
};

export type ShutdownApplicationError = ShutdownApplicationErrors[keyof ShutdownApplicationErrors];

export type ShutdownApplicationResponses = {
    /**
     * Server shut down.
     */
    204: void;
};

export type ShutdownApplicationResponse = ShutdownApplicationResponses[keyof ShutdownApplicationResponses];

export type GetWakeOnLanInfoData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/System/WakeOnLanInfo';
};

export type GetWakeOnLanInfoErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetWakeOnLanInfoResponses = {
    /**
     * Information retrieved.
     */
    200: Array<WakeOnLanInfo>;
};

export type GetWakeOnLanInfoResponse = GetWakeOnLanInfoResponses[keyof GetWakeOnLanInfoResponses];

export type GetUtcTimeData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/GetUtcTime';
};

export type GetUtcTimeResponses = {
    /**
     * Time returned.
     */
    200: UtcTimeResponse;
};

export type GetUtcTimeResponse = GetUtcTimeResponses[keyof GetUtcTimeResponses];

export type TmdbClientConfigurationData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Tmdb/ClientConfiguration';
};

export type TmdbClientConfigurationErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type TmdbClientConfigurationResponses = {
    /**
     * Success
     */
    200: ConfigImageTypes;
};

export type TmdbClientConfigurationResponse = TmdbClientConfigurationResponses[keyof TmdbClientConfigurationResponses];

export type GetTrailersData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The user id supplied as query parameter; this is required when not using an API key.
         */
        userId?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        maxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        hasThemeSong?: boolean;
        /**
         * Optional filter by items with theme videos.
         */
        hasThemeVideo?: boolean;
        /**
         * Optional filter by items with subtitles.
         */
        hasSubtitles?: boolean;
        /**
         * Optional filter by items with special features.
         */
        hasSpecialFeature?: boolean;
        /**
         * Optional filter by items with trailers.
         */
        hasTrailer?: boolean;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        adjacentTo?: string;
        /**
         * Optional filter by parent index number.
         */
        parentIndexNumber?: number;
        /**
         * Optional filter by items that have or do not have a parental rating.
         */
        hasParentalRating?: boolean;
        /**
         * Optional filter by items that are HD or not.
         */
        isHd?: boolean;
        /**
         * Optional filter by items that are 4K or not.
         */
        is4K?: boolean;
        /**
         * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimited.
         */
        locationTypes?: Array<LocationType>;
        /**
         * Optional. If specified, results will be filtered based on the LocationType. This allows multiple, comma delimited.
         */
        excludeLocationTypes?: Array<LocationType>;
        /**
         * Optional filter by items that are missing episodes or not.
         */
        isMissing?: boolean;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        isUnaired?: boolean;
        /**
         * Optional filter by minimum community rating.
         */
        minCommunityRating?: number;
        /**
         * Optional filter by minimum critic rating.
         */
        minCriticRating?: number;
        /**
         * Optional. The minimum premiere date. Format = ISO.
         */
        minPremiereDate?: string;
        /**
         * Optional. The minimum last saved date. Format = ISO.
         */
        minDateLastSaved?: string;
        /**
         * Optional. The minimum last saved date for the current user. Format = ISO.
         */
        minDateLastSavedForUser?: string;
        /**
         * Optional. The maximum premiere date. Format = ISO.
         */
        maxPremiereDate?: string;
        /**
         * Optional filter by items that have an overview or not.
         */
        hasOverview?: boolean;
        /**
         * Optional filter by items that have an IMDb id or not.
         */
        hasImdbId?: boolean;
        /**
         * Optional filter by items that have a TMDb id or not.
         */
        hasTmdbId?: boolean;
        /**
         * Optional filter by items that have a TVDb id or not.
         */
        hasTvdbId?: boolean;
        /**
         * Optional filter for live tv movies.
         */
        isMovie?: boolean;
        /**
         * Optional filter for live tv series.
         */
        isSeries?: boolean;
        /**
         * Optional filter for live tv news.
         */
        isNews?: boolean;
        /**
         * Optional filter for live tv kids.
         */
        isKids?: boolean;
        /**
         * Optional filter for live tv sports.
         */
        isSports?: boolean;
        /**
         * Optional. If specified, results will be filtered by excluding item ids. This allows multiple, comma delimited.
         */
        excludeItemIds?: Array<string>;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        startIndex?: number;
        /**
         * Optional. The maximum number of records to return.
         */
        limit?: number;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false.
         */
        recursive?: boolean;
        /**
         * Optional. Filter based on a search term.
         */
        searchTerm?: string;
        /**
         * Sort Order - Ascending, Descending.
         */
        sortOrder?: Array<SortOrder>;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root.
         */
        parentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         */
        fields?: Array<ItemFields>;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
         */
        excludeItemTypes?: Array<BaseItemKind>;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
         */
        filters?: Array<ItemFilter>;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        isFavorite?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        mediaTypes?: Array<MediaType>;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        imageTypes?: Array<ImageType>;
        /**
         * Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         */
        sortBy?: Array<ItemSortBy>;
        /**
         * Optional filter by items that are played, or not.
         */
        isPlayed?: boolean;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
         */
        genres?: Array<string>;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
         */
        officialRatings?: Array<string>;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
         */
        tags?: Array<string>;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
         */
        years?: Array<number>;
        /**
         * Optional, include user data.
         */
        enableUserData?: boolean;
        /**
         * Optional, the max number of images to return, per image type.
         */
        imageTypeLimit?: number;
        /**
         * Optional. The image types to include in the output.
         */
        enableImageTypes?: Array<ImageType>;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person id.
         */
        personIds?: Array<string>;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
         */
        personTypes?: Array<string>;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
         */
        studios?: Array<string>;
        /**
         * Optional. If specified, results will be filtered based on artists. This allows multiple, pipe delimited.
         */
        artists?: Array<string>;
        /**
         * Optional. If specified, results will be filtered based on artist id. This allows multiple, pipe delimited.
         */
        excludeArtistIds?: Array<string>;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified artist id.
         */
        artistIds?: Array<string>;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified album artist id.
         */
        albumArtistIds?: Array<string>;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified contributing artist id.
         */
        contributingArtistIds?: Array<string>;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimited.
         */
        albums?: Array<string>;
        /**
         * Optional. If specified, results will be filtered based on album id. This allows multiple, pipe delimited.
         */
        albumIds?: Array<string>;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        ids?: Array<string>;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimited.
         */
        videoTypes?: Array<VideoType>;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        minOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        isLocked?: boolean;
        /**
         * Optional filter by items that are placeholders.
         */
        isPlaceHolder?: boolean;
        /**
         * Optional filter by items that have official ratings.
         */
        hasOfficialRating?: boolean;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        collapseBoxSetItems?: boolean;
        /**
         * Optional. Filter by the minimum width of the item.
         */
        minWidth?: number;
        /**
         * Optional. Filter by the minimum height of the item.
         */
        minHeight?: number;
        /**
         * Optional. Filter by the maximum width of the item.
         */
        maxWidth?: number;
        /**
         * Optional. Filter by the maximum height of the item.
         */
        maxHeight?: number;
        /**
         * Optional filter by items that are 3D, or not.
         */
        is3D?: boolean;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimited.
         */
        seriesStatus?: Array<SeriesStatus>;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        nameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        nameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        nameLessThan?: string;
        /**
         * Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
         */
        studioIds?: Array<string>;
        /**
         * Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
         */
        genreIds?: Array<string>;
        /**
         * Optional. Enable the total record count.
         */
        enableTotalRecordCount?: boolean;
        /**
         * Optional, include image information in output.
         */
        enableImages?: boolean;
    };
    url: '/Trailers';
};

export type GetTrailersErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetTrailersResponses = {
    /**
     * Success
     */
    200: BaseItemDtoQueryResult;
};

export type GetTrailersResponse = GetTrailersResponses[keyof GetTrailersResponses];

export type GetTrickplayTileImageData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
        /**
         * The width of a single tile.
         */
        width: number;
        /**
         * The index of the desired tile.
         */
        index: number;
    };
    query?: {
        /**
         * The media version id, if using an alternate version.
         */
        mediaSourceId?: string;
    };
    url: '/Videos/{itemId}/Trickplay/{width}/{index}.jpg';
};

export type GetTrickplayTileImageErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Not Found
     */
    404: ProblemDetails;
};

export type GetTrickplayTileImageError = GetTrickplayTileImageErrors[keyof GetTrickplayTileImageErrors];

export type GetTrickplayTileImageResponses = {
    /**
     * Tile image not found at specified index.
     */
    200: Blob | File;
};

export type GetTrickplayTileImageResponse = GetTrickplayTileImageResponses[keyof GetTrickplayTileImageResponses];

export type GetTrickplayHlsPlaylistData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
        /**
         * The width of a single tile.
         */
        width: number;
    };
    query?: {
        /**
         * The media version id, if using an alternate version.
         */
        mediaSourceId?: string;
    };
    url: '/Videos/{itemId}/Trickplay/{width}/tiles.m3u8';
};

export type GetTrickplayHlsPlaylistErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Not Found
     */
    404: ProblemDetails;
};

export type GetTrickplayHlsPlaylistError = GetTrickplayHlsPlaylistErrors[keyof GetTrickplayHlsPlaylistErrors];

export type GetTrickplayHlsPlaylistResponses = {
    /**
     * Tiles playlist returned.
     */
    200: Blob | File;
};

export type GetTrickplayHlsPlaylistResponse = GetTrickplayHlsPlaylistResponses[keyof GetTrickplayHlsPlaylistResponses];

export type GetEpisodesData = {
    body?: never;
    path: {
        /**
         * The series id.
         */
        seriesId: string;
    };
    query?: {
        /**
         * The user id.
         */
        userId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         */
        fields?: Array<ItemFields>;
        /**
         * Optional filter by season number.
         */
        season?: number;
        /**
         * Optional. Filter by season id.
         */
        seasonId?: string;
        /**
         * Optional. Filter by items that are missing episodes or not.
         */
        isMissing?: boolean;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        adjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        startItemId?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        startIndex?: number;
        /**
         * Optional. The maximum number of records to return.
         */
        limit?: number;
        /**
         * Optional, include image information in output.
         */
        enableImages?: boolean;
        /**
         * Optional, the max number of images to return, per image type.
         */
        imageTypeLimit?: number;
        /**
         * Optional. The image types to include in the output.
         */
        enableImageTypes?: Array<ImageType>;
        /**
         * Optional. Include user data.
         */
        enableUserData?: boolean;
        /**
         * Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         */
        sortBy?: 'Default' | 'AiredEpisodeOrder' | 'Album' | 'AlbumArtist' | 'Artist' | 'DateCreated' | 'OfficialRating' | 'DatePlayed' | 'PremiereDate' | 'StartDate' | 'SortName' | 'Name' | 'Random' | 'Runtime' | 'CommunityRating' | 'ProductionYear' | 'PlayCount' | 'CriticRating' | 'IsFolder' | 'IsUnplayed' | 'IsPlayed' | 'SeriesSortName' | 'VideoBitRate' | 'AirTime' | 'Studio' | 'IsFavoriteOrLiked' | 'DateLastContentAdded' | 'SeriesDatePlayed' | 'ParentIndexNumber' | 'IndexNumber' | 'SimilarityScore' | 'SearchScore';
    };
    url: '/Shows/{seriesId}/Episodes';
};

export type GetEpisodesErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Not Found
     */
    404: ProblemDetails;
};

export type GetEpisodesError = GetEpisodesErrors[keyof GetEpisodesErrors];

export type GetEpisodesResponses = {
    /**
     * Success
     */
    200: BaseItemDtoQueryResult;
};

export type GetEpisodesResponse = GetEpisodesResponses[keyof GetEpisodesResponses];

export type GetSeasonsData = {
    body?: never;
    path: {
        /**
         * The series id.
         */
        seriesId: string;
    };
    query?: {
        /**
         * The user id.
         */
        userId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         */
        fields?: Array<ItemFields>;
        /**
         * Optional. Filter by special season.
         */
        isSpecialSeason?: boolean;
        /**
         * Optional. Filter by items that are missing episodes or not.
         */
        isMissing?: boolean;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        adjacentTo?: string;
        /**
         * Optional. Include image information in output.
         */
        enableImages?: boolean;
        /**
         * Optional. The max number of images to return, per image type.
         */
        imageTypeLimit?: number;
        /**
         * Optional. The image types to include in the output.
         */
        enableImageTypes?: Array<ImageType>;
        /**
         * Optional. Include user data.
         */
        enableUserData?: boolean;
    };
    url: '/Shows/{seriesId}/Seasons';
};

export type GetSeasonsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Not Found
     */
    404: ProblemDetails;
};

export type GetSeasonsError = GetSeasonsErrors[keyof GetSeasonsErrors];

export type GetSeasonsResponses = {
    /**
     * Success
     */
    200: BaseItemDtoQueryResult;
};

export type GetSeasonsResponse = GetSeasonsResponses[keyof GetSeasonsResponses];

export type GetNextUpData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The user id of the user to get the next up episodes for.
         */
        userId?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        startIndex?: number;
        /**
         * Optional. The maximum number of records to return.
         */
        limit?: number;
        /**
         * Optional. Specify additional fields of information to return in the output.
         */
        fields?: Array<ItemFields>;
        /**
         * Optional. Filter by series id.
         */
        seriesId?: string;
        /**
         * Optional. Specify this to localize the search to a specific item or folder. Omit to use the root.
         */
        parentId?: string;
        /**
         * Optional. Include image information in output.
         */
        enableImages?: boolean;
        /**
         * Optional. The max number of images to return, per image type.
         */
        imageTypeLimit?: number;
        /**
         * Optional. The image types to include in the output.
         */
        enableImageTypes?: Array<ImageType>;
        /**
         * Optional. Include user data.
         */
        enableUserData?: boolean;
        /**
         * Optional. Starting date of shows to show in Next Up section.
         */
        nextUpDateCutoff?: string;
        /**
         * Whether to enable the total records count. Defaults to true.
         */
        enableTotalRecordCount?: boolean;
        /**
         * Whether to disable sending the first episode in a series as next up.
         */
        disableFirstEpisode?: boolean;
        /**
         * Whether to include resumable episodes in next up results.
         */
        enableResumable?: boolean;
        /**
         * Whether to include watched episodes in next up results.
         */
        enableRewatching?: boolean;
    };
    url: '/Shows/NextUp';
};

export type GetNextUpErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetNextUpResponses = {
    /**
     * Success
     */
    200: BaseItemDtoQueryResult;
};

export type GetNextUpResponse = GetNextUpResponses[keyof GetNextUpResponses];

export type GetUpcomingEpisodesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The user id of the user to get the upcoming episodes for.
         */
        userId?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        startIndex?: number;
        /**
         * Optional. The maximum number of records to return.
         */
        limit?: number;
        /**
         * Optional. Specify additional fields of information to return in the output.
         */
        fields?: Array<ItemFields>;
        /**
         * Optional. Specify this to localize the search to a specific item or folder. Omit to use the root.
         */
        parentId?: string;
        /**
         * Optional. Include image information in output.
         */
        enableImages?: boolean;
        /**
         * Optional. The max number of images to return, per image type.
         */
        imageTypeLimit?: number;
        /**
         * Optional. The image types to include in the output.
         */
        enableImageTypes?: Array<ImageType>;
        /**
         * Optional. Include user data.
         */
        enableUserData?: boolean;
    };
    url: '/Shows/Upcoming';
};

export type GetUpcomingEpisodesErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetUpcomingEpisodesResponses = {
    /**
     * Success
     */
    200: BaseItemDtoQueryResult;
};

export type GetUpcomingEpisodesResponse = GetUpcomingEpisodesResponses[keyof GetUpcomingEpisodesResponses];

export type GetUniversalAudioStreamData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
    };
    query?: {
        /**
         * Optional. The audio container.
         */
        container?: Array<string>;
        /**
         * The media version id, if playing an alternate version.
         */
        mediaSourceId?: string;
        /**
         * The device id of the client requesting. Used to stop encoding processes when needed.
         */
        deviceId?: string;
        /**
         * Optional. The user id.
         */
        userId?: string;
        /**
         * Optional. The audio codec to transcode to.
         */
        audioCodec?: string;
        /**
         * Optional. The maximum number of audio channels.
         */
        maxAudioChannels?: number;
        /**
         * Optional. The number of how many audio channels to transcode to.
         */
        transcodingAudioChannels?: number;
        /**
         * Optional. The maximum streaming bitrate.
         */
        maxStreamingBitrate?: number;
        /**
         * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         */
        audioBitRate?: number;
        /**
         * Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
         */
        startTimeTicks?: number;
        /**
         * Optional. The container to transcode to.
         */
        transcodingContainer?: string;
        /**
         * Optional. The transcoding protocol.
         */
        transcodingProtocol?: 'http' | 'hls';
        /**
         * Optional. The maximum audio sample rate.
         */
        maxAudioSampleRate?: number;
        /**
         * Optional. The maximum audio bit depth.
         */
        maxAudioBitDepth?: number;
        /**
         * Optional. Whether to enable remote media.
         */
        enableRemoteMedia?: boolean;
        /**
         * Optional. Whether to enable Audio Encoding.
         */
        enableAudioVbrEncoding?: boolean;
        /**
         * Optional. Whether to break on non key frames.
         */
        breakOnNonKeyFrames?: boolean;
        /**
         * Whether to enable redirection. Defaults to true.
         */
        enableRedirection?: boolean;
    };
    url: '/Audio/{itemId}/universal';
};

export type GetUniversalAudioStreamErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type GetUniversalAudioStreamError = GetUniversalAudioStreamErrors[keyof GetUniversalAudioStreamErrors];

export type GetUniversalAudioStreamResponses = {
    /**
     * Audio stream returned.
     */
    200: Blob | File;
};

export type GetUniversalAudioStreamResponse = GetUniversalAudioStreamResponses[keyof GetUniversalAudioStreamResponses];

export type HeadUniversalAudioStreamData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
    };
    query?: {
        /**
         * Optional. The audio container.
         */
        container?: Array<string>;
        /**
         * The media version id, if playing an alternate version.
         */
        mediaSourceId?: string;
        /**
         * The device id of the client requesting. Used to stop encoding processes when needed.
         */
        deviceId?: string;
        /**
         * Optional. The user id.
         */
        userId?: string;
        /**
         * Optional. The audio codec to transcode to.
         */
        audioCodec?: string;
        /**
         * Optional. The maximum number of audio channels.
         */
        maxAudioChannels?: number;
        /**
         * Optional. The number of how many audio channels to transcode to.
         */
        transcodingAudioChannels?: number;
        /**
         * Optional. The maximum streaming bitrate.
         */
        maxStreamingBitrate?: number;
        /**
         * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         */
        audioBitRate?: number;
        /**
         * Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
         */
        startTimeTicks?: number;
        /**
         * Optional. The container to transcode to.
         */
        transcodingContainer?: string;
        /**
         * Optional. The transcoding protocol.
         */
        transcodingProtocol?: 'http' | 'hls';
        /**
         * Optional. The maximum audio sample rate.
         */
        maxAudioSampleRate?: number;
        /**
         * Optional. The maximum audio bit depth.
         */
        maxAudioBitDepth?: number;
        /**
         * Optional. Whether to enable remote media.
         */
        enableRemoteMedia?: boolean;
        /**
         * Optional. Whether to enable Audio Encoding.
         */
        enableAudioVbrEncoding?: boolean;
        /**
         * Optional. Whether to break on non key frames.
         */
        breakOnNonKeyFrames?: boolean;
        /**
         * Whether to enable redirection. Defaults to true.
         */
        enableRedirection?: boolean;
    };
    url: '/Audio/{itemId}/universal';
};

export type HeadUniversalAudioStreamErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Item not found.
     */
    404: ProblemDetails;
};

export type HeadUniversalAudioStreamError = HeadUniversalAudioStreamErrors[keyof HeadUniversalAudioStreamErrors];

export type HeadUniversalAudioStreamResponses = {
    /**
     * Audio stream returned.
     */
    200: Blob | File;
};

export type HeadUniversalAudioStreamResponse = HeadUniversalAudioStreamResponses[keyof HeadUniversalAudioStreamResponses];

export type GetUsersData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional filter by IsHidden=true or false.
         */
        isHidden?: boolean;
        /**
         * Optional filter by IsDisabled=true or false.
         */
        isDisabled?: boolean;
    };
    url: '/Users';
};

export type GetUsersErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetUsersResponses = {
    /**
     * Users returned.
     */
    200: Array<UserDto>;
};

export type GetUsersResponse = GetUsersResponses[keyof GetUsersResponses];

export type UpdateUserData = {
    /**
     * Class UserDto.
     */
    body: UserDto;
    path?: never;
    query?: {
        /**
         * The user id.
         */
        userId?: string;
    };
    url: '/Users';
};

export type UpdateUserErrors = {
    /**
     * User information was not supplied.
     */
    400: ProblemDetails;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * User update forbidden.
     */
    403: ProblemDetails;
};

export type UpdateUserError = UpdateUserErrors[keyof UpdateUserErrors];

export type UpdateUserResponses = {
    /**
     * User updated.
     */
    204: void;
};

export type UpdateUserResponse = UpdateUserResponses[keyof UpdateUserResponses];

export type DeleteUserData = {
    body?: never;
    path: {
        /**
         * The user id.
         */
        userId: string;
    };
    query?: never;
    url: '/Users/{userId}';
};

export type DeleteUserErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * User not found.
     */
    404: ProblemDetails;
};

export type DeleteUserError = DeleteUserErrors[keyof DeleteUserErrors];

export type DeleteUserResponses = {
    /**
     * User deleted.
     */
    204: void;
};

export type DeleteUserResponse = DeleteUserResponses[keyof DeleteUserResponses];

export type GetUserByIdData = {
    body?: never;
    path: {
        /**
         * The user id.
         */
        userId: string;
    };
    query?: never;
    url: '/Users/{userId}';
};

export type GetUserByIdErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * User not found.
     */
    404: ProblemDetails;
};

export type GetUserByIdError = GetUserByIdErrors[keyof GetUserByIdErrors];

export type GetUserByIdResponses = {
    /**
     * User returned.
     */
    200: UserDto;
};

export type GetUserByIdResponse = GetUserByIdResponses[keyof GetUserByIdResponses];

export type UpdateUserPolicyData = {
    /**
     * The new user policy.
     */
    body: UserPolicy;
    path: {
        /**
         * The user id.
         */
        userId: string;
    };
    query?: never;
    url: '/Users/{userId}/Policy';
};

export type UpdateUserPolicyErrors = {
    /**
     * User policy was not supplied.
     */
    400: ProblemDetails;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * User policy update forbidden.
     */
    403: ProblemDetails;
};

export type UpdateUserPolicyError = UpdateUserPolicyErrors[keyof UpdateUserPolicyErrors];

export type UpdateUserPolicyResponses = {
    /**
     * User policy updated.
     */
    204: void;
};

export type UpdateUserPolicyResponse = UpdateUserPolicyResponses[keyof UpdateUserPolicyResponses];

export type AuthenticateUserByNameData = {
    /**
     * The authenticate user by name request body.
     */
    body: AuthenticateUserByName;
    path?: never;
    query?: never;
    url: '/Users/AuthenticateByName';
};

export type AuthenticateUserByNameResponses = {
    /**
     * User authenticated.
     */
    200: AuthenticationResult;
};

export type AuthenticateUserByNameResponse = AuthenticateUserByNameResponses[keyof AuthenticateUserByNameResponses];

export type AuthenticateWithQuickConnectData = {
    /**
     * The quick connect request body.
     */
    body: QuickConnectDto;
    path?: never;
    query?: never;
    url: '/Users/AuthenticateWithQuickConnect';
};

export type AuthenticateWithQuickConnectErrors = {
    /**
     * Missing token.
     */
    400: unknown;
};

export type AuthenticateWithQuickConnectResponses = {
    /**
     * User authenticated.
     */
    200: AuthenticationResult;
};

export type AuthenticateWithQuickConnectResponse = AuthenticateWithQuickConnectResponses[keyof AuthenticateWithQuickConnectResponses];

export type UpdateUserConfigurationData = {
    /**
     * Class UserConfiguration.
     */
    body: UserConfiguration;
    path?: never;
    query?: {
        /**
         * The user id.
         */
        userId?: string;
    };
    url: '/Users/Configuration';
};

export type UpdateUserConfigurationErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * User configuration update forbidden.
     */
    403: ProblemDetails;
};

export type UpdateUserConfigurationError = UpdateUserConfigurationErrors[keyof UpdateUserConfigurationErrors];

export type UpdateUserConfigurationResponses = {
    /**
     * User configuration updated.
     */
    204: void;
};

export type UpdateUserConfigurationResponse = UpdateUserConfigurationResponses[keyof UpdateUserConfigurationResponses];

export type ForgotPasswordData = {
    /**
     * Forgot Password request body DTO.
     */
    body: ForgotPasswordDto;
    path?: never;
    query?: never;
    url: '/Users/ForgotPassword';
};

export type ForgotPasswordResponses = {
    /**
     * Password reset process started.
     */
    200: ForgotPasswordResult;
};

export type ForgotPasswordResponse = ForgotPasswordResponses[keyof ForgotPasswordResponses];

export type ForgotPasswordPinData = {
    /**
     * Forgot Password Pin enter request body DTO.
     */
    body: ForgotPasswordPinDto;
    path?: never;
    query?: never;
    url: '/Users/ForgotPassword/Pin';
};

export type ForgotPasswordPinResponses = {
    /**
     * Pin reset process started.
     */
    200: PinRedeemResult;
};

export type ForgotPasswordPinResponse = ForgotPasswordPinResponses[keyof ForgotPasswordPinResponses];

export type GetCurrentUserData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Users/Me';
};

export type GetCurrentUserErrors = {
    /**
     * Token is not owned by a user.
     */
    400: ProblemDetails;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetCurrentUserError = GetCurrentUserErrors[keyof GetCurrentUserErrors];

export type GetCurrentUserResponses = {
    /**
     * User returned.
     */
    200: UserDto;
};

export type GetCurrentUserResponse = GetCurrentUserResponses[keyof GetCurrentUserResponses];

export type CreateUserByNameData = {
    /**
     * The create user by name request body.
     */
    body: CreateUserByName;
    path?: never;
    query?: never;
    url: '/Users/New';
};

export type CreateUserByNameErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type CreateUserByNameResponses = {
    /**
     * User created.
     */
    200: UserDto;
};

export type CreateUserByNameResponse = CreateUserByNameResponses[keyof CreateUserByNameResponses];

export type UpdateUserPasswordData = {
    /**
     * The update user password request body.
     */
    body: UpdateUserPassword;
    path?: never;
    query?: {
        /**
         * The user id.
         */
        userId?: string;
    };
    url: '/Users/Password';
};

export type UpdateUserPasswordErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * User is not allowed to update the password.
     */
    403: ProblemDetails;
    /**
     * User not found.
     */
    404: ProblemDetails;
};

export type UpdateUserPasswordError = UpdateUserPasswordErrors[keyof UpdateUserPasswordErrors];

export type UpdateUserPasswordResponses = {
    /**
     * Password successfully reset.
     */
    204: void;
};

export type UpdateUserPasswordResponse = UpdateUserPasswordResponses[keyof UpdateUserPasswordResponses];

export type GetPublicUsersData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Users/Public';
};

export type GetPublicUsersResponses = {
    /**
     * Public users returned.
     */
    200: Array<UserDto>;
};

export type GetPublicUsersResponse = GetPublicUsersResponses[keyof GetPublicUsersResponses];

export type GetIntrosData = {
    body?: never;
    path: {
        /**
         * Item id.
         */
        itemId: string;
    };
    query?: {
        /**
         * User id.
         */
        userId?: string;
    };
    url: '/Items/{itemId}/Intros';
};

export type GetIntrosErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetIntrosResponses = {
    /**
     * Intros returned.
     */
    200: BaseItemDtoQueryResult;
};

export type GetIntrosResponse = GetIntrosResponses[keyof GetIntrosResponses];

export type GetLocalTrailersData = {
    body?: never;
    path: {
        /**
         * Item id.
         */
        itemId: string;
    };
    query?: {
        /**
         * User id.
         */
        userId?: string;
    };
    url: '/Items/{itemId}/LocalTrailers';
};

export type GetLocalTrailersErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetLocalTrailersResponses = {
    /**
     * An Microsoft.AspNetCore.Mvc.OkResult containing the item's local trailers.
     */
    200: Array<BaseItemDto>;
};

export type GetLocalTrailersResponse = GetLocalTrailersResponses[keyof GetLocalTrailersResponses];

export type GetSpecialFeaturesData = {
    body?: never;
    path: {
        /**
         * Item id.
         */
        itemId: string;
    };
    query?: {
        /**
         * User id.
         */
        userId?: string;
    };
    url: '/Items/{itemId}/SpecialFeatures';
};

export type GetSpecialFeaturesErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetSpecialFeaturesResponses = {
    /**
     * Special features returned.
     */
    200: Array<BaseItemDto>;
};

export type GetSpecialFeaturesResponse = GetSpecialFeaturesResponses[keyof GetSpecialFeaturesResponses];

export type GetLatestMediaData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * User id.
         */
        userId?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root.
         */
        parentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output.
         */
        fields?: Array<ItemFields>;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
         */
        includeItemTypes?: Array<BaseItemKind>;
        /**
         * Filter by items that are played, or not.
         */
        isPlayed?: boolean;
        /**
         * Optional. include image information in output.
         */
        enableImages?: boolean;
        /**
         * Optional. the max number of images to return, per image type.
         */
        imageTypeLimit?: number;
        /**
         * Optional. The image types to include in the output.
         */
        enableImageTypes?: Array<ImageType>;
        /**
         * Optional. include user data.
         */
        enableUserData?: boolean;
        /**
         * Return item limit.
         */
        limit?: number;
        /**
         * Whether or not to group items into a parent container.
         */
        groupItems?: boolean;
    };
    url: '/Items/Latest';
};

export type GetLatestMediaErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetLatestMediaResponses = {
    /**
     * Latest media returned.
     */
    200: Array<BaseItemDto>;
};

export type GetLatestMediaResponse = GetLatestMediaResponses[keyof GetLatestMediaResponses];

export type GetRootFolderData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * User id.
         */
        userId?: string;
    };
    url: '/Items/Root';
};

export type GetRootFolderErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetRootFolderResponses = {
    /**
     * Root folder returned.
     */
    200: BaseItemDto;
};

export type GetRootFolderResponse = GetRootFolderResponses[keyof GetRootFolderResponses];

export type UnmarkFavoriteItemData = {
    body?: never;
    path: {
        /**
         * Item id.
         */
        itemId: string;
    };
    query?: {
        /**
         * User id.
         */
        userId?: string;
    };
    url: '/UserFavoriteItems/{itemId}';
};

export type UnmarkFavoriteItemErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type UnmarkFavoriteItemResponses = {
    /**
     * Item unmarked as favorite.
     */
    200: UserItemDataDto;
};

export type UnmarkFavoriteItemResponse = UnmarkFavoriteItemResponses[keyof UnmarkFavoriteItemResponses];

export type MarkFavoriteItemData = {
    body?: never;
    path: {
        /**
         * Item id.
         */
        itemId: string;
    };
    query?: {
        /**
         * User id.
         */
        userId?: string;
    };
    url: '/UserFavoriteItems/{itemId}';
};

export type MarkFavoriteItemErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type MarkFavoriteItemResponses = {
    /**
     * Item marked as favorite.
     */
    200: UserItemDataDto;
};

export type MarkFavoriteItemResponse = MarkFavoriteItemResponses[keyof MarkFavoriteItemResponses];

export type DeleteUserItemRatingData = {
    body?: never;
    path: {
        /**
         * Item id.
         */
        itemId: string;
    };
    query?: {
        /**
         * User id.
         */
        userId?: string;
    };
    url: '/UserItems/{itemId}/Rating';
};

export type DeleteUserItemRatingErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type DeleteUserItemRatingResponses = {
    /**
     * Personal rating removed.
     */
    200: UserItemDataDto;
};

export type DeleteUserItemRatingResponse = DeleteUserItemRatingResponses[keyof DeleteUserItemRatingResponses];

export type UpdateUserItemRatingData = {
    body?: never;
    path: {
        /**
         * Item id.
         */
        itemId: string;
    };
    query?: {
        /**
         * User id.
         */
        userId?: string;
        /**
         * Whether this M:Jellyfin.Api.Controllers.UserLibraryController.UpdateUserItemRating(System.Nullable{System.Guid},System.Guid,System.Nullable{System.Boolean}) is likes.
         */
        likes?: boolean;
    };
    url: '/UserItems/{itemId}/Rating';
};

export type UpdateUserItemRatingErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type UpdateUserItemRatingResponses = {
    /**
     * Item rating updated.
     */
    200: UserItemDataDto;
};

export type UpdateUserItemRatingResponse = UpdateUserItemRatingResponses[keyof UpdateUserItemRatingResponses];

export type GetUserViewsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * User id.
         */
        userId?: string;
        /**
         * Whether or not to include external views such as channels or live tv.
         */
        includeExternalContent?: boolean;
        /**
         * Preset views.
         */
        presetViews?: Array<CollectionType>;
        /**
         * Whether or not to include hidden content.
         */
        includeHidden?: boolean;
    };
    url: '/UserViews';
};

export type GetUserViewsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetUserViewsResponses = {
    /**
     * User views returned.
     */
    200: BaseItemDtoQueryResult;
};

export type GetUserViewsResponse = GetUserViewsResponses[keyof GetUserViewsResponses];

export type GetGroupingOptionsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * User id.
         */
        userId?: string;
    };
    url: '/UserViews/GroupingOptions';
};

export type GetGroupingOptionsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * User not found.
     */
    404: ProblemDetails;
};

export type GetGroupingOptionsError = GetGroupingOptionsErrors[keyof GetGroupingOptionsErrors];

export type GetGroupingOptionsResponses = {
    /**
     * User view grouping options returned.
     */
    200: Array<SpecialViewOptionDto>;
};

export type GetGroupingOptionsResponse = GetGroupingOptionsResponses[keyof GetGroupingOptionsResponses];

export type GetAttachmentData = {
    body?: never;
    path: {
        /**
         * Video ID.
         */
        videoId: string;
        /**
         * Media Source ID.
         */
        mediaSourceId: string;
        /**
         * Attachment Index.
         */
        index: number;
    };
    query?: never;
    url: '/Videos/{videoId}/{mediaSourceId}/Attachments/{index}';
};

export type GetAttachmentErrors = {
    /**
     * Video or attachment not found.
     */
    404: ProblemDetails;
};

export type GetAttachmentError = GetAttachmentErrors[keyof GetAttachmentErrors];

export type GetAttachmentResponses = {
    /**
     * Attachment retrieved.
     */
    200: Blob | File;
};

export type GetAttachmentResponse = GetAttachmentResponses[keyof GetAttachmentResponses];

export type GetAdditionalPartData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
    };
    query?: {
        /**
         * Optional. Filter by user id, and attach user data.
         */
        userId?: string;
    };
    url: '/Videos/{itemId}/AdditionalParts';
};

export type GetAdditionalPartErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetAdditionalPartResponses = {
    /**
     * Additional parts returned.
     */
    200: BaseItemDtoQueryResult;
};

export type GetAdditionalPartResponse = GetAdditionalPartResponses[keyof GetAdditionalPartResponses];

export type DeleteAlternateSourcesData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
    };
    query?: never;
    url: '/Videos/{itemId}/AlternateSources';
};

export type DeleteAlternateSourcesErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Video not found.
     */
    404: ProblemDetails;
};

export type DeleteAlternateSourcesError = DeleteAlternateSourcesErrors[keyof DeleteAlternateSourcesErrors];

export type DeleteAlternateSourcesResponses = {
    /**
     * Alternate sources deleted.
     */
    204: void;
};

export type DeleteAlternateSourcesResponse = DeleteAlternateSourcesResponses[keyof DeleteAlternateSourcesResponses];

export type GetVideoStreamData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
    };
    query?: {
        /**
         * The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
         */
        container?: string;
        /**
         * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         */
        static?: boolean;
        /**
         * The streaming parameters.
         */
        params?: string;
        /**
         * The tag.
         */
        tag?: string;
        /**
         * Optional. The dlna device profile id to utilize.
         * @deprecated
         */
        deviceProfileId?: string;
        /**
         * The play session id.
         */
        playSessionId?: string;
        /**
         * The segment container.
         */
        segmentContainer?: string;
        /**
         * The segment length.
         */
        segmentLength?: number;
        /**
         * The minimum number of segments.
         */
        minSegments?: number;
        /**
         * The media version id, if playing an alternate version.
         */
        mediaSourceId?: string;
        /**
         * The device id of the client requesting. Used to stop encoding processes when needed.
         */
        deviceId?: string;
        /**
         * Optional. Specify an audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension.
         */
        audioCodec?: string;
        /**
         * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         */
        enableAutoStreamCopy?: boolean;
        /**
         * Whether or not to allow copying of the video stream url.
         */
        allowVideoStreamCopy?: boolean;
        /**
         * Whether or not to allow copying of the audio stream url.
         */
        allowAudioStreamCopy?: boolean;
        /**
         * Optional. Whether to break on non key frames.
         */
        breakOnNonKeyFrames?: boolean;
        /**
         * Optional. Specify a specific audio sample rate, e.g. 44100.
         */
        audioSampleRate?: number;
        /**
         * Optional. The maximum audio bit depth.
         */
        maxAudioBitDepth?: number;
        /**
         * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         */
        audioBitRate?: number;
        /**
         * Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         */
        audioChannels?: number;
        /**
         * Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         */
        maxAudioChannels?: number;
        /**
         * Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         */
        profile?: string;
        /**
         * Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         */
        level?: string;
        /**
         * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         */
        framerate?: number;
        /**
         * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         */
        maxFramerate?: number;
        /**
         * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         */
        copyTimestamps?: boolean;
        /**
         * Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
         */
        startTimeTicks?: number;
        /**
         * Optional. The fixed horizontal resolution of the encoded video.
         */
        width?: number;
        /**
         * Optional. The fixed vertical resolution of the encoded video.
         */
        height?: number;
        /**
         * Optional. The maximum horizontal resolution of the encoded video.
         */
        maxWidth?: number;
        /**
         * Optional. The maximum vertical resolution of the encoded video.
         */
        maxHeight?: number;
        /**
         * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         */
        videoBitRate?: number;
        /**
         * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         */
        subtitleStreamIndex?: number;
        /**
         * Optional. Specify the subtitle delivery method.
         */
        subtitleMethod?: 'Encode' | 'Embed' | 'External' | 'Hls' | 'Drop';
        /**
         * Optional.
         */
        maxRefFrames?: number;
        /**
         * Optional. The maximum video bit depth.
         */
        maxVideoBitDepth?: number;
        /**
         * Optional. Whether to require avc.
         */
        requireAvc?: boolean;
        /**
         * Optional. Whether to deinterlace the video.
         */
        deInterlace?: boolean;
        /**
         * Optional. Whether to require a non anamorphic stream.
         */
        requireNonAnamorphic?: boolean;
        /**
         * Optional. The maximum number of audio channels to transcode.
         */
        transcodingMaxAudioChannels?: number;
        /**
         * Optional. The limit of how many cpu cores to use.
         */
        cpuCoreLimit?: number;
        /**
         * The live stream id.
         */
        liveStreamId?: string;
        /**
         * Optional. Whether to enable the MpegtsM2Ts mode.
         */
        enableMpegtsM2TsMode?: boolean;
        /**
         * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension.
         */
        videoCodec?: string;
        /**
         * Optional. Specify a subtitle codec to encode to.
         */
        subtitleCodec?: string;
        /**
         * Optional. The transcoding reason.
         */
        transcodeReasons?: string;
        /**
         * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         */
        audioStreamIndex?: number;
        /**
         * Optional. The index of the video stream to use. If omitted the first video stream will be used.
         */
        videoStreamIndex?: number;
        /**
         * Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         */
        context?: 'Streaming' | 'Static';
        /**
         * Optional. The streaming options.
         */
        streamOptions?: {
            [key: string]: string | null;
        };
        /**
         * Optional. Whether to enable Audio Encoding.
         */
        enableAudioVbrEncoding?: boolean;
    };
    url: '/Videos/{itemId}/stream';
};

export type GetVideoStreamResponses = {
    /**
     * Video stream returned.
     */
    200: Blob | File;
};

export type GetVideoStreamResponse = GetVideoStreamResponses[keyof GetVideoStreamResponses];

export type HeadVideoStreamData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
    };
    query?: {
        /**
         * The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
         */
        container?: string;
        /**
         * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         */
        static?: boolean;
        /**
         * The streaming parameters.
         */
        params?: string;
        /**
         * The tag.
         */
        tag?: string;
        /**
         * Optional. The dlna device profile id to utilize.
         * @deprecated
         */
        deviceProfileId?: string;
        /**
         * The play session id.
         */
        playSessionId?: string;
        /**
         * The segment container.
         */
        segmentContainer?: string;
        /**
         * The segment length.
         */
        segmentLength?: number;
        /**
         * The minimum number of segments.
         */
        minSegments?: number;
        /**
         * The media version id, if playing an alternate version.
         */
        mediaSourceId?: string;
        /**
         * The device id of the client requesting. Used to stop encoding processes when needed.
         */
        deviceId?: string;
        /**
         * Optional. Specify an audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension.
         */
        audioCodec?: string;
        /**
         * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         */
        enableAutoStreamCopy?: boolean;
        /**
         * Whether or not to allow copying of the video stream url.
         */
        allowVideoStreamCopy?: boolean;
        /**
         * Whether or not to allow copying of the audio stream url.
         */
        allowAudioStreamCopy?: boolean;
        /**
         * Optional. Whether to break on non key frames.
         */
        breakOnNonKeyFrames?: boolean;
        /**
         * Optional. Specify a specific audio sample rate, e.g. 44100.
         */
        audioSampleRate?: number;
        /**
         * Optional. The maximum audio bit depth.
         */
        maxAudioBitDepth?: number;
        /**
         * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         */
        audioBitRate?: number;
        /**
         * Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         */
        audioChannels?: number;
        /**
         * Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         */
        maxAudioChannels?: number;
        /**
         * Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         */
        profile?: string;
        /**
         * Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         */
        level?: string;
        /**
         * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         */
        framerate?: number;
        /**
         * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         */
        maxFramerate?: number;
        /**
         * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         */
        copyTimestamps?: boolean;
        /**
         * Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
         */
        startTimeTicks?: number;
        /**
         * Optional. The fixed horizontal resolution of the encoded video.
         */
        width?: number;
        /**
         * Optional. The fixed vertical resolution of the encoded video.
         */
        height?: number;
        /**
         * Optional. The maximum horizontal resolution of the encoded video.
         */
        maxWidth?: number;
        /**
         * Optional. The maximum vertical resolution of the encoded video.
         */
        maxHeight?: number;
        /**
         * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         */
        videoBitRate?: number;
        /**
         * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         */
        subtitleStreamIndex?: number;
        /**
         * Optional. Specify the subtitle delivery method.
         */
        subtitleMethod?: 'Encode' | 'Embed' | 'External' | 'Hls' | 'Drop';
        /**
         * Optional.
         */
        maxRefFrames?: number;
        /**
         * Optional. The maximum video bit depth.
         */
        maxVideoBitDepth?: number;
        /**
         * Optional. Whether to require avc.
         */
        requireAvc?: boolean;
        /**
         * Optional. Whether to deinterlace the video.
         */
        deInterlace?: boolean;
        /**
         * Optional. Whether to require a non anamorphic stream.
         */
        requireNonAnamorphic?: boolean;
        /**
         * Optional. The maximum number of audio channels to transcode.
         */
        transcodingMaxAudioChannels?: number;
        /**
         * Optional. The limit of how many cpu cores to use.
         */
        cpuCoreLimit?: number;
        /**
         * The live stream id.
         */
        liveStreamId?: string;
        /**
         * Optional. Whether to enable the MpegtsM2Ts mode.
         */
        enableMpegtsM2TsMode?: boolean;
        /**
         * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension.
         */
        videoCodec?: string;
        /**
         * Optional. Specify a subtitle codec to encode to.
         */
        subtitleCodec?: string;
        /**
         * Optional. The transcoding reason.
         */
        transcodeReasons?: string;
        /**
         * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         */
        audioStreamIndex?: number;
        /**
         * Optional. The index of the video stream to use. If omitted the first video stream will be used.
         */
        videoStreamIndex?: number;
        /**
         * Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         */
        context?: 'Streaming' | 'Static';
        /**
         * Optional. The streaming options.
         */
        streamOptions?: {
            [key: string]: string | null;
        };
        /**
         * Optional. Whether to enable Audio Encoding.
         */
        enableAudioVbrEncoding?: boolean;
    };
    url: '/Videos/{itemId}/stream';
};

export type HeadVideoStreamResponses = {
    /**
     * Video stream returned.
     */
    200: Blob | File;
};

export type HeadVideoStreamResponse = HeadVideoStreamResponses[keyof HeadVideoStreamResponses];

export type GetVideoStreamByContainerData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
        /**
         * The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
         */
        container: string;
    };
    query?: {
        /**
         * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         */
        static?: boolean;
        /**
         * The streaming parameters.
         */
        params?: string;
        /**
         * The tag.
         */
        tag?: string;
        /**
         * Optional. The dlna device profile id to utilize.
         */
        deviceProfileId?: string;
        /**
         * The play session id.
         */
        playSessionId?: string;
        /**
         * The segment container.
         */
        segmentContainer?: string;
        /**
         * The segment length.
         */
        segmentLength?: number;
        /**
         * The minimum number of segments.
         */
        minSegments?: number;
        /**
         * The media version id, if playing an alternate version.
         */
        mediaSourceId?: string;
        /**
         * The device id of the client requesting. Used to stop encoding processes when needed.
         */
        deviceId?: string;
        /**
         * Optional. Specify an audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension.
         */
        audioCodec?: string;
        /**
         * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         */
        enableAutoStreamCopy?: boolean;
        /**
         * Whether or not to allow copying of the video stream url.
         */
        allowVideoStreamCopy?: boolean;
        /**
         * Whether or not to allow copying of the audio stream url.
         */
        allowAudioStreamCopy?: boolean;
        /**
         * Optional. Whether to break on non key frames.
         */
        breakOnNonKeyFrames?: boolean;
        /**
         * Optional. Specify a specific audio sample rate, e.g. 44100.
         */
        audioSampleRate?: number;
        /**
         * Optional. The maximum audio bit depth.
         */
        maxAudioBitDepth?: number;
        /**
         * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         */
        audioBitRate?: number;
        /**
         * Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         */
        audioChannels?: number;
        /**
         * Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         */
        maxAudioChannels?: number;
        /**
         * Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         */
        profile?: string;
        /**
         * Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         */
        level?: string;
        /**
         * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         */
        framerate?: number;
        /**
         * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         */
        maxFramerate?: number;
        /**
         * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         */
        copyTimestamps?: boolean;
        /**
         * Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
         */
        startTimeTicks?: number;
        /**
         * Optional. The fixed horizontal resolution of the encoded video.
         */
        width?: number;
        /**
         * Optional. The fixed vertical resolution of the encoded video.
         */
        height?: number;
        /**
         * Optional. The maximum horizontal resolution of the encoded video.
         */
        maxWidth?: number;
        /**
         * Optional. The maximum vertical resolution of the encoded video.
         */
        maxHeight?: number;
        /**
         * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         */
        videoBitRate?: number;
        /**
         * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         */
        subtitleStreamIndex?: number;
        /**
         * Optional. Specify the subtitle delivery method.
         */
        subtitleMethod?: 'Encode' | 'Embed' | 'External' | 'Hls' | 'Drop';
        /**
         * Optional.
         */
        maxRefFrames?: number;
        /**
         * Optional. The maximum video bit depth.
         */
        maxVideoBitDepth?: number;
        /**
         * Optional. Whether to require avc.
         */
        requireAvc?: boolean;
        /**
         * Optional. Whether to deinterlace the video.
         */
        deInterlace?: boolean;
        /**
         * Optional. Whether to require a non anamorphic stream.
         */
        requireNonAnamorphic?: boolean;
        /**
         * Optional. The maximum number of audio channels to transcode.
         */
        transcodingMaxAudioChannels?: number;
        /**
         * Optional. The limit of how many cpu cores to use.
         */
        cpuCoreLimit?: number;
        /**
         * The live stream id.
         */
        liveStreamId?: string;
        /**
         * Optional. Whether to enable the MpegtsM2Ts mode.
         */
        enableMpegtsM2TsMode?: boolean;
        /**
         * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension.
         */
        videoCodec?: string;
        /**
         * Optional. Specify a subtitle codec to encode to.
         */
        subtitleCodec?: string;
        /**
         * Optional. The transcoding reason.
         */
        transcodeReasons?: string;
        /**
         * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         */
        audioStreamIndex?: number;
        /**
         * Optional. The index of the video stream to use. If omitted the first video stream will be used.
         */
        videoStreamIndex?: number;
        /**
         * Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         */
        context?: 'Streaming' | 'Static';
        /**
         * Optional. The streaming options.
         */
        streamOptions?: {
            [key: string]: string | null;
        };
        /**
         * Optional. Whether to enable Audio Encoding.
         */
        enableAudioVbrEncoding?: boolean;
    };
    url: '/Videos/{itemId}/stream.{container}';
};

export type GetVideoStreamByContainerResponses = {
    /**
     * Video stream returned.
     */
    200: Blob | File;
};

export type GetVideoStreamByContainerResponse = GetVideoStreamByContainerResponses[keyof GetVideoStreamByContainerResponses];

export type HeadVideoStreamByContainerData = {
    body?: never;
    path: {
        /**
         * The item id.
         */
        itemId: string;
        /**
         * The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
         */
        container: string;
    };
    query?: {
        /**
         * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         */
        static?: boolean;
        /**
         * The streaming parameters.
         */
        params?: string;
        /**
         * The tag.
         */
        tag?: string;
        /**
         * Optional. The dlna device profile id to utilize.
         */
        deviceProfileId?: string;
        /**
         * The play session id.
         */
        playSessionId?: string;
        /**
         * The segment container.
         */
        segmentContainer?: string;
        /**
         * The segment length.
         */
        segmentLength?: number;
        /**
         * The minimum number of segments.
         */
        minSegments?: number;
        /**
         * The media version id, if playing an alternate version.
         */
        mediaSourceId?: string;
        /**
         * The device id of the client requesting. Used to stop encoding processes when needed.
         */
        deviceId?: string;
        /**
         * Optional. Specify an audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension.
         */
        audioCodec?: string;
        /**
         * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         */
        enableAutoStreamCopy?: boolean;
        /**
         * Whether or not to allow copying of the video stream url.
         */
        allowVideoStreamCopy?: boolean;
        /**
         * Whether or not to allow copying of the audio stream url.
         */
        allowAudioStreamCopy?: boolean;
        /**
         * Optional. Whether to break on non key frames.
         */
        breakOnNonKeyFrames?: boolean;
        /**
         * Optional. Specify a specific audio sample rate, e.g. 44100.
         */
        audioSampleRate?: number;
        /**
         * Optional. The maximum audio bit depth.
         */
        maxAudioBitDepth?: number;
        /**
         * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         */
        audioBitRate?: number;
        /**
         * Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         */
        audioChannels?: number;
        /**
         * Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         */
        maxAudioChannels?: number;
        /**
         * Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         */
        profile?: string;
        /**
         * Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         */
        level?: string;
        /**
         * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         */
        framerate?: number;
        /**
         * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         */
        maxFramerate?: number;
        /**
         * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         */
        copyTimestamps?: boolean;
        /**
         * Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
         */
        startTimeTicks?: number;
        /**
         * Optional. The fixed horizontal resolution of the encoded video.
         */
        width?: number;
        /**
         * Optional. The fixed vertical resolution of the encoded video.
         */
        height?: number;
        /**
         * Optional. The maximum horizontal resolution of the encoded video.
         */
        maxWidth?: number;
        /**
         * Optional. The maximum vertical resolution of the encoded video.
         */
        maxHeight?: number;
        /**
         * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         */
        videoBitRate?: number;
        /**
         * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         */
        subtitleStreamIndex?: number;
        /**
         * Optional. Specify the subtitle delivery method.
         */
        subtitleMethod?: 'Encode' | 'Embed' | 'External' | 'Hls' | 'Drop';
        /**
         * Optional.
         */
        maxRefFrames?: number;
        /**
         * Optional. The maximum video bit depth.
         */
        maxVideoBitDepth?: number;
        /**
         * Optional. Whether to require avc.
         */
        requireAvc?: boolean;
        /**
         * Optional. Whether to deinterlace the video.
         */
        deInterlace?: boolean;
        /**
         * Optional. Whether to require a non anamorphic stream.
         */
        requireNonAnamorphic?: boolean;
        /**
         * Optional. The maximum number of audio channels to transcode.
         */
        transcodingMaxAudioChannels?: number;
        /**
         * Optional. The limit of how many cpu cores to use.
         */
        cpuCoreLimit?: number;
        /**
         * The live stream id.
         */
        liveStreamId?: string;
        /**
         * Optional. Whether to enable the MpegtsM2Ts mode.
         */
        enableMpegtsM2TsMode?: boolean;
        /**
         * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension.
         */
        videoCodec?: string;
        /**
         * Optional. Specify a subtitle codec to encode to.
         */
        subtitleCodec?: string;
        /**
         * Optional. The transcoding reason.
         */
        transcodeReasons?: string;
        /**
         * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         */
        audioStreamIndex?: number;
        /**
         * Optional. The index of the video stream to use. If omitted the first video stream will be used.
         */
        videoStreamIndex?: number;
        /**
         * Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         */
        context?: 'Streaming' | 'Static';
        /**
         * Optional. The streaming options.
         */
        streamOptions?: {
            [key: string]: string | null;
        };
        /**
         * Optional. Whether to enable Audio Encoding.
         */
        enableAudioVbrEncoding?: boolean;
    };
    url: '/Videos/{itemId}/stream.{container}';
};

export type HeadVideoStreamByContainerResponses = {
    /**
     * Video stream returned.
     */
    200: Blob | File;
};

export type HeadVideoStreamByContainerResponse = HeadVideoStreamByContainerResponses[keyof HeadVideoStreamByContainerResponses];

export type MergeVersionsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Item id list. This allows multiple, comma delimited.
         */
        ids: Array<string>;
    };
    url: '/Videos/MergeVersions';
};

export type MergeVersionsErrors = {
    /**
     * Supply at least 2 video ids.
     */
    400: ProblemDetails;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type MergeVersionsError = MergeVersionsErrors[keyof MergeVersionsErrors];

export type MergeVersionsResponses = {
    /**
     * Videos merged.
     */
    204: void;
};

export type MergeVersionsResponse = MergeVersionsResponses[keyof MergeVersionsResponses];

export type GetYearsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Skips over a given number of items within the results. Use for paging.
         */
        startIndex?: number;
        /**
         * Optional. The maximum number of records to return.
         */
        limit?: number;
        /**
         * Sort Order - Ascending,Descending.
         */
        sortOrder?: Array<SortOrder>;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root.
         */
        parentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output.
         */
        fields?: Array<ItemFields>;
        /**
         * Optional. If specified, results will be excluded based on item type. This allows multiple, comma delimited.
         */
        excludeItemTypes?: Array<BaseItemKind>;
        /**
         * Optional. If specified, results will be included based on item type. This allows multiple, comma delimited.
         */
        includeItemTypes?: Array<BaseItemKind>;
        /**
         * Optional. Filter by MediaType. Allows multiple, comma delimited.
         */
        mediaTypes?: Array<MediaType>;
        /**
         * Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         */
        sortBy?: Array<ItemSortBy>;
        /**
         * Optional. Include user data.
         */
        enableUserData?: boolean;
        /**
         * Optional. The max number of images to return, per image type.
         */
        imageTypeLimit?: number;
        /**
         * Optional. The image types to include in the output.
         */
        enableImageTypes?: Array<ImageType>;
        /**
         * User Id.
         */
        userId?: string;
        /**
         * Search recursively.
         */
        recursive?: boolean;
        /**
         * Optional. Include image information in output.
         */
        enableImages?: boolean;
    };
    url: '/Years';
};

export type GetYearsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetYearsResponses = {
    /**
     * Year query returned.
     */
    200: BaseItemDtoQueryResult;
};

export type GetYearsResponse = GetYearsResponses[keyof GetYearsResponses];

export type GetYearData = {
    body?: never;
    path: {
        /**
         * The year.
         */
        year: number;
    };
    query?: {
        /**
         * Optional. Filter by user id, and attach user data.
         */
        userId?: string;
    };
    url: '/Years/{year}';
};

export type GetYearErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Year not found.
     */
    404: ProblemDetails;
};

export type GetYearError = GetYearErrors[keyof GetYearErrors];

export type GetYearResponses = {
    /**
     * Year returned.
     */
    200: BaseItemDto;
};

export type GetYearResponse = GetYearResponses[keyof GetYearResponses];

export type ClientOptions = {
    baseUrl: 'https://jellyfin.pikarocks.dev' | (string & {});
};